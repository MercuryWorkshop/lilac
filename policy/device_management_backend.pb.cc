// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: device_management_backend.proto

#include "device_management_backend.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace enterprise_management {
PROTOBUF_CONSTEXPR LicenseType::LicenseType(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.license_type_)*/0} {}
struct LicenseTypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LicenseTypeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LicenseTypeDefaultTypeInternal() {}
  union {
    LicenseType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LicenseTypeDefaultTypeInternal _LicenseType_default_instance_;
PROTOBUF_CONSTEXPR SignedData::SignedData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.extra_data_bytes_)*/0} {}
struct SignedDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignedDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignedDataDefaultTypeInternal() {}
  union {
    SignedData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignedDataDefaultTypeInternal _SignedData_default_instance_;
PROTOBUF_CONSTEXPR CheckUserAccountRequest::CheckUserAccountRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_email_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CheckUserAccountRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckUserAccountRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckUserAccountRequestDefaultTypeInternal() {}
  union {
    CheckUserAccountRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckUserAccountRequestDefaultTypeInternal _CheckUserAccountRequest_default_instance_;
PROTOBUF_CONSTEXPR DeviceRegisterRequest::DeviceRegisterRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.machine_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.machine_model_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.requisition_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.server_backed_state_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.brand_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reregistration_dm_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ethernet_mac_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dock_mac_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.manufacture_date_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.expected_enrollment_domain_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.license_type_)*/nullptr
  , /*decltype(_impl_.device_register_identification_)*/nullptr
  , /*decltype(_impl_.reregister_)*/false
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.flavor_)*/0
  , /*decltype(_impl_.psm_execution_result_)*/0
  , /*decltype(_impl_.psm_determination_timestamp_ms_)*/int64_t{0}
  , /*decltype(_impl_.lifetime_)*/1} {}
struct DeviceRegisterRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceRegisterRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceRegisterRequestDefaultTypeInternal() {}
  union {
    DeviceRegisterRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceRegisterRequestDefaultTypeInternal _DeviceRegisterRequest_default_instance_;
PROTOBUF_CONSTEXPR DeviceRegisterIdentification::DeviceRegisterIdentification(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attested_device_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeviceRegisterIdentificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceRegisterIdentificationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceRegisterIdentificationDefaultTypeInternal() {}
  union {
    DeviceRegisterIdentification _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceRegisterIdentificationDefaultTypeInternal _DeviceRegisterIdentification_default_instance_;
PROTOBUF_CONSTEXPR CheckUserAccountResponse::CheckUserAccountResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.domain_verified_)*/false
  , /*decltype(_impl_.user_account_type_)*/0} {}
struct CheckUserAccountResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckUserAccountResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckUserAccountResponseDefaultTypeInternal() {}
  union {
    CheckUserAccountResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckUserAccountResponseDefaultTypeInternal _CheckUserAccountResponse_default_instance_;
PROTOBUF_CONSTEXPR DeviceRegisterResponse::DeviceRegisterResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_affiliation_ids_)*/{}
  , /*decltype(_impl_.device_management_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.machine_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.configuration_seed_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.directory_api_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.enrollment_type_)*/0} {}
struct DeviceRegisterResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceRegisterResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceRegisterResponseDefaultTypeInternal() {}
  union {
    DeviceRegisterResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceRegisterResponseDefaultTypeInternal _DeviceRegisterResponse_default_instance_;
PROTOBUF_CONSTEXPR DeviceUnregisterRequest::DeviceUnregisterRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct DeviceUnregisterRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceUnregisterRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceUnregisterRequestDefaultTypeInternal() {}
  union {
    DeviceUnregisterRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceUnregisterRequestDefaultTypeInternal _DeviceUnregisterRequest_default_instance_;
PROTOBUF_CONSTEXPR DeviceUnregisterResponse::DeviceUnregisterResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct DeviceUnregisterResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceUnregisterResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceUnregisterResponseDefaultTypeInternal() {}
  union {
    DeviceUnregisterResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceUnregisterResponseDefaultTypeInternal _DeviceUnregisterResponse_default_instance_;
PROTOBUF_CONSTEXPR DeviceCertUploadRequest::DeviceCertUploadRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_certificate_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.enrollment_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.certificate_type_)*/0} {}
struct DeviceCertUploadRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceCertUploadRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceCertUploadRequestDefaultTypeInternal() {}
  union {
    DeviceCertUploadRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceCertUploadRequestDefaultTypeInternal _DeviceCertUploadRequest_default_instance_;
PROTOBUF_CONSTEXPR DeviceCertUploadResponse::DeviceCertUploadResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct DeviceCertUploadResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceCertUploadResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceCertUploadResponseDefaultTypeInternal() {}
  union {
    DeviceCertUploadResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceCertUploadResponseDefaultTypeInternal _DeviceCertUploadResponse_default_instance_;
PROTOBUF_CONSTEXPR DeviceServiceApiAccessRequest::DeviceServiceApiAccessRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.auth_scopes_)*/{}
  , /*decltype(_impl_.oauth2_client_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_type_)*/0} {}
struct DeviceServiceApiAccessRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceServiceApiAccessRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceServiceApiAccessRequestDefaultTypeInternal() {}
  union {
    DeviceServiceApiAccessRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceServiceApiAccessRequestDefaultTypeInternal _DeviceServiceApiAccessRequest_default_instance_;
PROTOBUF_CONSTEXPR DeviceServiceApiAccessResponse::DeviceServiceApiAccessResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.auth_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeviceServiceApiAccessResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceServiceApiAccessResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceServiceApiAccessResponseDefaultTypeInternal() {}
  union {
    DeviceServiceApiAccessResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceServiceApiAccessResponseDefaultTypeInternal _DeviceServiceApiAccessResponse_default_instance_;
PROTOBUF_CONSTEXPR BrowserDeviceIdentifier::BrowserDeviceIdentifier(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.computer_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.serial_number_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct BrowserDeviceIdentifierDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BrowserDeviceIdentifierDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BrowserDeviceIdentifierDefaultTypeInternal() {}
  union {
    BrowserDeviceIdentifier _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BrowserDeviceIdentifierDefaultTypeInternal _BrowserDeviceIdentifier_default_instance_;
PROTOBUF_CONSTEXPR PolicyFetchRequest::PolicyFetchRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.policy_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.settings_entity_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.invalidation_payload_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.verification_key_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.policy_invalidation_info_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_dm_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.browser_device_identifier_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_.signature_type_)*/0
  , /*decltype(_impl_.public_key_version_)*/0
  , /*decltype(_impl_.invalidation_version_)*/int64_t{0}
  , /*decltype(_impl_.invalidation_topics_only_)*/false} {}
struct PolicyFetchRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PolicyFetchRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PolicyFetchRequestDefaultTypeInternal() {}
  union {
    PolicyFetchRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PolicyFetchRequestDefaultTypeInternal _PolicyFetchRequest_default_instance_;
PROTOBUF_CONSTEXPR DisabledState::DisabledState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DisabledStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DisabledStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DisabledStateDefaultTypeInternal() {}
  union {
    DisabledState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DisabledStateDefaultTypeInternal _DisabledState_default_instance_;
PROTOBUF_CONSTEXPR DeviceState::DeviceState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.disabled_state_)*/nullptr
  , /*decltype(_impl_.device_mode_)*/0} {}
struct DeviceStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceStateDefaultTypeInternal() {}
  union {
    DeviceState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceStateDefaultTypeInternal _DeviceState_default_instance_;
PROTOBUF_CONSTEXPR CustomerLogo::CustomerLogo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.logo_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CustomerLogoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CustomerLogoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CustomerLogoDefaultTypeInternal() {}
  union {
    CustomerLogo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CustomerLogoDefaultTypeInternal _CustomerLogo_default_instance_;
PROTOBUF_CONSTEXPR PolicyData::PolicyData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_affiliation_ids_)*/{}
  , /*decltype(_impl_.user_affiliation_ids_)*/{}
  , /*decltype(_impl_.policy_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.request_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.policy_value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.machine_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.username_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.settings_entity_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.service_account_identity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.policy_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.annotated_location_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.annotated_asset_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.directory_api_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.display_domain_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.policy_invalidation_topic_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.command_invalidation_topic_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gaia_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.change_password_uri_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.obfuscated_customer_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.managed_by_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sso_profile_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.license_sku_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_state_)*/nullptr
  , /*decltype(_impl_.customer_logo_)*/nullptr
  , /*decltype(_impl_.client_action_required_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_.public_key_version_)*/0
  , /*decltype(_impl_.state_)*/0
  , /*decltype(_impl_.management_mode_)*/0
  , /*decltype(_impl_.enrollment_id_needed_)*/false
  , /*decltype(_impl_.market_segment_)*/0
  , /*decltype(_impl_.metrics_log_segment_)*/0} {}
struct PolicyDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PolicyDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PolicyDataDefaultTypeInternal() {}
  union {
    PolicyData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PolicyDataDefaultTypeInternal _PolicyData_default_instance_;
PROTOBUF_CONSTEXPR ClientActionRequired::ClientActionRequired(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enrollment_certificate_needed_)*/false} {}
struct ClientActionRequiredDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientActionRequiredDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientActionRequiredDefaultTypeInternal() {}
  union {
    ClientActionRequired _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientActionRequiredDefaultTypeInternal _ClientActionRequired_default_instance_;
PROTOBUF_CONSTEXPR PolicyFetchResponse::PolicyFetchResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.error_message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.policy_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.policy_data_signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.new_public_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.new_public_key_signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.new_public_key_verification_signature_deprecated_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.new_public_key_verification_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.new_public_key_verification_data_signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.policy_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_code_)*/0
  , /*decltype(_impl_.policy_data_signature_type_)*/0} {}
struct PolicyFetchResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PolicyFetchResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PolicyFetchResponseDefaultTypeInternal() {}
  union {
    PolicyFetchResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PolicyFetchResponseDefaultTypeInternal _PolicyFetchResponse_default_instance_;
PROTOBUF_CONSTEXPR DEPRECATEDPolicyPublicKeyAndDomain::DEPRECATEDPolicyPublicKeyAndDomain(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.new_public_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.domain_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DEPRECATEDPolicyPublicKeyAndDomainDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DEPRECATEDPolicyPublicKeyAndDomainDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DEPRECATEDPolicyPublicKeyAndDomainDefaultTypeInternal() {}
  union {
    DEPRECATEDPolicyPublicKeyAndDomain _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DEPRECATEDPolicyPublicKeyAndDomainDefaultTypeInternal _DEPRECATEDPolicyPublicKeyAndDomain_default_instance_;
PROTOBUF_CONSTEXPR PublicKeyVerificationData::PublicKeyVerificationData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.new_public_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.domain_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.new_public_key_version_)*/0} {}
struct PublicKeyVerificationDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PublicKeyVerificationDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PublicKeyVerificationDataDefaultTypeInternal() {}
  union {
    PublicKeyVerificationData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PublicKeyVerificationDataDefaultTypeInternal _PublicKeyVerificationData_default_instance_;
PROTOBUF_CONSTEXPR DevicePolicyRequest::DevicePolicyRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.requests_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DevicePolicyRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DevicePolicyRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DevicePolicyRequestDefaultTypeInternal() {}
  union {
    DevicePolicyRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DevicePolicyRequestDefaultTypeInternal _DevicePolicyRequest_default_instance_;
PROTOBUF_CONSTEXPR DevicePolicyResponse::DevicePolicyResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.responses_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DevicePolicyResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DevicePolicyResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DevicePolicyResponseDefaultTypeInternal() {}
  union {
    DevicePolicyResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DevicePolicyResponseDefaultTypeInternal _DevicePolicyResponse_default_instance_;
PROTOBUF_CONSTEXPR TimePeriod::TimePeriod(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.start_timestamp_)*/int64_t{0}
  , /*decltype(_impl_.end_timestamp_)*/int64_t{0}} {}
struct TimePeriodDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimePeriodDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimePeriodDefaultTypeInternal() {}
  union {
    TimePeriod _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimePeriodDefaultTypeInternal _TimePeriod_default_instance_;
PROTOBUF_CONSTEXPR ActiveTimePeriod::ActiveTimePeriod(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_email_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.time_period_)*/nullptr
  , /*decltype(_impl_.active_duration_)*/0
  , /*decltype(_impl_.session_type_)*/0} {}
struct ActiveTimePeriodDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActiveTimePeriodDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActiveTimePeriodDefaultTypeInternal() {}
  union {
    ActiveTimePeriod _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActiveTimePeriodDefaultTypeInternal _ActiveTimePeriod_default_instance_;
PROTOBUF_CONSTEXPR NetworkInterface::NetworkInterface(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.eids_)*/{}
  , /*decltype(_impl_.mac_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.meid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.imei_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.iccid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mdn_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0} {}
struct NetworkInterfaceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetworkInterfaceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetworkInterfaceDefaultTypeInternal() {}
  union {
    NetworkInterface _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkInterfaceDefaultTypeInternal _NetworkInterface_default_instance_;
PROTOBUF_CONSTEXPR NetworkState::NetworkState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ip_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gateway_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.connection_state_)*/0
  , /*decltype(_impl_.signal_strength_)*/0} {}
struct NetworkStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetworkStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetworkStateDefaultTypeInternal() {}
  union {
    NetworkState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkStateDefaultTypeInternal _NetworkState_default_instance_;
PROTOBUF_CONSTEXPR DeviceUser::DeviceUser(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.email_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0} {}
struct DeviceUserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceUserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceUserDefaultTypeInternal() {}
  union {
    DeviceUser _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceUserDefaultTypeInternal _DeviceUser_default_instance_;
PROTOBUF_CONSTEXPR VolumeInfo::VolumeInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.volume_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.storage_total_)*/int64_t{0}
  , /*decltype(_impl_.storage_free_)*/int64_t{0}} {}
struct VolumeInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VolumeInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VolumeInfoDefaultTypeInternal() {}
  union {
    VolumeInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VolumeInfoDefaultTypeInternal _VolumeInfo_default_instance_;
PROTOBUF_CONSTEXPR CpuUtilizationInfo::CpuUtilizationInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_.cpu_utilization_pct_)*/0} {}
struct CpuUtilizationInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CpuUtilizationInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CpuUtilizationInfoDefaultTypeInternal() {}
  union {
    CpuUtilizationInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CpuUtilizationInfoDefaultTypeInternal _CpuUtilizationInfo_default_instance_;
PROTOBUF_CONSTEXPR SystemFreeRamInfo::SystemFreeRamInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.size_in_bytes_)*/int64_t{0}
  , /*decltype(_impl_.timestamp_)*/int64_t{0}} {}
struct SystemFreeRamInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemFreeRamInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemFreeRamInfoDefaultTypeInternal() {}
  union {
    SystemFreeRamInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemFreeRamInfoDefaultTypeInternal _SystemFreeRamInfo_default_instance_;
PROTOBUF_CONSTEXPR CPUTempInfo::CPUTempInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cpu_label_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_.cpu_temp_)*/0} {}
struct CPUTempInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CPUTempInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CPUTempInfoDefaultTypeInternal() {}
  union {
    CPUTempInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CPUTempInfoDefaultTypeInternal _CPUTempInfo_default_instance_;
PROTOBUF_CONSTEXPR StatefulPartitionInfo::StatefulPartitionInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.filesystem_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mount_source_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.available_space_)*/uint64_t{0u}
  , /*decltype(_impl_.total_space_)*/uint64_t{0u}} {}
struct StatefulPartitionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatefulPartitionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatefulPartitionInfoDefaultTypeInternal() {}
  union {
    StatefulPartitionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatefulPartitionInfoDefaultTypeInternal _StatefulPartitionInfo_default_instance_;
PROTOBUF_CONSTEXPR BatterySample::BatterySample(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_.voltage_)*/int64_t{0}
  , /*decltype(_impl_.remaining_capacity_)*/int64_t{0}
  , /*decltype(_impl_.temperature_)*/0
  , /*decltype(_impl_.discharge_rate_)*/0
  , /*decltype(_impl_.current_)*/int64_t{0}
  , /*decltype(_impl_.charge_rate_)*/0} {}
struct BatterySampleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatterySampleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatterySampleDefaultTypeInternal() {}
  union {
    BatterySample _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatterySampleDefaultTypeInternal _BatterySample_default_instance_;
PROTOBUF_CONSTEXPR BatteryInfo::BatteryInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.samples_)*/{}
  , /*decltype(_impl_.serial_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.manufacturer_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.battery_health_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.manufacture_date_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.technology_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.design_capacity_)*/int64_t{0}
  , /*decltype(_impl_.full_charge_capacity_)*/int64_t{0}
  , /*decltype(_impl_.cycle_count_)*/0
  , /*decltype(_impl_.design_min_voltage_)*/0} {}
struct BatteryInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatteryInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatteryInfoDefaultTypeInternal() {}
  union {
    BatteryInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatteryInfoDefaultTypeInternal _BatteryInfo_default_instance_;
PROTOBUF_CONSTEXPR PowerStatus::PowerStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.batteries_)*/{}
  , /*decltype(_impl_.power_source_)*/0} {}
struct PowerStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PowerStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PowerStatusDefaultTypeInternal() {}
  union {
    PowerStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PowerStatusDefaultTypeInternal _PowerStatus_default_instance_;
PROTOBUF_CONSTEXPR DiskLifetimeEstimation::DiskLifetimeEstimation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.slc_)*/0
  , /*decltype(_impl_.mlc_)*/0} {}
struct DiskLifetimeEstimationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DiskLifetimeEstimationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DiskLifetimeEstimationDefaultTypeInternal() {}
  union {
    DiskLifetimeEstimation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DiskLifetimeEstimationDefaultTypeInternal _DiskLifetimeEstimation_default_instance_;
PROTOBUF_CONSTEXPR DiskInfo::DiskInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.volumes_)*/{}
  , /*decltype(_impl_.serial_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.manufacturer_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.model_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.health_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.size_)*/int64_t{0}
  , /*decltype(_impl_.bytes_read_since_last_boot_)*/uint64_t{0u}
  , /*decltype(_impl_.bytes_written_since_last_boot_)*/uint64_t{0u}
  , /*decltype(_impl_.read_time_seconds_since_last_boot_)*/uint64_t{0u}
  , /*decltype(_impl_.write_time_seconds_since_last_boot_)*/uint64_t{0u}
  , /*decltype(_impl_.io_time_seconds_since_last_boot_)*/uint64_t{0u}
  , /*decltype(_impl_.discard_time_seconds_since_last_boot_)*/uint64_t{0u}
  , /*decltype(_impl_.purpose_)*/0
  , /*decltype(_impl_.vendor_id_)*/{}
  , /*decltype(_impl_.product_id_)*/{}
  , /*decltype(_impl_.hardware_revision_)*/{}
  , /*decltype(_impl_.firmware_revision_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct DiskInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DiskInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DiskInfoDefaultTypeInternal() {}
  union {
    DiskInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DiskInfoDefaultTypeInternal _DiskInfo_default_instance_;
PROTOBUF_CONSTEXPR StorageStatus::StorageStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.disks_)*/{}
  , /*decltype(_impl_.lifetime_estimation_)*/nullptr} {}
struct StorageStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StorageStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StorageStatusDefaultTypeInternal() {}
  union {
    StorageStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StorageStatusDefaultTypeInternal _StorageStatus_default_instance_;
PROTOBUF_CONSTEXPR ThermalSample::ThermalSample(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_.temperature_)*/0} {}
struct ThermalSampleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThermalSampleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThermalSampleDefaultTypeInternal() {}
  union {
    ThermalSample _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThermalSampleDefaultTypeInternal _ThermalSample_default_instance_;
PROTOBUF_CONSTEXPR ThermalInfo::ThermalInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.samples_)*/{}
  , /*decltype(_impl_.label_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ThermalInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThermalInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThermalInfoDefaultTypeInternal() {}
  union {
    ThermalInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThermalInfoDefaultTypeInternal _ThermalInfo_default_instance_;
PROTOBUF_CONSTEXPR BoardStatus::BoardStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.thermal_infos_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BoardStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BoardStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BoardStatusDefaultTypeInternal() {}
  union {
    BoardStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoardStatusDefaultTypeInternal _BoardStatus_default_instance_;
PROTOBUF_CONSTEXPR SystemStatus::SystemStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vpd_sku_number_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.first_power_date_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.manufacture_date_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.marketing_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bios_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.board_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.board_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.product_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.vpd_serial_number_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.chassis_type_)*/uint64_t{0u}} {}
struct SystemStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemStatusDefaultTypeInternal() {}
  union {
    SystemStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemStatusDefaultTypeInternal _SystemStatus_default_instance_;
PROTOBUF_CONSTEXPR CpuCStateInfo::CpuCStateInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.time_in_state_since_last_boot_us_)*/uint64_t{0u}} {}
struct CpuCStateInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CpuCStateInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CpuCStateInfoDefaultTypeInternal() {}
  union {
    CpuCStateInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CpuCStateInfoDefaultTypeInternal _CpuCStateInfo_default_instance_;
PROTOBUF_CONSTEXPR LogicalCpuInfo::LogicalCpuInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.c_states_)*/{}
  , /*decltype(_impl_.scaling_max_frequency_khz_)*/0u
  , /*decltype(_impl_.scaling_current_frequency_khz_)*/0u
  , /*decltype(_impl_.idle_time_seconds_)*/uint64_t{0u}} {}
struct LogicalCpuInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogicalCpuInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogicalCpuInfoDefaultTypeInternal() {}
  union {
    LogicalCpuInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogicalCpuInfoDefaultTypeInternal _LogicalCpuInfo_default_instance_;
PROTOBUF_CONSTEXPR CpuInfo::CpuInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.logical_cpus_)*/{}
  , /*decltype(_impl_.model_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.architecture_)*/0
  , /*decltype(_impl_.max_clock_speed_khz_)*/0u} {}
struct CpuInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CpuInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CpuInfoDefaultTypeInternal() {}
  union {
    CpuInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CpuInfoDefaultTypeInternal _CpuInfo_default_instance_;
PROTOBUF_CONSTEXPR GlobalCpuInfo::GlobalCpuInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.num_total_threads_)*/0u} {}
struct GlobalCpuInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GlobalCpuInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GlobalCpuInfoDefaultTypeInternal() {}
  union {
    GlobalCpuInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GlobalCpuInfoDefaultTypeInternal _GlobalCpuInfo_default_instance_;
PROTOBUF_CONSTEXPR DisplayInfo::DisplayInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.resolution_width_)*/0u
  , /*decltype(_impl_.resolution_height_)*/0u
  , /*decltype(_impl_.refresh_rate_)*/0u
  , /*decltype(_impl_.is_internal_)*/false} {}
struct DisplayInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DisplayInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DisplayInfoDefaultTypeInternal() {}
  union {
    DisplayInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DisplayInfoDefaultTypeInternal _DisplayInfo_default_instance_;
PROTOBUF_CONSTEXPR GraphicsAdapterInfo::GraphicsAdapterInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.driver_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_id_)*/uint64_t{0u}
  , /*decltype(_impl_.system_ram_usage_)*/uint64_t{0u}} {}
struct GraphicsAdapterInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GraphicsAdapterInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GraphicsAdapterInfoDefaultTypeInternal() {}
  union {
    GraphicsAdapterInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GraphicsAdapterInfoDefaultTypeInternal _GraphicsAdapterInfo_default_instance_;
PROTOBUF_CONSTEXPR GraphicsStatus::GraphicsStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.displays_)*/{}
  , /*decltype(_impl_.adapter_)*/nullptr} {}
struct GraphicsStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GraphicsStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GraphicsStatusDefaultTypeInternal() {}
  union {
    GraphicsStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GraphicsStatusDefaultTypeInternal _GraphicsStatus_default_instance_;
PROTOBUF_CONSTEXPR CrashReportInfo::CrashReportInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.remote_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cause_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.capture_timestamp_)*/int64_t{0}
  , /*decltype(_impl_.upload_status_)*/0} {}
struct CrashReportInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CrashReportInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CrashReportInfoDefaultTypeInternal() {}
  union {
    CrashReportInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CrashReportInfoDefaultTypeInternal _CrashReportInfo_default_instance_;
PROTOBUF_CONSTEXPR TimezoneInfo::TimezoneInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.posix_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.region_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct TimezoneInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimezoneInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimezoneInfoDefaultTypeInternal() {}
  union {
    TimezoneInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimezoneInfoDefaultTypeInternal _TimezoneInfo_default_instance_;
PROTOBUF_CONSTEXPR MemoryInfo::MemoryInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.total_memory_kib_)*/0u
  , /*decltype(_impl_.free_memory_kib_)*/0u
  , /*decltype(_impl_.page_faults_since_last_boot_)*/uint64_t{0u}
  , /*decltype(_impl_.available_memory_kib_)*/0u} {}
struct MemoryInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MemoryInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MemoryInfoDefaultTypeInternal() {}
  union {
    MemoryInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MemoryInfoDefaultTypeInternal _MemoryInfo_default_instance_;
PROTOBUF_CONSTEXPR BacklightInfo::BacklightInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.max_brightness_)*/0u
  , /*decltype(_impl_.brightness_)*/0u} {}
struct BacklightInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BacklightInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BacklightInfoDefaultTypeInternal() {}
  union {
    BacklightInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BacklightInfoDefaultTypeInternal _BacklightInfo_default_instance_;
PROTOBUF_CONSTEXPR FanInfo::FanInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.speed_rpm_)*/0u} {}
struct FanInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FanInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FanInfoDefaultTypeInternal() {}
  union {
    FanInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FanInfoDefaultTypeInternal _FanInfo_default_instance_;
PROTOBUF_CONSTEXPR BluetoothAdapterInfo::BluetoothAdapterInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.powered_)*/false
  , /*decltype(_impl_.num_connected_devices_)*/0u} {}
struct BluetoothAdapterInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BluetoothAdapterInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BluetoothAdapterInfoDefaultTypeInternal() {}
  union {
    BluetoothAdapterInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BluetoothAdapterInfoDefaultTypeInternal _BluetoothAdapterInfo_default_instance_;
PROTOBUF_CONSTEXPR SmbiosInfo::SmbiosInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sys_vendor_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.product_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.product_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bios_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct SmbiosInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SmbiosInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SmbiosInfoDefaultTypeInternal() {}
  union {
    SmbiosInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SmbiosInfoDefaultTypeInternal _SmbiosInfo_default_instance_;
PROTOBUF_CONSTEXPR KernelParameters::KernelParameters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cros_efi_)*/false} {}
struct KernelParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KernelParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KernelParametersDefaultTypeInternal() {}
  union {
    KernelParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KernelParametersDefaultTypeInternal _KernelParameters_default_instance_;
PROTOBUF_CONSTEXPR EFIVars::EFIVars(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.secure_boot_)*/false} {}
struct EFIVarsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EFIVarsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EFIVarsDefaultTypeInternal() {}
  union {
    EFIVars _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EFIVarsDefaultTypeInternal _EFIVars_default_instance_;
PROTOBUF_CONSTEXPR BootInfo::BootInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.boot_method_)*/0
  , /*decltype(_impl_.secure_boot_)*/false} {}
struct BootInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BootInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BootInfoDefaultTypeInternal() {}
  union {
    BootInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BootInfoDefaultTypeInternal _BootInfo_default_instance_;
PROTOBUF_CONSTEXPR NetworkAdapterInfo::NetworkAdapterInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.driver_)*/{}
  , /*decltype(_impl_.vendor_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_class_)*/0
  , /*decltype(_impl_.bus_type_)*/0
  , /*decltype(_impl_.vendor_id_)*/0
  , /*decltype(_impl_.device_id_)*/0} {}
struct NetworkAdapterInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetworkAdapterInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetworkAdapterInfoDefaultTypeInternal() {}
  union {
    NetworkAdapterInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkAdapterInfoDefaultTypeInternal _NetworkAdapterInfo_default_instance_;
PROTOBUF_CONSTEXPR LaCrOsBrowserReport::LaCrOsBrowserReport(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_user_)*/nullptr
  , /*decltype(_impl_.browser_report_)*/nullptr} {}
struct LaCrOsBrowserReportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LaCrOsBrowserReportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LaCrOsBrowserReportDefaultTypeInternal() {}
  union {
    LaCrOsBrowserReport _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LaCrOsBrowserReportDefaultTypeInternal _LaCrOsBrowserReport_default_instance_;
PROTOBUF_CONSTEXPR DeviceStatusReportRequest::DeviceStatusReportRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.active_periods_)*/{}
  , /*decltype(_impl_.network_interfaces_)*/{}
  , /*decltype(_impl_.users_)*/{}
  , /*decltype(_impl_.volume_infos_)*/{}
  , /*decltype(_impl_.network_states_)*/{}
  , /*decltype(_impl_.cpu_utilization_pct_samples_)*/{}
  , /*decltype(_impl_.system_ram_free_samples_)*/{}
  , /*decltype(_impl_.cpu_temp_infos_)*/{}
  , /*decltype(_impl_.cpu_utilization_infos_)*/{}
  , /*decltype(_impl_.system_ram_free_infos_)*/{}
  , /*decltype(_impl_.cpu_info_)*/{}
  , /*decltype(_impl_.crash_report_infos_)*/{}
  , /*decltype(_impl_.backlight_info_)*/{}
  , /*decltype(_impl_.fan_info_)*/{}
  , /*decltype(_impl_.bluetooth_adapter_info_)*/{}
  , /*decltype(_impl_.network_adapter_info_)*/{}
  , /*decltype(_impl_.lacros_browser_report_)*/{}
  , /*decltype(_impl_.os_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.firmware_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.boot_mode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.browser_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.os_update_status_)*/nullptr
  , /*decltype(_impl_.running_kiosk_app_)*/nullptr
  , /*decltype(_impl_.tpm_version_info_)*/nullptr
  , /*decltype(_impl_.tpm_status_info_)*/nullptr
  , /*decltype(_impl_.power_status_)*/nullptr
  , /*decltype(_impl_.storage_status_)*/nullptr
  , /*decltype(_impl_.board_status_)*/nullptr
  , /*decltype(_impl_.system_status_)*/nullptr
  , /*decltype(_impl_.stateful_partition_info_)*/nullptr
  , /*decltype(_impl_.graphics_status_)*/nullptr
  , /*decltype(_impl_.timezone_info_)*/nullptr
  , /*decltype(_impl_.memory_info_)*/nullptr
  , /*decltype(_impl_.global_cpu_info_)*/nullptr
  , /*decltype(_impl_.smbios_info_)*/nullptr
  , /*decltype(_impl_.kernel_parameters_)*/nullptr
  , /*decltype(_impl_.efi_vars_)*/nullptr
  , /*decltype(_impl_.boot_info_)*/nullptr
  , /*decltype(_impl_.system_ram_total_)*/int64_t{0}
  , /*decltype(_impl_.sound_volume_)*/0
  , /*decltype(_impl_.channel_)*/0
  , /*decltype(_impl_.root_device_total_storage_bytes_)*/int64_t{0}
  , /*decltype(_impl_.write_protect_switch_)*/false} {}
struct DeviceStatusReportRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceStatusReportRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceStatusReportRequestDefaultTypeInternal() {}
  union {
    DeviceStatusReportRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceStatusReportRequestDefaultTypeInternal _DeviceStatusReportRequest_default_instance_;
PROTOBUF_CONSTEXPR OsUpdateStatus::OsUpdateStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.new_platform_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.new_required_platform_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.last_checked_timestamp_)*/int64_t{0}
  , /*decltype(_impl_.last_reboot_timestamp_)*/int64_t{0}
  , /*decltype(_impl_.update_status_)*/0} {}
struct OsUpdateStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OsUpdateStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OsUpdateStatusDefaultTypeInternal() {}
  union {
    OsUpdateStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OsUpdateStatusDefaultTypeInternal _OsUpdateStatus_default_instance_;
PROTOBUF_CONSTEXPR AppStatus::AppStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.app_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.extension_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.required_platform_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_)*/false} {}
struct AppStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AppStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AppStatusDefaultTypeInternal() {}
  union {
    AppStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AppStatusDefaultTypeInternal _AppStatus_default_instance_;
PROTOBUF_CONSTEXPR AppInfo::AppInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.active_time_periods_)*/{}
  , /*decltype(_impl_.app_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.app_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.app_type_)*/0
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_.install_time_)*/int64_t{0}} {}
struct AppInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AppInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AppInfoDefaultTypeInternal() {}
  union {
    AppInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AppInfoDefaultTypeInternal _AppInfo_default_instance_;
PROTOBUF_CONSTEXPR AndroidAppPermission::AndroidAppPermission(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.granted_)*/false
  , /*decltype(_impl_.managed_)*/false} {}
struct AndroidAppPermissionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AndroidAppPermissionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AndroidAppPermissionDefaultTypeInternal() {}
  union {
    AndroidAppPermission _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AndroidAppPermissionDefaultTypeInternal _AndroidAppPermission_default_instance_;
PROTOBUF_CONSTEXPR AndroidAppInfo::AndroidAppInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.permissions_)*/{}
  , /*decltype(_impl_.app_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.app_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.package_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_.installed_source_)*/0
  , /*decltype(_impl_.version_)*/0} {}
struct AndroidAppInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AndroidAppInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AndroidAppInfoDefaultTypeInternal() {}
  union {
    AndroidAppInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AndroidAppInfoDefaultTypeInternal _AndroidAppInfo_default_instance_;
PROTOBUF_CONSTEXPR ChromeUserProfileReport::ChromeUserProfileReport(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.extension_requests_)*/{}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.chrome_signed_in_user_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.extension_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.plugins_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.policy_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.policy_fetched_timestamp_)*/int64_t{0}
  , /*decltype(_impl_.safe_browsing_warnings_)*/uint64_t{0u}
  , /*decltype(_impl_.safe_browsing_warnings_click_through_)*/uint64_t{0u}} {}
struct ChromeUserProfileReportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChromeUserProfileReportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChromeUserProfileReportDefaultTypeInternal() {}
  union {
    ChromeUserProfileReport _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromeUserProfileReportDefaultTypeInternal _ChromeUserProfileReport_default_instance_;
PROTOBUF_CONSTEXPR ChromeSignedInUser::ChromeSignedInUser(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.email_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.obfuscated_gaia_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ChromeSignedInUserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChromeSignedInUserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChromeSignedInUserDefaultTypeInternal() {}
  union {
    ChromeSignedInUser _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromeSignedInUserDefaultTypeInternal _ChromeSignedInUser_default_instance_;
PROTOBUF_CONSTEXPR ExtensionRequest::ExtensionRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.justification_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.request_timestamp_)*/int64_t{0}} {}
struct ExtensionRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExtensionRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExtensionRequestDefaultTypeInternal() {}
  union {
    ExtensionRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionRequestDefaultTypeInternal _ExtensionRequest_default_instance_;
PROTOBUF_CONSTEXPR Extension::Extension(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.permissions_)*/{}
  , /*decltype(_impl_.host_permissions_)*/{}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.homepage_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.app_type_)*/0
  , /*decltype(_impl_.install_type_)*/0
  , /*decltype(_impl_.enabled_)*/false
  , /*decltype(_impl_.from_webstore_)*/false
  , /*decltype(_impl_.manifest_version_)*/0} {}
struct ExtensionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExtensionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExtensionDefaultTypeInternal() {}
  union {
    Extension _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionDefaultTypeInternal _Extension_default_instance_;
PROTOBUF_CONSTEXPR Plugin::Plugin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PluginDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PluginDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PluginDefaultTypeInternal() {}
  union {
    Plugin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PluginDefaultTypeInternal _Plugin_default_instance_;
PROTOBUF_CONSTEXPR Policy::Policy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.level_)*/0
  , /*decltype(_impl_.scope_)*/0
  , /*decltype(_impl_.source_)*/0} {}
struct PolicyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PolicyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PolicyDefaultTypeInternal() {}
  union {
    Policy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PolicyDefaultTypeInternal _Policy_default_instance_;
PROTOBUF_CONSTEXPR ExtensionPolicy::ExtensionPolicy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.policies_)*/{}
  , /*decltype(_impl_.extension_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ExtensionPolicyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExtensionPolicyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExtensionPolicyDefaultTypeInternal() {}
  union {
    ExtensionPolicy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionPolicyDefaultTypeInternal _ExtensionPolicy_default_instance_;
PROTOBUF_CONSTEXPR PolicyFetchTimestamp::PolicyFetchTimestamp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timestamp_)*/int64_t{0}} {}
struct PolicyFetchTimestampDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PolicyFetchTimestampDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PolicyFetchTimestampDefaultTypeInternal() {}
  union {
    PolicyFetchTimestamp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PolicyFetchTimestampDefaultTypeInternal _PolicyFetchTimestamp_default_instance_;
PROTOBUF_CONSTEXPR ChromeUserProfileInfo::ChromeUserProfileInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.extensions_)*/{}
  , /*decltype(_impl_.chrome_policies_)*/{}
  , /*decltype(_impl_.extension_policies_)*/{}
  , /*decltype(_impl_.policy_fetched_timestamps_)*/{}
  , /*decltype(_impl_.extension_requests_)*/{}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.chrome_signed_in_user_)*/nullptr
  , /*decltype(_impl_.is_detail_available_)*/false} {}
struct ChromeUserProfileInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChromeUserProfileInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChromeUserProfileInfoDefaultTypeInternal() {}
  union {
    ChromeUserProfileInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromeUserProfileInfoDefaultTypeInternal _ChromeUserProfileInfo_default_instance_;
PROTOBUF_CONSTEXPR BrowserReport::BrowserReport(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.chrome_user_profile_reports_)*/{}
  , /*decltype(_impl_.chrome_user_profile_infos_)*/{}
  , /*decltype(_impl_.plugins_)*/{}
  , /*decltype(_impl_.browser_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.executable_path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.installed_browser_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.channel_)*/0
  , /*decltype(_impl_.is_extended_stable_channel_)*/false} {}
struct BrowserReportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BrowserReportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BrowserReportDefaultTypeInternal() {}
  union {
    BrowserReport _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BrowserReportDefaultTypeInternal _BrowserReport_default_instance_;
PROTOBUF_CONSTEXPR OSReport::OSReport(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.arch_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_type_)*/0} {}
struct OSReportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OSReportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OSReportDefaultTypeInternal() {}
  union {
    OSReport _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OSReportDefaultTypeInternal _OSReport_default_instance_;
PROTOBUF_CONSTEXPR ChromeDesktopReportRequest::ChromeDesktopReportRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.partial_report_types_)*/{}
  , /*decltype(_impl_.machine_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.os_info_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.os_user_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.serial_number_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.computer_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.os_user_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.machine_attestation_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_model_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.brand_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.browser_report_)*/nullptr
  , /*decltype(_impl_.os_report_)*/nullptr
  , /*decltype(_impl_.browser_device_identifier_)*/nullptr} {}
struct ChromeDesktopReportRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChromeDesktopReportRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChromeDesktopReportRequestDefaultTypeInternal() {}
  union {
    ChromeDesktopReportRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromeDesktopReportRequestDefaultTypeInternal _ChromeDesktopReportRequest_default_instance_;
PROTOBUF_CONSTEXPR ChromeOsUserReportRequest::ChromeOsUserReportRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.android_app_infos_)*/{}
  , /*decltype(_impl_.partial_report_types_)*/{}
  , /*decltype(_impl_.browser_report_)*/nullptr} {}
struct ChromeOsUserReportRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChromeOsUserReportRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChromeOsUserReportRequestDefaultTypeInternal() {}
  union {
    ChromeOsUserReportRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromeOsUserReportRequestDefaultTypeInternal _ChromeOsUserReportRequest_default_instance_;
PROTOBUF_CONSTEXPR ChromeProfileReportRequest::ChromeProfileReportRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.browser_report_)*/nullptr
  , /*decltype(_impl_.os_report_)*/nullptr} {}
struct ChromeProfileReportRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChromeProfileReportRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChromeProfileReportRequestDefaultTypeInternal() {}
  union {
    ChromeProfileReportRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromeProfileReportRequestDefaultTypeInternal _ChromeProfileReportRequest_default_instance_;
PROTOBUF_CONSTEXPR PolicyValueValidationIssue::PolicyValueValidationIssue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.policy_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.debug_message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.severity_)*/0} {}
struct PolicyValueValidationIssueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PolicyValueValidationIssueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PolicyValueValidationIssueDefaultTypeInternal() {}
  union {
    PolicyValueValidationIssue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PolicyValueValidationIssueDefaultTypeInternal _PolicyValueValidationIssue_default_instance_;
PROTOBUF_CONSTEXPR PolicyValidationReportRequest::PolicyValidationReportRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.policy_value_validation_issues_)*/{}
  , /*decltype(_impl_.policy_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.policy_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.validation_result_type_)*/0} {}
struct PolicyValidationReportRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PolicyValidationReportRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PolicyValidationReportRequestDefaultTypeInternal() {}
  union {
    PolicyValidationReportRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PolicyValidationReportRequestDefaultTypeInternal _PolicyValidationReportRequest_default_instance_;
PROTOBUF_CONSTEXPR PolicyValidationReportResponse::PolicyValidationReportResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct PolicyValidationReportResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PolicyValidationReportResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PolicyValidationReportResponseDefaultTypeInternal() {}
  union {
    PolicyValidationReportResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PolicyValidationReportResponseDefaultTypeInternal _PolicyValidationReportResponse_default_instance_;
PROTOBUF_CONSTEXPR AndroidStatus::AndroidStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.status_payload_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.droid_guard_info_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct AndroidStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AndroidStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AndroidStatusDefaultTypeInternal() {}
  union {
    AndroidStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AndroidStatusDefaultTypeInternal _AndroidStatus_default_instance_;
PROTOBUF_CONSTEXPR CrostiniApp::CrostiniApp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.app_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.package_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.package_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.package_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.last_launch_time_window_start_timestamp_)*/int64_t{0}
  , /*decltype(_impl_.app_type_)*/0} {}
struct CrostiniAppDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CrostiniAppDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CrostiniAppDefaultTypeInternal() {}
  union {
    CrostiniApp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CrostiniAppDefaultTypeInternal _CrostiniApp_default_instance_;
PROTOBUF_CONSTEXPR CrostiniStatus::CrostiniStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.installed_apps_)*/{}
  , /*decltype(_impl_.last_launch_vm_image_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.last_launch_vm_kernel_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.last_launch_time_window_start_timestamp_)*/int64_t{0}} {}
struct CrostiniStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CrostiniStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CrostiniStatusDefaultTypeInternal() {}
  union {
    CrostiniStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CrostiniStatusDefaultTypeInternal _CrostiniStatus_default_instance_;
PROTOBUF_CONSTEXPR SessionStatusReportRequest::SessionStatusReportRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.installed_apps_)*/{}
  , /*decltype(_impl_.app_infos_)*/{}
  , /*decltype(_impl_.device_local_account_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_dm_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.time_zone_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.android_status_)*/nullptr
  , /*decltype(_impl_.crostini_status_)*/nullptr} {}
struct SessionStatusReportRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SessionStatusReportRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SessionStatusReportRequestDefaultTypeInternal() {}
  union {
    SessionStatusReportRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SessionStatusReportRequestDefaultTypeInternal _SessionStatusReportRequest_default_instance_;
PROTOBUF_CONSTEXPR DeviceStatusReportResponse::DeviceStatusReportResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.error_message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_code_)*/0} {}
struct DeviceStatusReportResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceStatusReportResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceStatusReportResponseDefaultTypeInternal() {}
  union {
    DeviceStatusReportResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceStatusReportResponseDefaultTypeInternal _DeviceStatusReportResponse_default_instance_;
PROTOBUF_CONSTEXPR ChromeDesktopReportResponse::ChromeDesktopReportResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct ChromeDesktopReportResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChromeDesktopReportResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChromeDesktopReportResponseDefaultTypeInternal() {}
  union {
    ChromeDesktopReportResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromeDesktopReportResponseDefaultTypeInternal _ChromeDesktopReportResponse_default_instance_;
PROTOBUF_CONSTEXPR ChromeOsUserReportResponse::ChromeOsUserReportResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct ChromeOsUserReportResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChromeOsUserReportResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChromeOsUserReportResponseDefaultTypeInternal() {}
  union {
    ChromeOsUserReportResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromeOsUserReportResponseDefaultTypeInternal _ChromeOsUserReportResponse_default_instance_;
PROTOBUF_CONSTEXPR ChromeProfileReportResponse::ChromeProfileReportResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct ChromeProfileReportResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChromeProfileReportResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChromeProfileReportResponseDefaultTypeInternal() {}
  union {
    ChromeProfileReportResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromeProfileReportResponseDefaultTypeInternal _ChromeProfileReportResponse_default_instance_;
PROTOBUF_CONSTEXPR SessionStatusReportResponse::SessionStatusReportResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.error_message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_code_)*/0} {}
struct SessionStatusReportResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SessionStatusReportResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SessionStatusReportResponseDefaultTypeInternal() {}
  union {
    SessionStatusReportResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SessionStatusReportResponseDefaultTypeInternal _SessionStatusReportResponse_default_instance_;
PROTOBUF_CONSTEXPR PrivateSetMembershipRequest::PrivateSetMembershipRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rlwe_request_)*/nullptr} {}
struct PrivateSetMembershipRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PrivateSetMembershipRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PrivateSetMembershipRequestDefaultTypeInternal() {}
  union {
    PrivateSetMembershipRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PrivateSetMembershipRequestDefaultTypeInternal _PrivateSetMembershipRequest_default_instance_;
PROTOBUF_CONSTEXPR PrivateSetMembershipResponse::PrivateSetMembershipResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rlwe_response_)*/nullptr} {}
struct PrivateSetMembershipResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PrivateSetMembershipResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PrivateSetMembershipResponseDefaultTypeInternal() {}
  union {
    PrivateSetMembershipResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PrivateSetMembershipResponseDefaultTypeInternal _PrivateSetMembershipResponse_default_instance_;
PROTOBUF_CONSTEXPR PrivateSetMembershipRlweRequest::PrivateSetMembershipRlweRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.oprf_request_)*/nullptr
  , /*decltype(_impl_.query_request_)*/nullptr} {}
struct PrivateSetMembershipRlweRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PrivateSetMembershipRlweRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PrivateSetMembershipRlweRequestDefaultTypeInternal() {}
  union {
    PrivateSetMembershipRlweRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PrivateSetMembershipRlweRequestDefaultTypeInternal _PrivateSetMembershipRlweRequest_default_instance_;
PROTOBUF_CONSTEXPR PrivateSetMembershipRlweResponse::PrivateSetMembershipRlweResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.oprf_response_)*/nullptr
  , /*decltype(_impl_.query_response_)*/nullptr} {}
struct PrivateSetMembershipRlweResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PrivateSetMembershipRlweResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PrivateSetMembershipRlweResponseDefaultTypeInternal() {}
  union {
    PrivateSetMembershipRlweResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PrivateSetMembershipRlweResponseDefaultTypeInternal _PrivateSetMembershipRlweResponse_default_instance_;
PROTOBUF_CONSTEXPR DeviceAutoEnrollmentRequest::DeviceAutoEnrollmentRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.remainder_)*/int64_t{0}
  , /*decltype(_impl_.modulus_)*/int64_t{0}
  , /*decltype(_impl_.enrollment_check_type_)*/1} {}
struct DeviceAutoEnrollmentRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceAutoEnrollmentRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceAutoEnrollmentRequestDefaultTypeInternal() {}
  union {
    DeviceAutoEnrollmentRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceAutoEnrollmentRequestDefaultTypeInternal _DeviceAutoEnrollmentRequest_default_instance_;
PROTOBUF_CONSTEXPR DeviceAutoEnrollmentResponse::DeviceAutoEnrollmentResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hashes_)*/{}
  , /*decltype(_impl_.expected_modulus_)*/int64_t{0}} {}
struct DeviceAutoEnrollmentResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceAutoEnrollmentResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceAutoEnrollmentResponseDefaultTypeInternal() {}
  union {
    DeviceAutoEnrollmentResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceAutoEnrollmentResponseDefaultTypeInternal _DeviceAutoEnrollmentResponse_default_instance_;
PROTOBUF_CONSTEXPR DeviceStateRetrievalRequest::DeviceStateRetrievalRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.server_backed_state_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeviceStateRetrievalRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceStateRetrievalRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceStateRetrievalRequestDefaultTypeInternal() {}
  union {
    DeviceStateRetrievalRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceStateRetrievalRequestDefaultTypeInternal _DeviceStateRetrievalRequest_default_instance_;
PROTOBUF_CONSTEXPR DeviceStateKeyUpdateRequest::DeviceStateKeyUpdateRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.server_backed_state_keys_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeviceStateKeyUpdateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceStateKeyUpdateRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceStateKeyUpdateRequestDefaultTypeInternal() {}
  union {
    DeviceStateKeyUpdateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceStateKeyUpdateRequestDefaultTypeInternal _DeviceStateKeyUpdateRequest_default_instance_;
PROTOBUF_CONSTEXPR DeviceStateRetrievalResponse::DeviceStateRetrievalResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.management_domain_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.disabled_state_)*/nullptr
  , /*decltype(_impl_.initial_state_response_)*/nullptr
  , /*decltype(_impl_.license_type_)*/nullptr
  , /*decltype(_impl_.restore_mode_)*/0} {}
struct DeviceStateRetrievalResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceStateRetrievalResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceStateRetrievalResponseDefaultTypeInternal() {}
  union {
    DeviceStateRetrievalResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceStateRetrievalResponseDefaultTypeInternal _DeviceStateRetrievalResponse_default_instance_;
PROTOBUF_CONSTEXPR DeviceInitialEnrollmentStateRequest::DeviceInitialEnrollmentStateRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.serial_number_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.brand_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeviceInitialEnrollmentStateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceInitialEnrollmentStateRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceInitialEnrollmentStateRequestDefaultTypeInternal() {}
  union {
    DeviceInitialEnrollmentStateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceInitialEnrollmentStateRequestDefaultTypeInternal _DeviceInitialEnrollmentStateRequest_default_instance_;
PROTOBUF_CONSTEXPR DeviceInitialEnrollmentStateResponse::DeviceInitialEnrollmentStateResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.management_domain_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.disabled_state_)*/nullptr
  , /*decltype(_impl_.initial_enrollment_mode_)*/0
  , /*decltype(_impl_.is_license_packaged_with_device_)*/false
  , /*decltype(_impl_.license_packaging_sku_)*/0
  , /*decltype(_impl_.assigned_upgrade_type_)*/0} {}
struct DeviceInitialEnrollmentStateResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceInitialEnrollmentStateResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceInitialEnrollmentStateResponseDefaultTypeInternal() {}
  union {
    DeviceInitialEnrollmentStateResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceInitialEnrollmentStateResponseDefaultTypeInternal _DeviceInitialEnrollmentStateResponse_default_instance_;
PROTOBUF_CONSTEXPR DevicePairingRequest::DevicePairingRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.host_device_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.controller_device_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DevicePairingRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DevicePairingRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DevicePairingRequestDefaultTypeInternal() {}
  union {
    DevicePairingRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DevicePairingRequestDefaultTypeInternal _DevicePairingRequest_default_instance_;
PROTOBUF_CONSTEXPR DevicePairingResponse::DevicePairingResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.status_code_)*/1} {}
struct DevicePairingResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DevicePairingResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DevicePairingResponseDefaultTypeInternal() {}
  union {
    DevicePairingResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DevicePairingResponseDefaultTypeInternal _DevicePairingResponse_default_instance_;
PROTOBUF_CONSTEXPR CheckDevicePairingRequest::CheckDevicePairingRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.host_device_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.controller_device_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CheckDevicePairingRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckDevicePairingRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckDevicePairingRequestDefaultTypeInternal() {}
  union {
    CheckDevicePairingRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckDevicePairingRequestDefaultTypeInternal _CheckDevicePairingRequest_default_instance_;
PROTOBUF_CONSTEXPR CheckDevicePairingResponse::CheckDevicePairingResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.status_code_)*/1} {}
struct CheckDevicePairingResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckDevicePairingResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckDevicePairingResponseDefaultTypeInternal() {}
  union {
    CheckDevicePairingResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckDevicePairingResponseDefaultTypeInternal _CheckDevicePairingResponse_default_instance_;
PROTOBUF_CONSTEXPR RemoteCommand::RemoteCommand(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.payload_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.target_device_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.command_id_)*/int64_t{0}
  , /*decltype(_impl_.age_of_command_)*/int64_t{0}
  , /*decltype(_impl_.type_)*/-1} {}
struct RemoteCommandDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoteCommandDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoteCommandDefaultTypeInternal() {}
  union {
    RemoteCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoteCommandDefaultTypeInternal _RemoteCommand_default_instance_;
PROTOBUF_CONSTEXPR RemoteCommandResult::RemoteCommandResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.payload_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.command_id_)*/int64_t{0}
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_.result_)*/0} {}
struct RemoteCommandResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoteCommandResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoteCommandResultDefaultTypeInternal() {}
  union {
    RemoteCommandResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoteCommandResultDefaultTypeInternal _RemoteCommandResult_default_instance_;
PROTOBUF_CONSTEXPR DeviceRemoteCommandRequest::DeviceRemoteCommandRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.command_results_)*/{}
  , /*decltype(_impl_.last_command_unique_id_)*/int64_t{0}
  , /*decltype(_impl_.send_secure_commands_)*/false
  , /*decltype(_impl_.signature_type_)*/0} {}
struct DeviceRemoteCommandRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceRemoteCommandRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceRemoteCommandRequestDefaultTypeInternal() {}
  union {
    DeviceRemoteCommandRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceRemoteCommandRequestDefaultTypeInternal _DeviceRemoteCommandRequest_default_instance_;
PROTOBUF_CONSTEXPR DeviceRemoteCommandResponse::DeviceRemoteCommandResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.commands_)*/{}
  , /*decltype(_impl_.secure_commands_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeviceRemoteCommandResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceRemoteCommandResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceRemoteCommandResponseDefaultTypeInternal() {}
  union {
    DeviceRemoteCommandResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceRemoteCommandResponseDefaultTypeInternal _DeviceRemoteCommandResponse_default_instance_;
PROTOBUF_CONSTEXPR DeviceAttributeUpdatePermissionRequest::DeviceAttributeUpdatePermissionRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct DeviceAttributeUpdatePermissionRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceAttributeUpdatePermissionRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceAttributeUpdatePermissionRequestDefaultTypeInternal() {}
  union {
    DeviceAttributeUpdatePermissionRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceAttributeUpdatePermissionRequestDefaultTypeInternal _DeviceAttributeUpdatePermissionRequest_default_instance_;
PROTOBUF_CONSTEXPR DeviceAttributeUpdatePermissionResponse::DeviceAttributeUpdatePermissionResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0} {}
struct DeviceAttributeUpdatePermissionResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceAttributeUpdatePermissionResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceAttributeUpdatePermissionResponseDefaultTypeInternal() {}
  union {
    DeviceAttributeUpdatePermissionResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceAttributeUpdatePermissionResponseDefaultTypeInternal _DeviceAttributeUpdatePermissionResponse_default_instance_;
PROTOBUF_CONSTEXPR DeviceAttributeUpdateRequest::DeviceAttributeUpdateRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.asset_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.location_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeviceAttributeUpdateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceAttributeUpdateRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceAttributeUpdateRequestDefaultTypeInternal() {}
  union {
    DeviceAttributeUpdateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceAttributeUpdateRequestDefaultTypeInternal _DeviceAttributeUpdateRequest_default_instance_;
PROTOBUF_CONSTEXPR DeviceAttributeUpdateResponse::DeviceAttributeUpdateResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0} {}
struct DeviceAttributeUpdateResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceAttributeUpdateResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceAttributeUpdateResponseDefaultTypeInternal() {}
  union {
    DeviceAttributeUpdateResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceAttributeUpdateResponseDefaultTypeInternal _DeviceAttributeUpdateResponse_default_instance_;
PROTOBUF_CONSTEXPR GcmIdUpdateRequest::GcmIdUpdateRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gcm_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct GcmIdUpdateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GcmIdUpdateRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GcmIdUpdateRequestDefaultTypeInternal() {}
  union {
    GcmIdUpdateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GcmIdUpdateRequestDefaultTypeInternal _GcmIdUpdateRequest_default_instance_;
PROTOBUF_CONSTEXPR GcmIdUpdateResponse::GcmIdUpdateResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct GcmIdUpdateResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GcmIdUpdateResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GcmIdUpdateResponseDefaultTypeInternal() {}
  union {
    GcmIdUpdateResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GcmIdUpdateResponseDefaultTypeInternal _GcmIdUpdateResponse_default_instance_;
PROTOBUF_CONSTEXPR CheckAndroidManagementRequest::CheckAndroidManagementRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct CheckAndroidManagementRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckAndroidManagementRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckAndroidManagementRequestDefaultTypeInternal() {}
  union {
    CheckAndroidManagementRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckAndroidManagementRequestDefaultTypeInternal _CheckAndroidManagementRequest_default_instance_;
PROTOBUF_CONSTEXPR CheckAndroidManagementResponse::CheckAndroidManagementResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct CheckAndroidManagementResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckAndroidManagementResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckAndroidManagementResponseDefaultTypeInternal() {}
  union {
    CheckAndroidManagementResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckAndroidManagementResponseDefaultTypeInternal _CheckAndroidManagementResponse_default_instance_;
PROTOBUF_CONSTEXPR CertificateBasedDeviceRegisterRequest::CertificateBasedDeviceRegisterRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.signed_request_)*/nullptr} {}
struct CertificateBasedDeviceRegisterRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CertificateBasedDeviceRegisterRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CertificateBasedDeviceRegisterRequestDefaultTypeInternal() {}
  union {
    CertificateBasedDeviceRegisterRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CertificateBasedDeviceRegisterRequestDefaultTypeInternal _CertificateBasedDeviceRegisterRequest_default_instance_;
PROTOBUF_CONSTEXPR DeviceRegisterConfiguration::DeviceRegisterConfiguration(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_owner_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeviceRegisterConfigurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceRegisterConfigurationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceRegisterConfigurationDefaultTypeInternal() {}
  union {
    DeviceRegisterConfiguration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceRegisterConfigurationDefaultTypeInternal _DeviceRegisterConfiguration_default_instance_;
PROTOBUF_CONSTEXPR CertificateBasedDeviceRegistrationData::CertificateBasedDeviceRegistrationData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.device_certificate_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_register_request_)*/nullptr
  , /*decltype(_impl_.device_register_configuration_)*/nullptr
  , /*decltype(_impl_.certificate_type_)*/0} {}
struct CertificateBasedDeviceRegistrationDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CertificateBasedDeviceRegistrationDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CertificateBasedDeviceRegistrationDataDefaultTypeInternal() {}
  union {
    CertificateBasedDeviceRegistrationData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CertificateBasedDeviceRegistrationDataDefaultTypeInternal _CertificateBasedDeviceRegistrationData_default_instance_;
PROTOBUF_CONSTEXPR RegisterBrowserRequest::RegisterBrowserRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.machine_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.os_platform_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.os_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_model_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.brand_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.browser_device_identifier_)*/nullptr} {}
struct RegisterBrowserRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RegisterBrowserRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RegisterBrowserRequestDefaultTypeInternal() {}
  union {
    RegisterBrowserRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RegisterBrowserRequestDefaultTypeInternal _RegisterBrowserRequest_default_instance_;
PROTOBUF_CONSTEXPR ActiveDirectoryEnrollPlayUserRequest::ActiveDirectoryEnrollPlayUserRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.auth_session_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ActiveDirectoryEnrollPlayUserRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActiveDirectoryEnrollPlayUserRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActiveDirectoryEnrollPlayUserRequestDefaultTypeInternal() {}
  union {
    ActiveDirectoryEnrollPlayUserRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActiveDirectoryEnrollPlayUserRequestDefaultTypeInternal _ActiveDirectoryEnrollPlayUserRequest_default_instance_;
PROTOBUF_CONSTEXPR ActiveDirectoryEnrollPlayUserResponse::ActiveDirectoryEnrollPlayUserResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enrollment_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.saml_parameters_)*/nullptr} {}
struct ActiveDirectoryEnrollPlayUserResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActiveDirectoryEnrollPlayUserResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActiveDirectoryEnrollPlayUserResponseDefaultTypeInternal() {}
  union {
    ActiveDirectoryEnrollPlayUserResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActiveDirectoryEnrollPlayUserResponseDefaultTypeInternal _ActiveDirectoryEnrollPlayUserResponse_default_instance_;
PROTOBUF_CONSTEXPR SamlParametersProto::SamlParametersProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.auth_redirect_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.auth_session_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct SamlParametersProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SamlParametersProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SamlParametersProtoDefaultTypeInternal() {}
  union {
    SamlParametersProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SamlParametersProtoDefaultTypeInternal _SamlParametersProto_default_instance_;
PROTOBUF_CONSTEXPR PublicSamlUserRequest::PublicSamlUserRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PublicSamlUserRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PublicSamlUserRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PublicSamlUserRequestDefaultTypeInternal() {}
  union {
    PublicSamlUserRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PublicSamlUserRequestDefaultTypeInternal _PublicSamlUserRequest_default_instance_;
PROTOBUF_CONSTEXPR PublicSamlUserResponse::PublicSamlUserResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.saml_parameters_)*/nullptr} {}
struct PublicSamlUserResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PublicSamlUserResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PublicSamlUserResponseDefaultTypeInternal() {}
  union {
    PublicSamlUserResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PublicSamlUserResponseDefaultTypeInternal _PublicSamlUserResponse_default_instance_;
PROTOBUF_CONSTEXPR ActiveDirectoryPlayActivityRequest::ActiveDirectoryPlayActivityRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ActiveDirectoryPlayActivityRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActiveDirectoryPlayActivityRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActiveDirectoryPlayActivityRequestDefaultTypeInternal() {}
  union {
    ActiveDirectoryPlayActivityRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActiveDirectoryPlayActivityRequestDefaultTypeInternal _ActiveDirectoryPlayActivityRequest_default_instance_;
PROTOBUF_CONSTEXPR ActiveDirectoryPlayActivityResponse::ActiveDirectoryPlayActivityResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct ActiveDirectoryPlayActivityResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActiveDirectoryPlayActivityResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActiveDirectoryPlayActivityResponseDefaultTypeInternal() {}
  union {
    ActiveDirectoryPlayActivityResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActiveDirectoryPlayActivityResponseDefaultTypeInternal _ActiveDirectoryPlayActivityResponse_default_instance_;
PROTOBUF_CONSTEXPR CheckDeviceLicenseRequest::CheckDeviceLicenseRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct CheckDeviceLicenseRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckDeviceLicenseRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckDeviceLicenseRequestDefaultTypeInternal() {}
  union {
    CheckDeviceLicenseRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckDeviceLicenseRequestDefaultTypeInternal _CheckDeviceLicenseRequest_default_instance_;
PROTOBUF_CONSTEXPR LicenseAvailability::LicenseAvailability(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.license_type_deprecated_)*/nullptr
  , /*decltype(_impl_.available_licenses_deprecated_)*/0} {}
struct LicenseAvailabilityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LicenseAvailabilityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LicenseAvailabilityDefaultTypeInternal() {}
  union {
    LicenseAvailability _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LicenseAvailabilityDefaultTypeInternal _LicenseAvailability_default_instance_;
PROTOBUF_CONSTEXPR CheckDeviceLicenseResponse::CheckDeviceLicenseResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.license_availabilities_deprecated_)*/{}
  , /*decltype(_impl_.license_selection_mode_deprecated_)*/0} {}
struct CheckDeviceLicenseResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckDeviceLicenseResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckDeviceLicenseResponseDefaultTypeInternal() {}
  union {
    CheckDeviceLicenseResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckDeviceLicenseResponseDefaultTypeInternal _CheckDeviceLicenseResponse_default_instance_;
PROTOBUF_CONSTEXPR ActiveDirectoryUserSigninRequest::ActiveDirectoryUserSigninRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct ActiveDirectoryUserSigninRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActiveDirectoryUserSigninRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActiveDirectoryUserSigninRequestDefaultTypeInternal() {}
  union {
    ActiveDirectoryUserSigninRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActiveDirectoryUserSigninRequestDefaultTypeInternal _ActiveDirectoryUserSigninRequest_default_instance_;
PROTOBUF_CONSTEXPR ActiveDirectoryUserSigninResponse::ActiveDirectoryUserSigninResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.auth_redirect_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ActiveDirectoryUserSigninResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActiveDirectoryUserSigninResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActiveDirectoryUserSigninResponseDefaultTypeInternal() {}
  union {
    ActiveDirectoryUserSigninResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActiveDirectoryUserSigninResponseDefaultTypeInternal _ActiveDirectoryUserSigninResponse_default_instance_;
PROTOBUF_CONSTEXPR TpmVersionInfo::TpmVersionInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vendor_specific_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.did_vid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.spec_level_)*/uint64_t{0u}
  , /*decltype(_impl_.family_)*/0u
  , /*decltype(_impl_.manufacturer_)*/0u
  , /*decltype(_impl_.firmware_version_)*/uint64_t{0u}
  , /*decltype(_impl_.tpm_model_)*/0u
  , /*decltype(_impl_.gsc_version_)*/0} {}
struct TpmVersionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TpmVersionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TpmVersionInfoDefaultTypeInternal() {}
  union {
    TpmVersionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TpmVersionInfoDefaultTypeInternal _TpmVersionInfo_default_instance_;
PROTOBUF_CONSTEXPR TpmStatusInfo::TpmStatusInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tpm_supported_features_)*/nullptr
  , /*decltype(_impl_.enabled_)*/false
  , /*decltype(_impl_.owned_)*/false
  , /*decltype(_impl_.tpm_initialized_)*/false
  , /*decltype(_impl_.attestation_prepared_)*/false
  , /*decltype(_impl_.dictionary_attack_counter_)*/0
  , /*decltype(_impl_.dictionary_attack_threshold_)*/0
  , /*decltype(_impl_.attestation_enrolled_)*/false
  , /*decltype(_impl_.dictionary_attack_lockout_in_effect_)*/false
  , /*decltype(_impl_.boot_lockbox_finalized_)*/false
  , /*decltype(_impl_.owner_password_is_present_)*/false
  , /*decltype(_impl_.dictionary_attack_lockout_seconds_remaining_)*/0} {}
struct TpmStatusInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TpmStatusInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TpmStatusInfoDefaultTypeInternal() {}
  union {
    TpmStatusInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TpmStatusInfoDefaultTypeInternal _TpmStatusInfo_default_instance_;
PROTOBUF_CONSTEXPR TpmSupportedFeatures::TpmSupportedFeatures(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.is_allowed_)*/false
  , /*decltype(_impl_.support_pinweaver_)*/false
  , /*decltype(_impl_.support_runtime_selection_)*/false
  , /*decltype(_impl_.support_u2f_)*/false} {}
struct TpmSupportedFeaturesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TpmSupportedFeaturesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TpmSupportedFeaturesDefaultTypeInternal() {}
  union {
    TpmSupportedFeatures _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TpmSupportedFeaturesDefaultTypeInternal _TpmSupportedFeatures_default_instance_;
PROTOBUF_CONSTEXPR SystemState::SystemState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.volume_infos_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SystemStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemStateDefaultTypeInternal() {}
  union {
    SystemState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemStateDefaultTypeInternal _SystemState_default_instance_;
PROTOBUF_CONSTEXPR ExtensionInstallReportLogEvent::ExtensionInstallReportLogEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_.stateful_total_)*/int64_t{0}
  , /*decltype(_impl_.stateful_free_)*/int64_t{0}
  , /*decltype(_impl_.event_type_)*/0
  , /*decltype(_impl_.session_state_change_type_)*/0
  , /*decltype(_impl_.failure_reason_)*/0
  , /*decltype(_impl_.installation_stage_)*/0
  , /*decltype(_impl_.downloading_stage_)*/0
  , /*decltype(_impl_.extension_type_)*/0
  , /*decltype(_impl_.online_)*/false
  , /*decltype(_impl_.is_new_user_)*/false
  , /*decltype(_impl_.is_misconfiguration_failure_)*/false
  , /*decltype(_impl_.user_type_)*/0
  , /*decltype(_impl_.install_creation_stage_)*/0
  , /*decltype(_impl_.download_cache_status_)*/0
  , /*decltype(_impl_.unpacker_failure_reason_)*/0
  , /*decltype(_impl_.manifest_invalid_error_)*/0
  , /*decltype(_impl_.crx_install_error_detail_)*/0
  , /*decltype(_impl_.fetch_error_code_)*/0
  , /*decltype(_impl_.fetch_tries_)*/0} {}
struct ExtensionInstallReportLogEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExtensionInstallReportLogEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExtensionInstallReportLogEventDefaultTypeInternal() {}
  union {
    ExtensionInstallReportLogEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionInstallReportLogEventDefaultTypeInternal _ExtensionInstallReportLogEvent_default_instance_;
PROTOBUF_CONSTEXPR AppInstallReportLogEvent::AppInstallReportLogEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.phonesky_log_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_.stateful_total_)*/int64_t{0}
  , /*decltype(_impl_.event_type_)*/0
  , /*decltype(_impl_.clouddps_response_)*/0
  , /*decltype(_impl_.stateful_free_)*/int64_t{0}
  , /*decltype(_impl_.online_)*/false
  , /*decltype(_impl_.session_state_change_type_)*/0
  , /*decltype(_impl_.android_id_)*/int64_t{0}} {}
struct AppInstallReportLogEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AppInstallReportLogEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AppInstallReportLogEventDefaultTypeInternal() {}
  union {
    AppInstallReportLogEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AppInstallReportLogEventDefaultTypeInternal _AppInstallReportLogEvent_default_instance_;
PROTOBUF_CONSTEXPR ExtensionInstallReport::ExtensionInstallReport(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.logs_)*/{}
  , /*decltype(_impl_.extension_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.incomplete_)*/false} {}
struct ExtensionInstallReportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExtensionInstallReportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExtensionInstallReportDefaultTypeInternal() {}
  union {
    ExtensionInstallReport _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionInstallReportDefaultTypeInternal _ExtensionInstallReport_default_instance_;
PROTOBUF_CONSTEXPR AppInstallReport::AppInstallReport(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.logs_)*/{}
  , /*decltype(_impl_.package_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.incomplete_)*/false} {}
struct AppInstallReportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AppInstallReportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AppInstallReportDefaultTypeInternal() {}
  union {
    AppInstallReport _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AppInstallReportDefaultTypeInternal _AppInstallReport_default_instance_;
PROTOBUF_CONSTEXPR AppInstallReportRequest::AppInstallReportRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.app_install_reports_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AppInstallReportRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AppInstallReportRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AppInstallReportRequestDefaultTypeInternal() {}
  union {
    AppInstallReportRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AppInstallReportRequestDefaultTypeInternal _AppInstallReportRequest_default_instance_;
PROTOBUF_CONSTEXPR ExtensionInstallReportRequest::ExtensionInstallReportRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.extension_install_reports_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ExtensionInstallReportRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExtensionInstallReportRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExtensionInstallReportRequestDefaultTypeInternal() {}
  union {
    ExtensionInstallReportRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionInstallReportRequestDefaultTypeInternal _ExtensionInstallReportRequest_default_instance_;
PROTOBUF_CONSTEXPR AppInstallReportResponse::AppInstallReportResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct AppInstallReportResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AppInstallReportResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AppInstallReportResponseDefaultTypeInternal() {}
  union {
    AppInstallReportResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AppInstallReportResponseDefaultTypeInternal _AppInstallReportResponse_default_instance_;
PROTOBUF_CONSTEXPR RefreshAccountRequest::RefreshAccountRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.account_type_)*/0} {}
struct RefreshAccountRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RefreshAccountRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RefreshAccountRequestDefaultTypeInternal() {}
  union {
    RefreshAccountRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RefreshAccountRequestDefaultTypeInternal _RefreshAccountRequest_default_instance_;
PROTOBUF_CONSTEXPR RefreshAccountResponse::RefreshAccountResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct RefreshAccountResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RefreshAccountResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RefreshAccountResponseDefaultTypeInternal() {}
  union {
    RefreshAccountResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RefreshAccountResponseDefaultTypeInternal _RefreshAccountResponse_default_instance_;
PROTOBUF_CONSTEXPR RsuLookupKeyUploadRequest::RsuLookupKeyUploadRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.board_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cr50_hashed_device_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct RsuLookupKeyUploadRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RsuLookupKeyUploadRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RsuLookupKeyUploadRequestDefaultTypeInternal() {}
  union {
    RsuLookupKeyUploadRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RsuLookupKeyUploadRequestDefaultTypeInternal _RsuLookupKeyUploadRequest_default_instance_;
PROTOBUF_CONSTEXPR RsuLookupKeyUploadResponse::RsuLookupKeyUploadResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rsu_lookup_key_updated_)*/false} {}
struct RsuLookupKeyUploadResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RsuLookupKeyUploadResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RsuLookupKeyUploadResponseDefaultTypeInternal() {}
  union {
    RsuLookupKeyUploadResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RsuLookupKeyUploadResponseDefaultTypeInternal _RsuLookupKeyUploadResponse_default_instance_;
PROTOBUF_CONSTEXPR ESimProfileInfo::ESimProfileInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.iccid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.smdp_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ESimProfileInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ESimProfileInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ESimProfileInfoDefaultTypeInternal() {}
  union {
    ESimProfileInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ESimProfileInfoDefaultTypeInternal _ESimProfileInfo_default_instance_;
PROTOBUF_CONSTEXPR UploadEuiccInfoRequest::UploadEuiccInfoRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.esim_profiles_)*/{}
  , /*decltype(_impl_.euicc_count_)*/0u
  , /*decltype(_impl_.clear_profile_list_)*/false} {}
struct UploadEuiccInfoRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UploadEuiccInfoRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UploadEuiccInfoRequestDefaultTypeInternal() {}
  union {
    UploadEuiccInfoRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UploadEuiccInfoRequestDefaultTypeInternal _UploadEuiccInfoRequest_default_instance_;
PROTOBUF_CONSTEXPR UploadEuiccInfoResponse::UploadEuiccInfoResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct UploadEuiccInfoResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UploadEuiccInfoResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UploadEuiccInfoResponseDefaultTypeInternal() {}
  union {
    UploadEuiccInfoResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UploadEuiccInfoResponseDefaultTypeInternal _UploadEuiccInfoResponse_default_instance_;
PROTOBUF_CONSTEXPR PrintJobEvent_PrintJobConfiguration::PrintJobEvent_PrintJobConfiguration(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.settings_)*/nullptr
  , /*decltype(_impl_.creation_timestamp_ms_)*/int64_t{0}
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_.number_of_pages_)*/0
  , /*decltype(_impl_.completion_timestamp_ms_)*/int64_t{0}} {}
struct PrintJobEvent_PrintJobConfigurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PrintJobEvent_PrintJobConfigurationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PrintJobEvent_PrintJobConfigurationDefaultTypeInternal() {}
  union {
    PrintJobEvent_PrintJobConfiguration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PrintJobEvent_PrintJobConfigurationDefaultTypeInternal _PrintJobEvent_PrintJobConfiguration_default_instance_;
PROTOBUF_CONSTEXPR PrintJobEvent_Printer::PrintJobEvent_Printer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uri_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PrintJobEvent_PrinterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PrintJobEvent_PrinterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PrintJobEvent_PrinterDefaultTypeInternal() {}
  union {
    PrintJobEvent_Printer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PrintJobEvent_PrinterDefaultTypeInternal _PrintJobEvent_Printer_default_instance_;
PROTOBUF_CONSTEXPR PrintJobEvent_PrintSettings_MediaSize::PrintJobEvent_PrintSettings_MediaSize(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vendor_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.height_)*/0} {}
struct PrintJobEvent_PrintSettings_MediaSizeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PrintJobEvent_PrintSettings_MediaSizeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PrintJobEvent_PrintSettings_MediaSizeDefaultTypeInternal() {}
  union {
    PrintJobEvent_PrintSettings_MediaSize _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PrintJobEvent_PrintSettings_MediaSizeDefaultTypeInternal _PrintJobEvent_PrintSettings_MediaSize_default_instance_;
PROTOBUF_CONSTEXPR PrintJobEvent_PrintSettings::PrintJobEvent_PrintSettings(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.media_size_)*/nullptr
  , /*decltype(_impl_.color_)*/0
  , /*decltype(_impl_.duplex_)*/0
  , /*decltype(_impl_.copies_)*/0} {}
struct PrintJobEvent_PrintSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PrintJobEvent_PrintSettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PrintJobEvent_PrintSettingsDefaultTypeInternal() {}
  union {
    PrintJobEvent_PrintSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PrintJobEvent_PrintSettingsDefaultTypeInternal _PrintJobEvent_PrintSettings_default_instance_;
PROTOBUF_CONSTEXPR PrintJobEvent::PrintJobEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.job_configuration_)*/nullptr
  , /*decltype(_impl_.printer_)*/nullptr
  , /*decltype(_impl_.user_type_)*/0} {}
struct PrintJobEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PrintJobEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PrintJobEventDefaultTypeInternal() {}
  union {
    PrintJobEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PrintJobEventDefaultTypeInternal _PrintJobEvent_default_instance_;
PROTOBUF_CONSTEXPR App::App(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.additional_app_id_)*/{}
  , /*decltype(_impl_.app_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.app_type_)*/0} {}
struct AppDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AppDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AppDefaultTypeInternal() {}
  union {
    App _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AppDefaultTypeInternal _App_default_instance_;
PROTOBUF_CONSTEXPR AppActivity::AppActivity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.active_time_periods_)*/{}
  , /*decltype(_impl_.app_info_)*/nullptr
  , /*decltype(_impl_.populated_at_)*/int64_t{0}
  , /*decltype(_impl_.app_state_)*/0} {}
struct AppActivityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AppActivityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AppActivityDefaultTypeInternal() {}
  union {
    AppActivity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AppActivityDefaultTypeInternal _AppActivity_default_instance_;
PROTOBUF_CONSTEXPR ScreenTimeSpan::ScreenTimeSpan(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.time_period_)*/nullptr
  , /*decltype(_impl_.active_duration_ms_)*/int64_t{0}} {}
struct ScreenTimeSpanDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScreenTimeSpanDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScreenTimeSpanDefaultTypeInternal() {}
  union {
    ScreenTimeSpan _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScreenTimeSpanDefaultTypeInternal _ScreenTimeSpan_default_instance_;
PROTOBUF_CONSTEXPR ChildStatusReportRequest::ChildStatusReportRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.screen_time_span_)*/{}
  , /*decltype(_impl_.app_activity_)*/{}
  , /*decltype(_impl_.hidden_app_)*/{}
  , /*decltype(_impl_.user_dm_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.time_zone_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.os_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.boot_mode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.android_status_)*/nullptr
  , /*decltype(_impl_.timestamp_ms_)*/int64_t{0}} {}
struct ChildStatusReportRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChildStatusReportRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChildStatusReportRequestDefaultTypeInternal() {}
  union {
    ChildStatusReportRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChildStatusReportRequestDefaultTypeInternal _ChildStatusReportRequest_default_instance_;
PROTOBUF_CONSTEXPR ChildStatusReportResponse::ChildStatusReportResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.error_message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_code_)*/0} {}
struct ChildStatusReportResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChildStatusReportResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChildStatusReportResponseDefaultTypeInternal() {}
  union {
    ChildStatusReportResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChildStatusReportResponseDefaultTypeInternal _ChildStatusReportResponse_default_instance_;
PROTOBUF_CONSTEXPR StartCsrRequest::StartCsrRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct StartCsrRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StartCsrRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StartCsrRequestDefaultTypeInternal() {}
  union {
    StartCsrRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StartCsrRequestDefaultTypeInternal _StartCsrRequest_default_instance_;
PROTOBUF_CONSTEXPR StartCsrResponse::StartCsrResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.invalidation_topic_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.va_challenge_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.data_to_sign_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signing_algorithm_)*/0
  , /*decltype(_impl_.hashing_algorithm_)*/0} {}
struct StartCsrResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StartCsrResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StartCsrResponseDefaultTypeInternal() {}
  union {
    StartCsrResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StartCsrResponseDefaultTypeInternal _StartCsrResponse_default_instance_;
PROTOBUF_CONSTEXPR FinishCsrRequest::FinishCsrRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.va_challenge_response_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct FinishCsrRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FinishCsrRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FinishCsrRequestDefaultTypeInternal() {}
  union {
    FinishCsrRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FinishCsrRequestDefaultTypeInternal _FinishCsrRequest_default_instance_;
PROTOBUF_CONSTEXPR FinishCsrResponse::FinishCsrResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct FinishCsrResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FinishCsrResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FinishCsrResponseDefaultTypeInternal() {}
  union {
    FinishCsrResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FinishCsrResponseDefaultTypeInternal _FinishCsrResponse_default_instance_;
PROTOBUF_CONSTEXPR DownloadCertRequest::DownloadCertRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct DownloadCertRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DownloadCertRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DownloadCertRequestDefaultTypeInternal() {}
  union {
    DownloadCertRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownloadCertRequestDefaultTypeInternal _DownloadCertRequest_default_instance_;
PROTOBUF_CONSTEXPR DownloadCertResponse::DownloadCertResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pem_encoded_certificate_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DownloadCertResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DownloadCertResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DownloadCertResponseDefaultTypeInternal() {}
  union {
    DownloadCertResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownloadCertResponseDefaultTypeInternal _DownloadCertResponse_default_instance_;
PROTOBUF_CONSTEXPR CertProvStartOrContinueRequest::CertProvStartOrContinueRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct CertProvStartOrContinueRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CertProvStartOrContinueRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CertProvStartOrContinueRequestDefaultTypeInternal() {}
  union {
    CertProvStartOrContinueRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CertProvStartOrContinueRequestDefaultTypeInternal _CertProvStartOrContinueRequest_default_instance_;
PROTOBUF_CONSTEXPR CertProvAuthorizeRequest::CertProvAuthorizeRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.va_challenge_response_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CertProvAuthorizeRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CertProvAuthorizeRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CertProvAuthorizeRequestDefaultTypeInternal() {}
  union {
    CertProvAuthorizeRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CertProvAuthorizeRequestDefaultTypeInternal _CertProvAuthorizeRequest_default_instance_;
PROTOBUF_CONSTEXPR CertProvUploadProofOfPossessionRequest::CertProvUploadProofOfPossessionRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CertProvUploadProofOfPossessionRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CertProvUploadProofOfPossessionRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CertProvUploadProofOfPossessionRequestDefaultTypeInternal() {}
  union {
    CertProvUploadProofOfPossessionRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CertProvUploadProofOfPossessionRequestDefaultTypeInternal _CertProvUploadProofOfPossessionRequest_default_instance_;
PROTOBUF_CONSTEXPR CertProvTryLaterInstruction::CertProvTryLaterInstruction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.delay_ms_)*/int64_t{0}} {}
struct CertProvTryLaterInstructionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CertProvTryLaterInstructionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CertProvTryLaterInstructionDefaultTypeInternal() {}
  union {
    CertProvTryLaterInstruction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CertProvTryLaterInstructionDefaultTypeInternal _CertProvTryLaterInstruction_default_instance_;
PROTOBUF_CONSTEXPR CertProvAuthorizeInstruction::CertProvAuthorizeInstruction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.va_challenge_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CertProvAuthorizeInstructionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CertProvAuthorizeInstructionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CertProvAuthorizeInstructionDefaultTypeInternal() {}
  union {
    CertProvAuthorizeInstruction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CertProvAuthorizeInstructionDefaultTypeInternal _CertProvAuthorizeInstruction_default_instance_;
PROTOBUF_CONSTEXPR CertProvProofOfPossessionInstruction::CertProvProofOfPossessionInstruction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_to_sign_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CertProvProofOfPossessionInstructionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CertProvProofOfPossessionInstructionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CertProvProofOfPossessionInstructionDefaultTypeInternal() {}
  union {
    CertProvProofOfPossessionInstruction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CertProvProofOfPossessionInstructionDefaultTypeInternal _CertProvProofOfPossessionInstruction_default_instance_;
PROTOBUF_CONSTEXPR CertProvImportCertificateInstruction::CertProvImportCertificateInstruction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pem_encoded_certificate_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CertProvImportCertificateInstructionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CertProvImportCertificateInstructionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CertProvImportCertificateInstructionDefaultTypeInternal() {}
  union {
    CertProvImportCertificateInstruction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CertProvImportCertificateInstructionDefaultTypeInternal _CertProvImportCertificateInstruction_default_instance_;
PROTOBUF_CONSTEXPR CertProvNextActionResponse::CertProvNextActionResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.invalidation_topic_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.instruction_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct CertProvNextActionResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CertProvNextActionResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CertProvNextActionResponseDefaultTypeInternal() {}
  union {
    CertProvNextActionResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CertProvNextActionResponseDefaultTypeInternal _CertProvNextActionResponse_default_instance_;
PROTOBUF_CONSTEXPR ClientCertificateProvisioningRequest::ClientCertificateProvisioningRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.certificate_scope_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cert_profile_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.public_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_dm_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.policy_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.request_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ClientCertificateProvisioningRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientCertificateProvisioningRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientCertificateProvisioningRequestDefaultTypeInternal() {}
  union {
    ClientCertificateProvisioningRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientCertificateProvisioningRequestDefaultTypeInternal _ClientCertificateProvisioningRequest_default_instance_;
PROTOBUF_CONSTEXPR ClientCertificateProvisioningResponse::ClientCertificateProvisioningResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.try_again_later_)*/int64_t{0}
  , /*decltype(_impl_.response_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ClientCertificateProvisioningResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientCertificateProvisioningResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientCertificateProvisioningResponseDefaultTypeInternal() {}
  union {
    ClientCertificateProvisioningResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientCertificateProvisioningResponseDefaultTypeInternal _ClientCertificateProvisioningResponse_default_instance_;
PROTOBUF_CONSTEXPR BrowserPublicKeyUploadRequest::BrowserPublicKeyUploadRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.public_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.key_trust_level_)*/0
  , /*decltype(_impl_.key_type_)*/0} {}
struct BrowserPublicKeyUploadRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BrowserPublicKeyUploadRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BrowserPublicKeyUploadRequestDefaultTypeInternal() {}
  union {
    BrowserPublicKeyUploadRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BrowserPublicKeyUploadRequestDefaultTypeInternal _BrowserPublicKeyUploadRequest_default_instance_;
PROTOBUF_CONSTEXPR BrowserPublicKeyUploadResponse::BrowserPublicKeyUploadResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.response_code_)*/0} {}
struct BrowserPublicKeyUploadResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BrowserPublicKeyUploadResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BrowserPublicKeyUploadResponseDefaultTypeInternal() {}
  union {
    BrowserPublicKeyUploadResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BrowserPublicKeyUploadResponseDefaultTypeInternal _BrowserPublicKeyUploadResponse_default_instance_;
PROTOBUF_CONSTEXPR DeviceManagementRequest::DeviceManagementRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.register_request_)*/nullptr
  , /*decltype(_impl_.unregister_request_)*/nullptr
  , /*decltype(_impl_.policy_request_)*/nullptr
  , /*decltype(_impl_.device_status_report_request_)*/nullptr
  , /*decltype(_impl_.session_status_report_request_)*/nullptr
  , /*decltype(_impl_.auto_enrollment_request_)*/nullptr
  , /*decltype(_impl_.cert_upload_request_)*/nullptr
  , /*decltype(_impl_.service_api_access_request_)*/nullptr
  , /*decltype(_impl_.device_state_retrieval_request_)*/nullptr
  , /*decltype(_impl_.device_state_key_update_request_)*/nullptr
  , /*decltype(_impl_.device_pairing_request_)*/nullptr
  , /*decltype(_impl_.check_device_pairing_request_)*/nullptr
  , /*decltype(_impl_.remote_command_request_)*/nullptr
  , /*decltype(_impl_.device_attribute_update_permission_request_)*/nullptr
  , /*decltype(_impl_.device_attribute_update_request_)*/nullptr
  , /*decltype(_impl_.gcm_id_update_request_)*/nullptr
  , /*decltype(_impl_.check_android_management_request_)*/nullptr
  , /*decltype(_impl_.certificate_based_register_request_)*/nullptr
  , /*decltype(_impl_.active_directory_enroll_play_user_request_)*/nullptr
  , /*decltype(_impl_.active_directory_play_activity_request_)*/nullptr
  , /*decltype(_impl_.check_device_license_request_deprecated_)*/nullptr
  , /*decltype(_impl_.active_directory_user_signin_request_)*/nullptr
  , /*decltype(_impl_.register_browser_request_)*/nullptr
  , /*decltype(_impl_.app_install_report_request_)*/nullptr
  , /*decltype(_impl_.chrome_desktop_report_request_)*/nullptr
  , /*decltype(_impl_.policy_validation_report_request_)*/nullptr
  , /*decltype(_impl_.device_initial_enrollment_state_request_)*/nullptr
  , /*decltype(_impl_.refresh_account_request_)*/nullptr
  , /*decltype(_impl_.child_status_report_request_)*/nullptr
  , /*decltype(_impl_.rsu_lookup_key_upload_request_)*/nullptr
  , /*decltype(_impl_.public_saml_user_request_)*/nullptr
  , /*decltype(_impl_.chrome_os_user_report_request_)*/nullptr
  , /*decltype(_impl_.client_certificate_provisioning_request_)*/nullptr
  , /*decltype(_impl_.extension_install_report_request_)*/nullptr
  , /*decltype(_impl_.check_user_account_request_)*/nullptr
  , /*decltype(_impl_.private_set_membership_request_)*/nullptr
  , /*decltype(_impl_.browser_public_key_upload_request_)*/nullptr
  , /*decltype(_impl_.upload_euicc_info_request_)*/nullptr
  , /*decltype(_impl_.chrome_profile_report_request_)*/nullptr} {}
struct DeviceManagementRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceManagementRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceManagementRequestDefaultTypeInternal() {}
  union {
    DeviceManagementRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceManagementRequestDefaultTypeInternal _DeviceManagementRequest_default_instance_;
PROTOBUF_CONSTEXPR DeviceManagementResponse::DeviceManagementResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.error_detail_)*/{}
  , /*decltype(_impl_.error_message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.register_response_)*/nullptr
  , /*decltype(_impl_.unregister_response_)*/nullptr
  , /*decltype(_impl_.policy_response_)*/nullptr
  , /*decltype(_impl_.device_status_report_response_)*/nullptr
  , /*decltype(_impl_.session_status_report_response_)*/nullptr
  , /*decltype(_impl_.auto_enrollment_response_)*/nullptr
  , /*decltype(_impl_.cert_upload_response_)*/nullptr
  , /*decltype(_impl_.service_api_access_response_)*/nullptr
  , /*decltype(_impl_.device_state_retrieval_response_)*/nullptr
  , /*decltype(_impl_.device_pairing_response_)*/nullptr
  , /*decltype(_impl_.check_device_pairing_response_)*/nullptr
  , /*decltype(_impl_.remote_command_response_)*/nullptr
  , /*decltype(_impl_.device_attribute_update_permission_response_)*/nullptr
  , /*decltype(_impl_.device_attribute_update_response_)*/nullptr
  , /*decltype(_impl_.gcm_id_update_response_)*/nullptr
  , /*decltype(_impl_.check_android_management_response_)*/nullptr
  , /*decltype(_impl_.active_directory_enroll_play_user_response_)*/nullptr
  , /*decltype(_impl_.active_directory_play_activity_response_)*/nullptr
  , /*decltype(_impl_.check_device_license_response_deprecated_)*/nullptr
  , /*decltype(_impl_.active_directory_user_signin_response_)*/nullptr
  , /*decltype(_impl_.chrome_desktop_report_response_)*/nullptr
  , /*decltype(_impl_.app_install_report_response_)*/nullptr
  , /*decltype(_impl_.policy_validation_report_response_)*/nullptr
  , /*decltype(_impl_.device_initial_enrollment_state_response_)*/nullptr
  , /*decltype(_impl_.refresh_account_response_)*/nullptr
  , /*decltype(_impl_.child_status_report_response_)*/nullptr
  , /*decltype(_impl_.rsu_lookup_key_upload_response_)*/nullptr
  , /*decltype(_impl_.public_saml_user_response_)*/nullptr
  , /*decltype(_impl_.chrome_os_user_report_response_)*/nullptr
  , /*decltype(_impl_.client_certificate_provisioning_response_)*/nullptr
  , /*decltype(_impl_.check_user_account_response_)*/nullptr
  , /*decltype(_impl_.private_set_membership_response_)*/nullptr
  , /*decltype(_impl_.browser_public_key_upload_response_)*/nullptr
  , /*decltype(_impl_.upload_euicc_info_response_)*/nullptr
  , /*decltype(_impl_.chrome_profile_report_response_)*/nullptr} {}
struct DeviceManagementResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceManagementResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceManagementResponseDefaultTypeInternal() {}
  union {
    DeviceManagementResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceManagementResponseDefaultTypeInternal _DeviceManagementResponse_default_instance_;
PROTOBUF_CONSTEXPR DeviceStateRetrievalInfo::DeviceStateRetrievalInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.has_initial_state_)*/false} {}
struct DeviceStateRetrievalInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceStateRetrievalInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceStateRetrievalInfoDefaultTypeInternal() {}
  union {
    DeviceStateRetrievalInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceStateRetrievalInfoDefaultTypeInternal _DeviceStateRetrievalInfo_default_instance_;
}  // namespace enterprise_management
namespace enterprise_management {
bool LicenseType_LicenseTypeEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LicenseType_LicenseTypeEnum_strings[5] = {};

static const char LicenseType_LicenseTypeEnum_names[] =
  "CDM_ANNUAL"
  "CDM_PACKAGED"
  "CDM_PERPETUAL"
  "KIOSK"
  "UNDEFINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LicenseType_LicenseTypeEnum_entries[] = {
  { {LicenseType_LicenseTypeEnum_names + 0, 10}, 2 },
  { {LicenseType_LicenseTypeEnum_names + 10, 12}, 4 },
  { {LicenseType_LicenseTypeEnum_names + 22, 13}, 1 },
  { {LicenseType_LicenseTypeEnum_names + 35, 5}, 3 },
  { {LicenseType_LicenseTypeEnum_names + 40, 9}, 0 },
};

static const int LicenseType_LicenseTypeEnum_entries_by_number[] = {
  4, // 0 -> UNDEFINED
  2, // 1 -> CDM_PERPETUAL
  0, // 2 -> CDM_ANNUAL
  3, // 3 -> KIOSK
  1, // 4 -> CDM_PACKAGED
};

const std::string& LicenseType_LicenseTypeEnum_Name(
    LicenseType_LicenseTypeEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LicenseType_LicenseTypeEnum_entries,
          LicenseType_LicenseTypeEnum_entries_by_number,
          5, LicenseType_LicenseTypeEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LicenseType_LicenseTypeEnum_entries,
      LicenseType_LicenseTypeEnum_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LicenseType_LicenseTypeEnum_strings[idx].get();
}
bool LicenseType_LicenseTypeEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LicenseType_LicenseTypeEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LicenseType_LicenseTypeEnum_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<LicenseType_LicenseTypeEnum>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LicenseType_LicenseTypeEnum LicenseType::UNDEFINED;
constexpr LicenseType_LicenseTypeEnum LicenseType::CDM_PERPETUAL;
constexpr LicenseType_LicenseTypeEnum LicenseType::CDM_ANNUAL;
constexpr LicenseType_LicenseTypeEnum LicenseType::KIOSK;
constexpr LicenseType_LicenseTypeEnum LicenseType::CDM_PACKAGED;
constexpr LicenseType_LicenseTypeEnum LicenseType::LicenseTypeEnum_MIN;
constexpr LicenseType_LicenseTypeEnum LicenseType::LicenseTypeEnum_MAX;
constexpr int LicenseType::LicenseTypeEnum_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceRegisterRequest_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceRegisterRequest_Type_strings[6] = {};

static const char DeviceRegisterRequest_Type_names[] =
  "ANDROID_BROWSER"
  "BROWSER"
  "DEVICE"
  "IOS_BROWSER"
  "TT"
  "USER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceRegisterRequest_Type_entries[] = {
  { {DeviceRegisterRequest_Type_names + 0, 15}, 4 },
  { {DeviceRegisterRequest_Type_names + 15, 7}, 3 },
  { {DeviceRegisterRequest_Type_names + 22, 6}, 2 },
  { {DeviceRegisterRequest_Type_names + 28, 11}, 6 },
  { {DeviceRegisterRequest_Type_names + 39, 2}, 0 },
  { {DeviceRegisterRequest_Type_names + 41, 4}, 1 },
};

static const int DeviceRegisterRequest_Type_entries_by_number[] = {
  4, // 0 -> TT
  5, // 1 -> USER
  2, // 2 -> DEVICE
  1, // 3 -> BROWSER
  0, // 4 -> ANDROID_BROWSER
  3, // 6 -> IOS_BROWSER
};

const std::string& DeviceRegisterRequest_Type_Name(
    DeviceRegisterRequest_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceRegisterRequest_Type_entries,
          DeviceRegisterRequest_Type_entries_by_number,
          6, DeviceRegisterRequest_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceRegisterRequest_Type_entries,
      DeviceRegisterRequest_Type_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceRegisterRequest_Type_strings[idx].get();
}
bool DeviceRegisterRequest_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceRegisterRequest_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceRegisterRequest_Type_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<DeviceRegisterRequest_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceRegisterRequest_Type DeviceRegisterRequest::TT;
constexpr DeviceRegisterRequest_Type DeviceRegisterRequest::USER;
constexpr DeviceRegisterRequest_Type DeviceRegisterRequest::DEVICE;
constexpr DeviceRegisterRequest_Type DeviceRegisterRequest::BROWSER;
constexpr DeviceRegisterRequest_Type DeviceRegisterRequest::ANDROID_BROWSER;
constexpr DeviceRegisterRequest_Type DeviceRegisterRequest::IOS_BROWSER;
constexpr DeviceRegisterRequest_Type DeviceRegisterRequest::Type_MIN;
constexpr DeviceRegisterRequest_Type DeviceRegisterRequest::Type_MAX;
constexpr int DeviceRegisterRequest::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceRegisterRequest_Flavor_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceRegisterRequest_Flavor_strings[17] = {};

static const char DeviceRegisterRequest_Flavor_names[] =
  "FLAVOR_ENROLLMENT_ATTESTATION"
  "FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_MANUAL_FALLBACK"
  "FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_SERVER_FORCED"
  "FLAVOR_ENROLLMENT_ATTESTATION_LOCAL_FORCED"
  "FLAVOR_ENROLLMENT_ATTESTATION_MANUAL_FALLBACK"
  "FLAVOR_ENROLLMENT_ATTESTATION_ROLLBACK_FORCED"
  "FLAVOR_ENROLLMENT_ATTESTATION_ROLLBACK_MANUAL_FALLBACK"
  "FLAVOR_ENROLLMENT_ATTESTATION_SERVER_FORCED"
  "FLAVOR_ENROLLMENT_INITIAL_SERVER_FORCED"
  "FLAVOR_ENROLLMENT_LOCAL_ADVERTISED"
  "FLAVOR_ENROLLMENT_LOCAL_FORCED"
  "FLAVOR_ENROLLMENT_MANUAL"
  "FLAVOR_ENROLLMENT_MANUAL_RENEW"
  "FLAVOR_ENROLLMENT_RECOVERY"
  "FLAVOR_ENROLLMENT_SERVER_ADVERTISED"
  "FLAVOR_ENROLLMENT_SERVER_FORCED"
  "FLAVOR_USER_REGISTRATION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceRegisterRequest_Flavor_entries[] = {
  { {DeviceRegisterRequest_Flavor_names + 0, 29}, 8 },
  { {DeviceRegisterRequest_Flavor_names + 29, 53}, 15 },
  { {DeviceRegisterRequest_Flavor_names + 82, 51}, 14 },
  { {DeviceRegisterRequest_Flavor_names + 133, 42}, 9 },
  { {DeviceRegisterRequest_Flavor_names + 175, 45}, 11 },
  { {DeviceRegisterRequest_Flavor_names + 220, 45}, 16 },
  { {DeviceRegisterRequest_Flavor_names + 265, 54}, 17 },
  { {DeviceRegisterRequest_Flavor_names + 319, 43}, 10 },
  { {DeviceRegisterRequest_Flavor_names + 362, 39}, 13 },
  { {DeviceRegisterRequest_Flavor_names + 401, 34}, 3 },
  { {DeviceRegisterRequest_Flavor_names + 435, 30}, 2 },
  { {DeviceRegisterRequest_Flavor_names + 465, 24}, 0 },
  { {DeviceRegisterRequest_Flavor_names + 489, 30}, 1 },
  { {DeviceRegisterRequest_Flavor_names + 519, 26}, 6 },
  { {DeviceRegisterRequest_Flavor_names + 545, 35}, 5 },
  { {DeviceRegisterRequest_Flavor_names + 580, 31}, 4 },
  { {DeviceRegisterRequest_Flavor_names + 611, 24}, 7 },
};

static const int DeviceRegisterRequest_Flavor_entries_by_number[] = {
  11, // 0 -> FLAVOR_ENROLLMENT_MANUAL
  12, // 1 -> FLAVOR_ENROLLMENT_MANUAL_RENEW
  10, // 2 -> FLAVOR_ENROLLMENT_LOCAL_FORCED
  9, // 3 -> FLAVOR_ENROLLMENT_LOCAL_ADVERTISED
  15, // 4 -> FLAVOR_ENROLLMENT_SERVER_FORCED
  14, // 5 -> FLAVOR_ENROLLMENT_SERVER_ADVERTISED
  13, // 6 -> FLAVOR_ENROLLMENT_RECOVERY
  16, // 7 -> FLAVOR_USER_REGISTRATION
  0, // 8 -> FLAVOR_ENROLLMENT_ATTESTATION
  3, // 9 -> FLAVOR_ENROLLMENT_ATTESTATION_LOCAL_FORCED
  7, // 10 -> FLAVOR_ENROLLMENT_ATTESTATION_SERVER_FORCED
  4, // 11 -> FLAVOR_ENROLLMENT_ATTESTATION_MANUAL_FALLBACK
  8, // 13 -> FLAVOR_ENROLLMENT_INITIAL_SERVER_FORCED
  2, // 14 -> FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_SERVER_FORCED
  1, // 15 -> FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_MANUAL_FALLBACK
  5, // 16 -> FLAVOR_ENROLLMENT_ATTESTATION_ROLLBACK_FORCED
  6, // 17 -> FLAVOR_ENROLLMENT_ATTESTATION_ROLLBACK_MANUAL_FALLBACK
};

const std::string& DeviceRegisterRequest_Flavor_Name(
    DeviceRegisterRequest_Flavor value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceRegisterRequest_Flavor_entries,
          DeviceRegisterRequest_Flavor_entries_by_number,
          17, DeviceRegisterRequest_Flavor_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceRegisterRequest_Flavor_entries,
      DeviceRegisterRequest_Flavor_entries_by_number,
      17, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceRegisterRequest_Flavor_strings[idx].get();
}
bool DeviceRegisterRequest_Flavor_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceRegisterRequest_Flavor* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceRegisterRequest_Flavor_entries, 17, name, &int_value);
  if (success) {
    *value = static_cast<DeviceRegisterRequest_Flavor>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::FLAVOR_ENROLLMENT_MANUAL;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::FLAVOR_ENROLLMENT_MANUAL_RENEW;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::FLAVOR_ENROLLMENT_LOCAL_FORCED;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::FLAVOR_ENROLLMENT_LOCAL_ADVERTISED;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::FLAVOR_ENROLLMENT_SERVER_FORCED;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::FLAVOR_ENROLLMENT_SERVER_ADVERTISED;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::FLAVOR_ENROLLMENT_RECOVERY;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::FLAVOR_USER_REGISTRATION;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::FLAVOR_ENROLLMENT_ATTESTATION;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::FLAVOR_ENROLLMENT_ATTESTATION_LOCAL_FORCED;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::FLAVOR_ENROLLMENT_ATTESTATION_SERVER_FORCED;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::FLAVOR_ENROLLMENT_ATTESTATION_MANUAL_FALLBACK;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::FLAVOR_ENROLLMENT_INITIAL_SERVER_FORCED;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_SERVER_FORCED;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::FLAVOR_ENROLLMENT_ATTESTATION_INITIAL_MANUAL_FALLBACK;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::FLAVOR_ENROLLMENT_ATTESTATION_ROLLBACK_FORCED;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::FLAVOR_ENROLLMENT_ATTESTATION_ROLLBACK_MANUAL_FALLBACK;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::Flavor_MIN;
constexpr DeviceRegisterRequest_Flavor DeviceRegisterRequest::Flavor_MAX;
constexpr int DeviceRegisterRequest::Flavor_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceRegisterRequest_Lifetime_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceRegisterRequest_Lifetime_strings[3] = {};

static const char DeviceRegisterRequest_Lifetime_names[] =
  "LIFETIME_EPHEMERAL_USER"
  "LIFETIME_INDEFINITE"
  "LIFETIME_UNDEFINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceRegisterRequest_Lifetime_entries[] = {
  { {DeviceRegisterRequest_Lifetime_names + 0, 23}, 2 },
  { {DeviceRegisterRequest_Lifetime_names + 23, 19}, 1 },
  { {DeviceRegisterRequest_Lifetime_names + 42, 18}, 0 },
};

static const int DeviceRegisterRequest_Lifetime_entries_by_number[] = {
  2, // 0 -> LIFETIME_UNDEFINED
  1, // 1 -> LIFETIME_INDEFINITE
  0, // 2 -> LIFETIME_EPHEMERAL_USER
};

const std::string& DeviceRegisterRequest_Lifetime_Name(
    DeviceRegisterRequest_Lifetime value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceRegisterRequest_Lifetime_entries,
          DeviceRegisterRequest_Lifetime_entries_by_number,
          3, DeviceRegisterRequest_Lifetime_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceRegisterRequest_Lifetime_entries,
      DeviceRegisterRequest_Lifetime_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceRegisterRequest_Lifetime_strings[idx].get();
}
bool DeviceRegisterRequest_Lifetime_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceRegisterRequest_Lifetime* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceRegisterRequest_Lifetime_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DeviceRegisterRequest_Lifetime>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceRegisterRequest_Lifetime DeviceRegisterRequest::LIFETIME_UNDEFINED;
constexpr DeviceRegisterRequest_Lifetime DeviceRegisterRequest::LIFETIME_INDEFINITE;
constexpr DeviceRegisterRequest_Lifetime DeviceRegisterRequest::LIFETIME_EPHEMERAL_USER;
constexpr DeviceRegisterRequest_Lifetime DeviceRegisterRequest::Lifetime_MIN;
constexpr DeviceRegisterRequest_Lifetime DeviceRegisterRequest::Lifetime_MAX;
constexpr int DeviceRegisterRequest::Lifetime_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceRegisterRequest_PsmExecutionResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceRegisterRequest_PsmExecutionResult_strings[4] = {};

static const char DeviceRegisterRequest_PsmExecutionResult_names[] =
  "PSM_RESULT_ERROR"
  "PSM_RESULT_SUCCESSFUL_WITHOUT_STATE"
  "PSM_RESULT_SUCCESSFUL_WITH_STATE"
  "PSM_RESULT_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceRegisterRequest_PsmExecutionResult_entries[] = {
  { {DeviceRegisterRequest_PsmExecutionResult_names + 0, 16}, 3 },
  { {DeviceRegisterRequest_PsmExecutionResult_names + 16, 35}, 2 },
  { {DeviceRegisterRequest_PsmExecutionResult_names + 51, 32}, 1 },
  { {DeviceRegisterRequest_PsmExecutionResult_names + 83, 18}, 0 },
};

static const int DeviceRegisterRequest_PsmExecutionResult_entries_by_number[] = {
  3, // 0 -> PSM_RESULT_UNKNOWN
  2, // 1 -> PSM_RESULT_SUCCESSFUL_WITH_STATE
  1, // 2 -> PSM_RESULT_SUCCESSFUL_WITHOUT_STATE
  0, // 3 -> PSM_RESULT_ERROR
};

const std::string& DeviceRegisterRequest_PsmExecutionResult_Name(
    DeviceRegisterRequest_PsmExecutionResult value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceRegisterRequest_PsmExecutionResult_entries,
          DeviceRegisterRequest_PsmExecutionResult_entries_by_number,
          4, DeviceRegisterRequest_PsmExecutionResult_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceRegisterRequest_PsmExecutionResult_entries,
      DeviceRegisterRequest_PsmExecutionResult_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceRegisterRequest_PsmExecutionResult_strings[idx].get();
}
bool DeviceRegisterRequest_PsmExecutionResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceRegisterRequest_PsmExecutionResult* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceRegisterRequest_PsmExecutionResult_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DeviceRegisterRequest_PsmExecutionResult>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceRegisterRequest_PsmExecutionResult DeviceRegisterRequest::PSM_RESULT_UNKNOWN;
constexpr DeviceRegisterRequest_PsmExecutionResult DeviceRegisterRequest::PSM_RESULT_SUCCESSFUL_WITH_STATE;
constexpr DeviceRegisterRequest_PsmExecutionResult DeviceRegisterRequest::PSM_RESULT_SUCCESSFUL_WITHOUT_STATE;
constexpr DeviceRegisterRequest_PsmExecutionResult DeviceRegisterRequest::PSM_RESULT_ERROR;
constexpr DeviceRegisterRequest_PsmExecutionResult DeviceRegisterRequest::PsmExecutionResult_MIN;
constexpr DeviceRegisterRequest_PsmExecutionResult DeviceRegisterRequest::PsmExecutionResult_MAX;
constexpr int DeviceRegisterRequest::PsmExecutionResult_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CheckUserAccountResponse_UserAccountType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CheckUserAccountResponse_UserAccountType_strings[4] = {};

static const char CheckUserAccountResponse_UserAccountType_names[] =
  "CONSUMER"
  "DASHER"
  "NOT_EXIST"
  "UNKNOWN_USER_ACCOUNT_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CheckUserAccountResponse_UserAccountType_entries[] = {
  { {CheckUserAccountResponse_UserAccountType_names + 0, 8}, 2 },
  { {CheckUserAccountResponse_UserAccountType_names + 8, 6}, 3 },
  { {CheckUserAccountResponse_UserAccountType_names + 14, 9}, 1 },
  { {CheckUserAccountResponse_UserAccountType_names + 23, 25}, 0 },
};

static const int CheckUserAccountResponse_UserAccountType_entries_by_number[] = {
  3, // 0 -> UNKNOWN_USER_ACCOUNT_TYPE
  2, // 1 -> NOT_EXIST
  0, // 2 -> CONSUMER
  1, // 3 -> DASHER
};

const std::string& CheckUserAccountResponse_UserAccountType_Name(
    CheckUserAccountResponse_UserAccountType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CheckUserAccountResponse_UserAccountType_entries,
          CheckUserAccountResponse_UserAccountType_entries_by_number,
          4, CheckUserAccountResponse_UserAccountType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CheckUserAccountResponse_UserAccountType_entries,
      CheckUserAccountResponse_UserAccountType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CheckUserAccountResponse_UserAccountType_strings[idx].get();
}
bool CheckUserAccountResponse_UserAccountType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CheckUserAccountResponse_UserAccountType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CheckUserAccountResponse_UserAccountType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CheckUserAccountResponse_UserAccountType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CheckUserAccountResponse_UserAccountType CheckUserAccountResponse::UNKNOWN_USER_ACCOUNT_TYPE;
constexpr CheckUserAccountResponse_UserAccountType CheckUserAccountResponse::NOT_EXIST;
constexpr CheckUserAccountResponse_UserAccountType CheckUserAccountResponse::CONSUMER;
constexpr CheckUserAccountResponse_UserAccountType CheckUserAccountResponse::DASHER;
constexpr CheckUserAccountResponse_UserAccountType CheckUserAccountResponse::UserAccountType_MIN;
constexpr CheckUserAccountResponse_UserAccountType CheckUserAccountResponse::UserAccountType_MAX;
constexpr int CheckUserAccountResponse::UserAccountType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceRegisterResponse_DeviceMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceRegisterResponse_DeviceMode_strings[4] = {};

static const char DeviceRegisterResponse_DeviceMode_names[] =
  "CHROME_AD"
  "DEMO"
  "ENTERPRISE"
  "RETAIL_DEPRECATED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceRegisterResponse_DeviceMode_entries[] = {
  { {DeviceRegisterResponse_DeviceMode_names + 0, 9}, 2 },
  { {DeviceRegisterResponse_DeviceMode_names + 9, 4}, 3 },
  { {DeviceRegisterResponse_DeviceMode_names + 13, 10}, 0 },
  { {DeviceRegisterResponse_DeviceMode_names + 23, 17}, 1 },
};

static const int DeviceRegisterResponse_DeviceMode_entries_by_number[] = {
  2, // 0 -> ENTERPRISE
  3, // 1 -> RETAIL_DEPRECATED
  0, // 2 -> CHROME_AD
  1, // 3 -> DEMO
};

const std::string& DeviceRegisterResponse_DeviceMode_Name(
    DeviceRegisterResponse_DeviceMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceRegisterResponse_DeviceMode_entries,
          DeviceRegisterResponse_DeviceMode_entries_by_number,
          4, DeviceRegisterResponse_DeviceMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceRegisterResponse_DeviceMode_entries,
      DeviceRegisterResponse_DeviceMode_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceRegisterResponse_DeviceMode_strings[idx].get();
}
bool DeviceRegisterResponse_DeviceMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceRegisterResponse_DeviceMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceRegisterResponse_DeviceMode_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DeviceRegisterResponse_DeviceMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceRegisterResponse_DeviceMode DeviceRegisterResponse::ENTERPRISE;
constexpr DeviceRegisterResponse_DeviceMode DeviceRegisterResponse::RETAIL_DEPRECATED;
constexpr DeviceRegisterResponse_DeviceMode DeviceRegisterResponse::CHROME_AD;
constexpr DeviceRegisterResponse_DeviceMode DeviceRegisterResponse::DEMO;
constexpr DeviceRegisterResponse_DeviceMode DeviceRegisterResponse::DeviceMode_MIN;
constexpr DeviceRegisterResponse_DeviceMode DeviceRegisterResponse::DeviceMode_MAX;
constexpr int DeviceRegisterResponse::DeviceMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceCertUploadRequest_CertificateType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceCertUploadRequest_CertificateType_strings[3] = {};

static const char DeviceCertUploadRequest_CertificateType_names[] =
  "CERTIFICATE_TYPE_UNSPECIFIED"
  "ENTERPRISE_ENROLLMENT_CERTIFICATE"
  "ENTERPRISE_MACHINE_CERTIFICATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceCertUploadRequest_CertificateType_entries[] = {
  { {DeviceCertUploadRequest_CertificateType_names + 0, 28}, 0 },
  { {DeviceCertUploadRequest_CertificateType_names + 28, 33}, 2 },
  { {DeviceCertUploadRequest_CertificateType_names + 61, 30}, 1 },
};

static const int DeviceCertUploadRequest_CertificateType_entries_by_number[] = {
  0, // 0 -> CERTIFICATE_TYPE_UNSPECIFIED
  2, // 1 -> ENTERPRISE_MACHINE_CERTIFICATE
  1, // 2 -> ENTERPRISE_ENROLLMENT_CERTIFICATE
};

const std::string& DeviceCertUploadRequest_CertificateType_Name(
    DeviceCertUploadRequest_CertificateType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceCertUploadRequest_CertificateType_entries,
          DeviceCertUploadRequest_CertificateType_entries_by_number,
          3, DeviceCertUploadRequest_CertificateType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceCertUploadRequest_CertificateType_entries,
      DeviceCertUploadRequest_CertificateType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceCertUploadRequest_CertificateType_strings[idx].get();
}
bool DeviceCertUploadRequest_CertificateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceCertUploadRequest_CertificateType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceCertUploadRequest_CertificateType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DeviceCertUploadRequest_CertificateType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceCertUploadRequest_CertificateType DeviceCertUploadRequest::CERTIFICATE_TYPE_UNSPECIFIED;
constexpr DeviceCertUploadRequest_CertificateType DeviceCertUploadRequest::ENTERPRISE_MACHINE_CERTIFICATE;
constexpr DeviceCertUploadRequest_CertificateType DeviceCertUploadRequest::ENTERPRISE_ENROLLMENT_CERTIFICATE;
constexpr DeviceCertUploadRequest_CertificateType DeviceCertUploadRequest::CertificateType_MIN;
constexpr DeviceCertUploadRequest_CertificateType DeviceCertUploadRequest::CertificateType_MAX;
constexpr int DeviceCertUploadRequest::CertificateType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceServiceApiAccessRequest_DeviceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceServiceApiAccessRequest_DeviceType_strings[4] = {};

static const char DeviceServiceApiAccessRequest_DeviceType_names[] =
  "ANDROID_OS"
  "CHROME_BROWSER"
  "CHROME_OS"
  "CHROME_OS_DEMO_MODE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceServiceApiAccessRequest_DeviceType_entries[] = {
  { {DeviceServiceApiAccessRequest_DeviceType_names + 0, 10}, 1 },
  { {DeviceServiceApiAccessRequest_DeviceType_names + 10, 14}, 3 },
  { {DeviceServiceApiAccessRequest_DeviceType_names + 24, 9}, 0 },
  { {DeviceServiceApiAccessRequest_DeviceType_names + 33, 19}, 2 },
};

static const int DeviceServiceApiAccessRequest_DeviceType_entries_by_number[] = {
  2, // 0 -> CHROME_OS
  0, // 1 -> ANDROID_OS
  3, // 2 -> CHROME_OS_DEMO_MODE
  1, // 3 -> CHROME_BROWSER
};

const std::string& DeviceServiceApiAccessRequest_DeviceType_Name(
    DeviceServiceApiAccessRequest_DeviceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceServiceApiAccessRequest_DeviceType_entries,
          DeviceServiceApiAccessRequest_DeviceType_entries_by_number,
          4, DeviceServiceApiAccessRequest_DeviceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceServiceApiAccessRequest_DeviceType_entries,
      DeviceServiceApiAccessRequest_DeviceType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceServiceApiAccessRequest_DeviceType_strings[idx].get();
}
bool DeviceServiceApiAccessRequest_DeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceServiceApiAccessRequest_DeviceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceServiceApiAccessRequest_DeviceType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DeviceServiceApiAccessRequest_DeviceType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceServiceApiAccessRequest_DeviceType DeviceServiceApiAccessRequest::CHROME_OS;
constexpr DeviceServiceApiAccessRequest_DeviceType DeviceServiceApiAccessRequest::ANDROID_OS;
constexpr DeviceServiceApiAccessRequest_DeviceType DeviceServiceApiAccessRequest::CHROME_OS_DEMO_MODE;
constexpr DeviceServiceApiAccessRequest_DeviceType DeviceServiceApiAccessRequest::CHROME_BROWSER;
constexpr DeviceServiceApiAccessRequest_DeviceType DeviceServiceApiAccessRequest::DeviceType_MIN;
constexpr DeviceServiceApiAccessRequest_DeviceType DeviceServiceApiAccessRequest::DeviceType_MAX;
constexpr int DeviceServiceApiAccessRequest::DeviceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PolicyFetchRequest_SignatureType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PolicyFetchRequest_SignatureType_strings[3] = {};

static const char PolicyFetchRequest_SignatureType_names[] =
  "NONE"
  "SHA1_RSA"
  "SHA256_RSA";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PolicyFetchRequest_SignatureType_entries[] = {
  { {PolicyFetchRequest_SignatureType_names + 0, 4}, 0 },
  { {PolicyFetchRequest_SignatureType_names + 4, 8}, 1 },
  { {PolicyFetchRequest_SignatureType_names + 12, 10}, 2 },
};

static const int PolicyFetchRequest_SignatureType_entries_by_number[] = {
  0, // 0 -> NONE
  1, // 1 -> SHA1_RSA
  2, // 2 -> SHA256_RSA
};

const std::string& PolicyFetchRequest_SignatureType_Name(
    PolicyFetchRequest_SignatureType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PolicyFetchRequest_SignatureType_entries,
          PolicyFetchRequest_SignatureType_entries_by_number,
          3, PolicyFetchRequest_SignatureType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PolicyFetchRequest_SignatureType_entries,
      PolicyFetchRequest_SignatureType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PolicyFetchRequest_SignatureType_strings[idx].get();
}
bool PolicyFetchRequest_SignatureType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolicyFetchRequest_SignatureType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PolicyFetchRequest_SignatureType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PolicyFetchRequest_SignatureType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PolicyFetchRequest_SignatureType PolicyFetchRequest::NONE;
constexpr PolicyFetchRequest_SignatureType PolicyFetchRequest::SHA1_RSA;
constexpr PolicyFetchRequest_SignatureType PolicyFetchRequest::SHA256_RSA;
constexpr PolicyFetchRequest_SignatureType PolicyFetchRequest::SignatureType_MIN;
constexpr PolicyFetchRequest_SignatureType PolicyFetchRequest::SignatureType_MAX;
constexpr int PolicyFetchRequest::SignatureType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceState_DeviceMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceState_DeviceMode_strings[2] = {};

static const char DeviceState_DeviceMode_names[] =
  "DEVICE_MODE_DISABLED"
  "DEVICE_MODE_NORMAL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceState_DeviceMode_entries[] = {
  { {DeviceState_DeviceMode_names + 0, 20}, 1 },
  { {DeviceState_DeviceMode_names + 20, 18}, 0 },
};

static const int DeviceState_DeviceMode_entries_by_number[] = {
  1, // 0 -> DEVICE_MODE_NORMAL
  0, // 1 -> DEVICE_MODE_DISABLED
};

const std::string& DeviceState_DeviceMode_Name(
    DeviceState_DeviceMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceState_DeviceMode_entries,
          DeviceState_DeviceMode_entries_by_number,
          2, DeviceState_DeviceMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceState_DeviceMode_entries,
      DeviceState_DeviceMode_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceState_DeviceMode_strings[idx].get();
}
bool DeviceState_DeviceMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceState_DeviceMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceState_DeviceMode_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<DeviceState_DeviceMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceState_DeviceMode DeviceState::DEVICE_MODE_NORMAL;
constexpr DeviceState_DeviceMode DeviceState::DEVICE_MODE_DISABLED;
constexpr DeviceState_DeviceMode DeviceState::DeviceMode_MIN;
constexpr DeviceState_DeviceMode DeviceState::DeviceMode_MAX;
constexpr int DeviceState::DeviceMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PolicyData_AssociationState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PolicyData_AssociationState_strings[3] = {};

static const char PolicyData_AssociationState_names[] =
  "ACTIVE"
  "DEPROVISIONED"
  "UNMANAGED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PolicyData_AssociationState_entries[] = {
  { {PolicyData_AssociationState_names + 0, 6}, 0 },
  { {PolicyData_AssociationState_names + 6, 13}, 2 },
  { {PolicyData_AssociationState_names + 19, 9}, 1 },
};

static const int PolicyData_AssociationState_entries_by_number[] = {
  0, // 0 -> ACTIVE
  2, // 1 -> UNMANAGED
  1, // 2 -> DEPROVISIONED
};

const std::string& PolicyData_AssociationState_Name(
    PolicyData_AssociationState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PolicyData_AssociationState_entries,
          PolicyData_AssociationState_entries_by_number,
          3, PolicyData_AssociationState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PolicyData_AssociationState_entries,
      PolicyData_AssociationState_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PolicyData_AssociationState_strings[idx].get();
}
bool PolicyData_AssociationState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolicyData_AssociationState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PolicyData_AssociationState_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PolicyData_AssociationState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PolicyData_AssociationState PolicyData::ACTIVE;
constexpr PolicyData_AssociationState PolicyData::UNMANAGED;
constexpr PolicyData_AssociationState PolicyData::DEPROVISIONED;
constexpr PolicyData_AssociationState PolicyData::AssociationState_MIN;
constexpr PolicyData_AssociationState PolicyData::AssociationState_MAX;
constexpr int PolicyData::AssociationState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PolicyData_ManagementMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PolicyData_ManagementMode_strings[3] = {};

static const char PolicyData_ManagementMode_names[] =
  "ENTERPRISE_MANAGED"
  "LOCAL_OWNER"
  "OBSOLETE_CONSUMER_MANAGED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PolicyData_ManagementMode_entries[] = {
  { {PolicyData_ManagementMode_names + 0, 18}, 1 },
  { {PolicyData_ManagementMode_names + 18, 11}, 0 },
  { {PolicyData_ManagementMode_names + 29, 25}, 2 },
};

static const int PolicyData_ManagementMode_entries_by_number[] = {
  1, // 0 -> LOCAL_OWNER
  0, // 1 -> ENTERPRISE_MANAGED
  2, // 2 -> OBSOLETE_CONSUMER_MANAGED
};

const std::string& PolicyData_ManagementMode_Name(
    PolicyData_ManagementMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PolicyData_ManagementMode_entries,
          PolicyData_ManagementMode_entries_by_number,
          3, PolicyData_ManagementMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PolicyData_ManagementMode_entries,
      PolicyData_ManagementMode_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PolicyData_ManagementMode_strings[idx].get();
}
bool PolicyData_ManagementMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolicyData_ManagementMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PolicyData_ManagementMode_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PolicyData_ManagementMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PolicyData_ManagementMode PolicyData::LOCAL_OWNER;
constexpr PolicyData_ManagementMode PolicyData::ENTERPRISE_MANAGED;
constexpr PolicyData_ManagementMode PolicyData::OBSOLETE_CONSUMER_MANAGED;
constexpr PolicyData_ManagementMode PolicyData::ManagementMode_MIN;
constexpr PolicyData_ManagementMode PolicyData::ManagementMode_MAX;
constexpr int PolicyData::ManagementMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PolicyData_MarketSegment_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PolicyData_MarketSegment_strings[3] = {};

static const char PolicyData_MarketSegment_names[] =
  "ENROLLED_EDUCATION"
  "ENROLLED_ENTERPRISE"
  "MARKET_SEGMENT_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PolicyData_MarketSegment_entries[] = {
  { {PolicyData_MarketSegment_names + 0, 18}, 1 },
  { {PolicyData_MarketSegment_names + 18, 19}, 2 },
  { {PolicyData_MarketSegment_names + 37, 26}, 0 },
};

static const int PolicyData_MarketSegment_entries_by_number[] = {
  2, // 0 -> MARKET_SEGMENT_UNSPECIFIED
  0, // 1 -> ENROLLED_EDUCATION
  1, // 2 -> ENROLLED_ENTERPRISE
};

const std::string& PolicyData_MarketSegment_Name(
    PolicyData_MarketSegment value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PolicyData_MarketSegment_entries,
          PolicyData_MarketSegment_entries_by_number,
          3, PolicyData_MarketSegment_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PolicyData_MarketSegment_entries,
      PolicyData_MarketSegment_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PolicyData_MarketSegment_strings[idx].get();
}
bool PolicyData_MarketSegment_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolicyData_MarketSegment* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PolicyData_MarketSegment_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PolicyData_MarketSegment>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PolicyData_MarketSegment PolicyData::MARKET_SEGMENT_UNSPECIFIED;
constexpr PolicyData_MarketSegment PolicyData::ENROLLED_EDUCATION;
constexpr PolicyData_MarketSegment PolicyData::ENROLLED_ENTERPRISE;
constexpr PolicyData_MarketSegment PolicyData::MarketSegment_MIN;
constexpr PolicyData_MarketSegment PolicyData::MarketSegment_MAX;
constexpr int PolicyData::MarketSegment_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PolicyData_MetricsLogSegment_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PolicyData_MetricsLogSegment_strings[5] = {};

static const char PolicyData_MetricsLogSegment_names[] =
  "ENTERPRISE"
  "K12"
  "NONPROFIT"
  "UNIVERSITY"
  "UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PolicyData_MetricsLogSegment_entries[] = {
  { {PolicyData_MetricsLogSegment_names + 0, 10}, 4 },
  { {PolicyData_MetricsLogSegment_names + 10, 3}, 1 },
  { {PolicyData_MetricsLogSegment_names + 13, 9}, 3 },
  { {PolicyData_MetricsLogSegment_names + 22, 10}, 2 },
  { {PolicyData_MetricsLogSegment_names + 32, 11}, 0 },
};

static const int PolicyData_MetricsLogSegment_entries_by_number[] = {
  4, // 0 -> UNSPECIFIED
  1, // 1 -> K12
  3, // 2 -> UNIVERSITY
  2, // 3 -> NONPROFIT
  0, // 4 -> ENTERPRISE
};

const std::string& PolicyData_MetricsLogSegment_Name(
    PolicyData_MetricsLogSegment value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PolicyData_MetricsLogSegment_entries,
          PolicyData_MetricsLogSegment_entries_by_number,
          5, PolicyData_MetricsLogSegment_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PolicyData_MetricsLogSegment_entries,
      PolicyData_MetricsLogSegment_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PolicyData_MetricsLogSegment_strings[idx].get();
}
bool PolicyData_MetricsLogSegment_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolicyData_MetricsLogSegment* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PolicyData_MetricsLogSegment_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<PolicyData_MetricsLogSegment>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PolicyData_MetricsLogSegment PolicyData::UNSPECIFIED;
constexpr PolicyData_MetricsLogSegment PolicyData::K12;
constexpr PolicyData_MetricsLogSegment PolicyData::UNIVERSITY;
constexpr PolicyData_MetricsLogSegment PolicyData::NONPROFIT;
constexpr PolicyData_MetricsLogSegment PolicyData::ENTERPRISE;
constexpr PolicyData_MetricsLogSegment PolicyData::MetricsLogSegment_MIN;
constexpr PolicyData_MetricsLogSegment PolicyData::MetricsLogSegment_MAX;
constexpr int PolicyData::MetricsLogSegment_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ActiveTimePeriod_SessionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ActiveTimePeriod_SessionType_strings[6] = {};

static const char ActiveTimePeriod_SessionType_names[] =
  "SESSION_AFFILIATED_USER"
  "SESSION_ARC_KIOSK"
  "SESSION_KIOSK"
  "SESSION_MANAGED_GUEST"
  "SESSION_UNKNOWN"
  "SESSION_WEB_KIOSK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ActiveTimePeriod_SessionType_entries[] = {
  { {ActiveTimePeriod_SessionType_names + 0, 23}, 1 },
  { {ActiveTimePeriod_SessionType_names + 23, 17}, 4 },
  { {ActiveTimePeriod_SessionType_names + 40, 13}, 3 },
  { {ActiveTimePeriod_SessionType_names + 53, 21}, 2 },
  { {ActiveTimePeriod_SessionType_names + 74, 15}, 0 },
  { {ActiveTimePeriod_SessionType_names + 89, 17}, 5 },
};

static const int ActiveTimePeriod_SessionType_entries_by_number[] = {
  4, // 0 -> SESSION_UNKNOWN
  0, // 1 -> SESSION_AFFILIATED_USER
  3, // 2 -> SESSION_MANAGED_GUEST
  2, // 3 -> SESSION_KIOSK
  1, // 4 -> SESSION_ARC_KIOSK
  5, // 5 -> SESSION_WEB_KIOSK
};

const std::string& ActiveTimePeriod_SessionType_Name(
    ActiveTimePeriod_SessionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ActiveTimePeriod_SessionType_entries,
          ActiveTimePeriod_SessionType_entries_by_number,
          6, ActiveTimePeriod_SessionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ActiveTimePeriod_SessionType_entries,
      ActiveTimePeriod_SessionType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ActiveTimePeriod_SessionType_strings[idx].get();
}
bool ActiveTimePeriod_SessionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActiveTimePeriod_SessionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ActiveTimePeriod_SessionType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<ActiveTimePeriod_SessionType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ActiveTimePeriod_SessionType ActiveTimePeriod::SESSION_UNKNOWN;
constexpr ActiveTimePeriod_SessionType ActiveTimePeriod::SESSION_AFFILIATED_USER;
constexpr ActiveTimePeriod_SessionType ActiveTimePeriod::SESSION_MANAGED_GUEST;
constexpr ActiveTimePeriod_SessionType ActiveTimePeriod::SESSION_KIOSK;
constexpr ActiveTimePeriod_SessionType ActiveTimePeriod::SESSION_ARC_KIOSK;
constexpr ActiveTimePeriod_SessionType ActiveTimePeriod::SESSION_WEB_KIOSK;
constexpr ActiveTimePeriod_SessionType ActiveTimePeriod::SessionType_MIN;
constexpr ActiveTimePeriod_SessionType ActiveTimePeriod::SessionType_MAX;
constexpr int ActiveTimePeriod::SessionType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool NetworkInterface_NetworkDeviceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NetworkInterface_NetworkDeviceType_strings[4] = {};

static const char NetworkInterface_NetworkDeviceType_names[] =
  "TYPE_BLUETOOTH"
  "TYPE_CELLULAR"
  "TYPE_ETHERNET"
  "TYPE_WIFI";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NetworkInterface_NetworkDeviceType_entries[] = {
  { {NetworkInterface_NetworkDeviceType_names + 0, 14}, 3 },
  { {NetworkInterface_NetworkDeviceType_names + 14, 13}, 4 },
  { {NetworkInterface_NetworkDeviceType_names + 27, 13}, 0 },
  { {NetworkInterface_NetworkDeviceType_names + 40, 9}, 1 },
};

static const int NetworkInterface_NetworkDeviceType_entries_by_number[] = {
  2, // 0 -> TYPE_ETHERNET
  3, // 1 -> TYPE_WIFI
  0, // 3 -> TYPE_BLUETOOTH
  1, // 4 -> TYPE_CELLULAR
};

const std::string& NetworkInterface_NetworkDeviceType_Name(
    NetworkInterface_NetworkDeviceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NetworkInterface_NetworkDeviceType_entries,
          NetworkInterface_NetworkDeviceType_entries_by_number,
          4, NetworkInterface_NetworkDeviceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NetworkInterface_NetworkDeviceType_entries,
      NetworkInterface_NetworkDeviceType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NetworkInterface_NetworkDeviceType_strings[idx].get();
}
bool NetworkInterface_NetworkDeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetworkInterface_NetworkDeviceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NetworkInterface_NetworkDeviceType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<NetworkInterface_NetworkDeviceType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr NetworkInterface_NetworkDeviceType NetworkInterface::TYPE_ETHERNET;
constexpr NetworkInterface_NetworkDeviceType NetworkInterface::TYPE_WIFI;
constexpr NetworkInterface_NetworkDeviceType NetworkInterface::TYPE_BLUETOOTH;
constexpr NetworkInterface_NetworkDeviceType NetworkInterface::TYPE_CELLULAR;
constexpr NetworkInterface_NetworkDeviceType NetworkInterface::NetworkDeviceType_MIN;
constexpr NetworkInterface_NetworkDeviceType NetworkInterface::NetworkDeviceType_MAX;
constexpr int NetworkInterface::NetworkDeviceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool NetworkState_ConnectionState_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 11:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NetworkState_ConnectionState_strings[9] = {};

static const char NetworkState_ConnectionState_names[] =
  "ASSOCIATION"
  "CONFIGURATION"
  "DISCONNECT"
  "FAILURE"
  "IDLE"
  "ONLINE"
  "PORTAL"
  "READY"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NetworkState_ConnectionState_entries[] = {
  { {NetworkState_ConnectionState_names + 0, 11}, 2 },
  { {NetworkState_ConnectionState_names + 11, 13}, 3 },
  { {NetworkState_ConnectionState_names + 24, 10}, 8 },
  { {NetworkState_ConnectionState_names + 34, 7}, 9 },
  { {NetworkState_ConnectionState_names + 41, 4}, 0 },
  { {NetworkState_ConnectionState_names + 45, 6}, 7 },
  { {NetworkState_ConnectionState_names + 51, 6}, 5 },
  { {NetworkState_ConnectionState_names + 57, 5}, 4 },
  { {NetworkState_ConnectionState_names + 62, 7}, 11 },
};

static const int NetworkState_ConnectionState_entries_by_number[] = {
  4, // 0 -> IDLE
  0, // 2 -> ASSOCIATION
  1, // 3 -> CONFIGURATION
  7, // 4 -> READY
  6, // 5 -> PORTAL
  5, // 7 -> ONLINE
  2, // 8 -> DISCONNECT
  3, // 9 -> FAILURE
  8, // 11 -> UNKNOWN
};

const std::string& NetworkState_ConnectionState_Name(
    NetworkState_ConnectionState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NetworkState_ConnectionState_entries,
          NetworkState_ConnectionState_entries_by_number,
          9, NetworkState_ConnectionState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NetworkState_ConnectionState_entries,
      NetworkState_ConnectionState_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NetworkState_ConnectionState_strings[idx].get();
}
bool NetworkState_ConnectionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetworkState_ConnectionState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NetworkState_ConnectionState_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<NetworkState_ConnectionState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr NetworkState_ConnectionState NetworkState::IDLE;
constexpr NetworkState_ConnectionState NetworkState::ASSOCIATION;
constexpr NetworkState_ConnectionState NetworkState::CONFIGURATION;
constexpr NetworkState_ConnectionState NetworkState::READY;
constexpr NetworkState_ConnectionState NetworkState::PORTAL;
constexpr NetworkState_ConnectionState NetworkState::ONLINE;
constexpr NetworkState_ConnectionState NetworkState::DISCONNECT;
constexpr NetworkState_ConnectionState NetworkState::FAILURE;
constexpr NetworkState_ConnectionState NetworkState::UNKNOWN;
constexpr NetworkState_ConnectionState NetworkState::ConnectionState_MIN;
constexpr NetworkState_ConnectionState NetworkState::ConnectionState_MAX;
constexpr int NetworkState::ConnectionState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceUser_UserType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceUser_UserType_strings[2] = {};

static const char DeviceUser_UserType_names[] =
  "USER_TYPE_MANAGED"
  "USER_TYPE_UNMANAGED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceUser_UserType_entries[] = {
  { {DeviceUser_UserType_names + 0, 17}, 0 },
  { {DeviceUser_UserType_names + 17, 19}, 1 },
};

static const int DeviceUser_UserType_entries_by_number[] = {
  0, // 0 -> USER_TYPE_MANAGED
  1, // 1 -> USER_TYPE_UNMANAGED
};

const std::string& DeviceUser_UserType_Name(
    DeviceUser_UserType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceUser_UserType_entries,
          DeviceUser_UserType_entries_by_number,
          2, DeviceUser_UserType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceUser_UserType_entries,
      DeviceUser_UserType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceUser_UserType_strings[idx].get();
}
bool DeviceUser_UserType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceUser_UserType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceUser_UserType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<DeviceUser_UserType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceUser_UserType DeviceUser::USER_TYPE_MANAGED;
constexpr DeviceUser_UserType DeviceUser::USER_TYPE_UNMANAGED;
constexpr DeviceUser_UserType DeviceUser::UserType_MIN;
constexpr DeviceUser_UserType DeviceUser::UserType_MAX;
constexpr int DeviceUser::UserType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PowerStatus_PowerSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PowerStatus_PowerSource_strings[3] = {};

static const char PowerStatus_PowerSource_names[] =
  "POWER_AC"
  "POWER_BATTERY"
  "POWER_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PowerStatus_PowerSource_entries[] = {
  { {PowerStatus_PowerSource_names + 0, 8}, 1 },
  { {PowerStatus_PowerSource_names + 8, 13}, 2 },
  { {PowerStatus_PowerSource_names + 21, 13}, 0 },
};

static const int PowerStatus_PowerSource_entries_by_number[] = {
  2, // 0 -> POWER_UNKNOWN
  0, // 1 -> POWER_AC
  1, // 2 -> POWER_BATTERY
};

const std::string& PowerStatus_PowerSource_Name(
    PowerStatus_PowerSource value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PowerStatus_PowerSource_entries,
          PowerStatus_PowerSource_entries_by_number,
          3, PowerStatus_PowerSource_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PowerStatus_PowerSource_entries,
      PowerStatus_PowerSource_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PowerStatus_PowerSource_strings[idx].get();
}
bool PowerStatus_PowerSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerStatus_PowerSource* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PowerStatus_PowerSource_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PowerStatus_PowerSource>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PowerStatus_PowerSource PowerStatus::POWER_UNKNOWN;
constexpr PowerStatus_PowerSource PowerStatus::POWER_AC;
constexpr PowerStatus_PowerSource PowerStatus::POWER_BATTERY;
constexpr PowerStatus_PowerSource PowerStatus::PowerSource_MIN;
constexpr PowerStatus_PowerSource PowerStatus::PowerSource_MAX;
constexpr int PowerStatus::PowerSource_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DiskInfo_DevicePurpose_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DiskInfo_DevicePurpose_strings[3] = {};

static const char DiskInfo_DevicePurpose_names[] =
  "PURPOSE_BOOT"
  "PURPOSE_SWAP"
  "PURPOSE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DiskInfo_DevicePurpose_entries[] = {
  { {DiskInfo_DevicePurpose_names + 0, 12}, 1 },
  { {DiskInfo_DevicePurpose_names + 12, 12}, 2 },
  { {DiskInfo_DevicePurpose_names + 24, 15}, 0 },
};

static const int DiskInfo_DevicePurpose_entries_by_number[] = {
  2, // 0 -> PURPOSE_UNKNOWN
  0, // 1 -> PURPOSE_BOOT
  1, // 2 -> PURPOSE_SWAP
};

const std::string& DiskInfo_DevicePurpose_Name(
    DiskInfo_DevicePurpose value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DiskInfo_DevicePurpose_entries,
          DiskInfo_DevicePurpose_entries_by_number,
          3, DiskInfo_DevicePurpose_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DiskInfo_DevicePurpose_entries,
      DiskInfo_DevicePurpose_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DiskInfo_DevicePurpose_strings[idx].get();
}
bool DiskInfo_DevicePurpose_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DiskInfo_DevicePurpose* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DiskInfo_DevicePurpose_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DiskInfo_DevicePurpose>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DiskInfo_DevicePurpose DiskInfo::PURPOSE_UNKNOWN;
constexpr DiskInfo_DevicePurpose DiskInfo::PURPOSE_BOOT;
constexpr DiskInfo_DevicePurpose DiskInfo::PURPOSE_SWAP;
constexpr DiskInfo_DevicePurpose DiskInfo::DevicePurpose_MIN;
constexpr DiskInfo_DevicePurpose DiskInfo::DevicePurpose_MAX;
constexpr int DiskInfo::DevicePurpose_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CpuInfo_Architecture_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CpuInfo_Architecture_strings[4] = {};

static const char CpuInfo_Architecture_names[] =
  "AARCH64"
  "ARCHITECTURE_UNSPECIFIED"
  "ARMV7L"
  "X86_64";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CpuInfo_Architecture_entries[] = {
  { {CpuInfo_Architecture_names + 0, 7}, 2 },
  { {CpuInfo_Architecture_names + 7, 24}, 0 },
  { {CpuInfo_Architecture_names + 31, 6}, 3 },
  { {CpuInfo_Architecture_names + 37, 6}, 1 },
};

static const int CpuInfo_Architecture_entries_by_number[] = {
  1, // 0 -> ARCHITECTURE_UNSPECIFIED
  3, // 1 -> X86_64
  0, // 2 -> AARCH64
  2, // 3 -> ARMV7L
};

const std::string& CpuInfo_Architecture_Name(
    CpuInfo_Architecture value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CpuInfo_Architecture_entries,
          CpuInfo_Architecture_entries_by_number,
          4, CpuInfo_Architecture_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CpuInfo_Architecture_entries,
      CpuInfo_Architecture_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CpuInfo_Architecture_strings[idx].get();
}
bool CpuInfo_Architecture_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CpuInfo_Architecture* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CpuInfo_Architecture_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CpuInfo_Architecture>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CpuInfo_Architecture CpuInfo::ARCHITECTURE_UNSPECIFIED;
constexpr CpuInfo_Architecture CpuInfo::X86_64;
constexpr CpuInfo_Architecture CpuInfo::AARCH64;
constexpr CpuInfo_Architecture CpuInfo::ARMV7L;
constexpr CpuInfo_Architecture CpuInfo::Architecture_MIN;
constexpr CpuInfo_Architecture CpuInfo::Architecture_MAX;
constexpr int CpuInfo::Architecture_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CrashReportInfo_CrashReportUploadStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CrashReportInfo_CrashReportUploadStatus_strings[5] = {};

static const char CrashReportInfo_CrashReportUploadStatus_names[] =
  "UPLOAD_STATUS_NOT_UPLOADED"
  "UPLOAD_STATUS_PENDING"
  "UPLOAD_STATUS_PENDING_USER_REQUESTED"
  "UPLOAD_STATUS_UNKNOWN"
  "UPLOAD_STATUS_UPLOADED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CrashReportInfo_CrashReportUploadStatus_entries[] = {
  { {CrashReportInfo_CrashReportUploadStatus_names + 0, 26}, 1 },
  { {CrashReportInfo_CrashReportUploadStatus_names + 26, 21}, 2 },
  { {CrashReportInfo_CrashReportUploadStatus_names + 47, 36}, 3 },
  { {CrashReportInfo_CrashReportUploadStatus_names + 83, 21}, 0 },
  { {CrashReportInfo_CrashReportUploadStatus_names + 104, 22}, 4 },
};

static const int CrashReportInfo_CrashReportUploadStatus_entries_by_number[] = {
  3, // 0 -> UPLOAD_STATUS_UNKNOWN
  0, // 1 -> UPLOAD_STATUS_NOT_UPLOADED
  1, // 2 -> UPLOAD_STATUS_PENDING
  2, // 3 -> UPLOAD_STATUS_PENDING_USER_REQUESTED
  4, // 4 -> UPLOAD_STATUS_UPLOADED
};

const std::string& CrashReportInfo_CrashReportUploadStatus_Name(
    CrashReportInfo_CrashReportUploadStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CrashReportInfo_CrashReportUploadStatus_entries,
          CrashReportInfo_CrashReportUploadStatus_entries_by_number,
          5, CrashReportInfo_CrashReportUploadStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CrashReportInfo_CrashReportUploadStatus_entries,
      CrashReportInfo_CrashReportUploadStatus_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CrashReportInfo_CrashReportUploadStatus_strings[idx].get();
}
bool CrashReportInfo_CrashReportUploadStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CrashReportInfo_CrashReportUploadStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CrashReportInfo_CrashReportUploadStatus_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<CrashReportInfo_CrashReportUploadStatus>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CrashReportInfo_CrashReportUploadStatus CrashReportInfo::UPLOAD_STATUS_UNKNOWN;
constexpr CrashReportInfo_CrashReportUploadStatus CrashReportInfo::UPLOAD_STATUS_NOT_UPLOADED;
constexpr CrashReportInfo_CrashReportUploadStatus CrashReportInfo::UPLOAD_STATUS_PENDING;
constexpr CrashReportInfo_CrashReportUploadStatus CrashReportInfo::UPLOAD_STATUS_PENDING_USER_REQUESTED;
constexpr CrashReportInfo_CrashReportUploadStatus CrashReportInfo::UPLOAD_STATUS_UPLOADED;
constexpr CrashReportInfo_CrashReportUploadStatus CrashReportInfo::CrashReportUploadStatus_MIN;
constexpr CrashReportInfo_CrashReportUploadStatus CrashReportInfo::CrashReportUploadStatus_MAX;
constexpr int CrashReportInfo::CrashReportUploadStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool BootInfo_BootMethod_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BootInfo_BootMethod_strings[5] = {};

static const char BootInfo_BootMethod_names[] =
  "CROS_EFI_SECURE"
  "CROS_LEGACY"
  "CROS_SECURE"
  "CROS_UEFI"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BootInfo_BootMethod_entries[] = {
  { {BootInfo_BootMethod_names + 0, 15}, 4 },
  { {BootInfo_BootMethod_names + 15, 11}, 3 },
  { {BootInfo_BootMethod_names + 26, 11}, 1 },
  { {BootInfo_BootMethod_names + 37, 9}, 2 },
  { {BootInfo_BootMethod_names + 46, 7}, 0 },
};

static const int BootInfo_BootMethod_entries_by_number[] = {
  4, // 0 -> UNKNOWN
  2, // 1 -> CROS_SECURE
  3, // 2 -> CROS_UEFI
  1, // 3 -> CROS_LEGACY
  0, // 4 -> CROS_EFI_SECURE
};

const std::string& BootInfo_BootMethod_Name(
    BootInfo_BootMethod value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BootInfo_BootMethod_entries,
          BootInfo_BootMethod_entries_by_number,
          5, BootInfo_BootMethod_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BootInfo_BootMethod_entries,
      BootInfo_BootMethod_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BootInfo_BootMethod_strings[idx].get();
}
bool BootInfo_BootMethod_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BootInfo_BootMethod* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BootInfo_BootMethod_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<BootInfo_BootMethod>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BootInfo_BootMethod BootInfo::UNKNOWN;
constexpr BootInfo_BootMethod BootInfo::CROS_SECURE;
constexpr BootInfo_BootMethod BootInfo::CROS_UEFI;
constexpr BootInfo_BootMethod BootInfo::CROS_LEGACY;
constexpr BootInfo_BootMethod BootInfo::CROS_EFI_SECURE;
constexpr BootInfo_BootMethod BootInfo::BootMethod_MIN;
constexpr BootInfo_BootMethod BootInfo::BootMethod_MAX;
constexpr int BootInfo::BootMethod_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool OsUpdateStatus_UpdateStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OsUpdateStatus_UpdateStatus_strings[4] = {};

static const char OsUpdateStatus_UpdateStatus_names[] =
  "OS_IMAGE_DOWNLOAD_IN_PROGRESS"
  "OS_IMAGE_DOWNLOAD_NOT_STARTED"
  "OS_UPDATE_NEED_REBOOT"
  "OS_UP_TO_DATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OsUpdateStatus_UpdateStatus_entries[] = {
  { {OsUpdateStatus_UpdateStatus_names + 0, 29}, 2 },
  { {OsUpdateStatus_UpdateStatus_names + 29, 29}, 1 },
  { {OsUpdateStatus_UpdateStatus_names + 58, 21}, 3 },
  { {OsUpdateStatus_UpdateStatus_names + 79, 13}, 0 },
};

static const int OsUpdateStatus_UpdateStatus_entries_by_number[] = {
  3, // 0 -> OS_UP_TO_DATE
  1, // 1 -> OS_IMAGE_DOWNLOAD_NOT_STARTED
  0, // 2 -> OS_IMAGE_DOWNLOAD_IN_PROGRESS
  2, // 3 -> OS_UPDATE_NEED_REBOOT
};

const std::string& OsUpdateStatus_UpdateStatus_Name(
    OsUpdateStatus_UpdateStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          OsUpdateStatus_UpdateStatus_entries,
          OsUpdateStatus_UpdateStatus_entries_by_number,
          4, OsUpdateStatus_UpdateStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      OsUpdateStatus_UpdateStatus_entries,
      OsUpdateStatus_UpdateStatus_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     OsUpdateStatus_UpdateStatus_strings[idx].get();
}
bool OsUpdateStatus_UpdateStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OsUpdateStatus_UpdateStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      OsUpdateStatus_UpdateStatus_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<OsUpdateStatus_UpdateStatus>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr OsUpdateStatus_UpdateStatus OsUpdateStatus::OS_UP_TO_DATE;
constexpr OsUpdateStatus_UpdateStatus OsUpdateStatus::OS_IMAGE_DOWNLOAD_NOT_STARTED;
constexpr OsUpdateStatus_UpdateStatus OsUpdateStatus::OS_IMAGE_DOWNLOAD_IN_PROGRESS;
constexpr OsUpdateStatus_UpdateStatus OsUpdateStatus::OS_UPDATE_NEED_REBOOT;
constexpr OsUpdateStatus_UpdateStatus OsUpdateStatus::UpdateStatus_MIN;
constexpr OsUpdateStatus_UpdateStatus OsUpdateStatus::UpdateStatus_MAX;
constexpr int OsUpdateStatus::UpdateStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AppInfo_AppType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AppInfo_AppType_strings[9] = {};

static const char AppInfo_AppType_names[] =
  "TYPE_ARC"
  "TYPE_BOREALIS"
  "TYPE_BRUSCHETTA"
  "TYPE_BUILTIN"
  "TYPE_CROSTINI"
  "TYPE_EXTENSION"
  "TYPE_PLUGINVM"
  "TYPE_UNKNOWN"
  "TYPE_WEB";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AppInfo_AppType_entries[] = {
  { {AppInfo_AppType_names + 0, 8}, 1 },
  { {AppInfo_AppType_names + 8, 13}, 7 },
  { {AppInfo_AppType_names + 21, 15}, 8 },
  { {AppInfo_AppType_names + 36, 12}, 2 },
  { {AppInfo_AppType_names + 48, 13}, 3 },
  { {AppInfo_AppType_names + 61, 14}, 4 },
  { {AppInfo_AppType_names + 75, 13}, 6 },
  { {AppInfo_AppType_names + 88, 12}, 0 },
  { {AppInfo_AppType_names + 100, 8}, 5 },
};

static const int AppInfo_AppType_entries_by_number[] = {
  7, // 0 -> TYPE_UNKNOWN
  0, // 1 -> TYPE_ARC
  3, // 2 -> TYPE_BUILTIN
  4, // 3 -> TYPE_CROSTINI
  5, // 4 -> TYPE_EXTENSION
  8, // 5 -> TYPE_WEB
  6, // 6 -> TYPE_PLUGINVM
  1, // 7 -> TYPE_BOREALIS
  2, // 8 -> TYPE_BRUSCHETTA
};

const std::string& AppInfo_AppType_Name(
    AppInfo_AppType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AppInfo_AppType_entries,
          AppInfo_AppType_entries_by_number,
          9, AppInfo_AppType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AppInfo_AppType_entries,
      AppInfo_AppType_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AppInfo_AppType_strings[idx].get();
}
bool AppInfo_AppType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppInfo_AppType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AppInfo_AppType_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<AppInfo_AppType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AppInfo_AppType AppInfo::TYPE_UNKNOWN;
constexpr AppInfo_AppType AppInfo::TYPE_ARC;
constexpr AppInfo_AppType AppInfo::TYPE_BUILTIN;
constexpr AppInfo_AppType AppInfo::TYPE_CROSTINI;
constexpr AppInfo_AppType AppInfo::TYPE_EXTENSION;
constexpr AppInfo_AppType AppInfo::TYPE_WEB;
constexpr AppInfo_AppType AppInfo::TYPE_PLUGINVM;
constexpr AppInfo_AppType AppInfo::TYPE_BOREALIS;
constexpr AppInfo_AppType AppInfo::TYPE_BRUSCHETTA;
constexpr AppInfo_AppType AppInfo::AppType_MIN;
constexpr AppInfo_AppType AppInfo::AppType_MAX;
constexpr int AppInfo::AppType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AppInfo_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AppInfo_Status_strings[4] = {};

static const char AppInfo_Status_names[] =
  "STATUS_DISABLED"
  "STATUS_INSTALLED"
  "STATUS_UNINSTALLED"
  "STATUS_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AppInfo_Status_entries[] = {
  { {AppInfo_Status_names + 0, 15}, 2 },
  { {AppInfo_Status_names + 15, 16}, 1 },
  { {AppInfo_Status_names + 31, 18}, 3 },
  { {AppInfo_Status_names + 49, 14}, 0 },
};

static const int AppInfo_Status_entries_by_number[] = {
  3, // 0 -> STATUS_UNKNOWN
  1, // 1 -> STATUS_INSTALLED
  0, // 2 -> STATUS_DISABLED
  2, // 3 -> STATUS_UNINSTALLED
};

const std::string& AppInfo_Status_Name(
    AppInfo_Status value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AppInfo_Status_entries,
          AppInfo_Status_entries_by_number,
          4, AppInfo_Status_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AppInfo_Status_entries,
      AppInfo_Status_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AppInfo_Status_strings[idx].get();
}
bool AppInfo_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppInfo_Status* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AppInfo_Status_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<AppInfo_Status>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AppInfo_Status AppInfo::STATUS_UNKNOWN;
constexpr AppInfo_Status AppInfo::STATUS_INSTALLED;
constexpr AppInfo_Status AppInfo::STATUS_DISABLED;
constexpr AppInfo_Status AppInfo::STATUS_UNINSTALLED;
constexpr AppInfo_Status AppInfo::Status_MIN;
constexpr AppInfo_Status AppInfo::Status_MAX;
constexpr int AppInfo::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AndroidAppInfo_AndroidAppStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AndroidAppInfo_AndroidAppStatus_strings[4] = {};

static const char AndroidAppInfo_AndroidAppStatus_names[] =
  "STATUS_DISABLED"
  "STATUS_ENABLED"
  "STATUS_SUSPENDED"
  "STATUS_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AndroidAppInfo_AndroidAppStatus_entries[] = {
  { {AndroidAppInfo_AndroidAppStatus_names + 0, 15}, 3 },
  { {AndroidAppInfo_AndroidAppStatus_names + 15, 14}, 1 },
  { {AndroidAppInfo_AndroidAppStatus_names + 29, 16}, 2 },
  { {AndroidAppInfo_AndroidAppStatus_names + 45, 14}, 0 },
};

static const int AndroidAppInfo_AndroidAppStatus_entries_by_number[] = {
  3, // 0 -> STATUS_UNKNOWN
  1, // 1 -> STATUS_ENABLED
  2, // 2 -> STATUS_SUSPENDED
  0, // 3 -> STATUS_DISABLED
};

const std::string& AndroidAppInfo_AndroidAppStatus_Name(
    AndroidAppInfo_AndroidAppStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AndroidAppInfo_AndroidAppStatus_entries,
          AndroidAppInfo_AndroidAppStatus_entries_by_number,
          4, AndroidAppInfo_AndroidAppStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AndroidAppInfo_AndroidAppStatus_entries,
      AndroidAppInfo_AndroidAppStatus_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AndroidAppInfo_AndroidAppStatus_strings[idx].get();
}
bool AndroidAppInfo_AndroidAppStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AndroidAppInfo_AndroidAppStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AndroidAppInfo_AndroidAppStatus_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<AndroidAppInfo_AndroidAppStatus>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AndroidAppInfo_AndroidAppStatus AndroidAppInfo::STATUS_UNKNOWN;
constexpr AndroidAppInfo_AndroidAppStatus AndroidAppInfo::STATUS_ENABLED;
constexpr AndroidAppInfo_AndroidAppStatus AndroidAppInfo::STATUS_SUSPENDED;
constexpr AndroidAppInfo_AndroidAppStatus AndroidAppInfo::STATUS_DISABLED;
constexpr AndroidAppInfo_AndroidAppStatus AndroidAppInfo::AndroidAppStatus_MIN;
constexpr AndroidAppInfo_AndroidAppStatus AndroidAppInfo::AndroidAppStatus_MAX;
constexpr int AndroidAppInfo::AndroidAppStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AndroidAppInfo_InstalledSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AndroidAppInfo_InstalledSource_strings[4] = {};

static const char AndroidAppInfo_InstalledSource_names[] =
  "SOURCE_BY_ADMIN"
  "SOURCE_BY_USER"
  "SOURCE_NOT_INSTALLED"
  "SOURCE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AndroidAppInfo_InstalledSource_entries[] = {
  { {AndroidAppInfo_InstalledSource_names + 0, 15}, 1 },
  { {AndroidAppInfo_InstalledSource_names + 15, 14}, 2 },
  { {AndroidAppInfo_InstalledSource_names + 29, 20}, 3 },
  { {AndroidAppInfo_InstalledSource_names + 49, 14}, 0 },
};

static const int AndroidAppInfo_InstalledSource_entries_by_number[] = {
  3, // 0 -> SOURCE_UNKNOWN
  0, // 1 -> SOURCE_BY_ADMIN
  1, // 2 -> SOURCE_BY_USER
  2, // 3 -> SOURCE_NOT_INSTALLED
};

const std::string& AndroidAppInfo_InstalledSource_Name(
    AndroidAppInfo_InstalledSource value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AndroidAppInfo_InstalledSource_entries,
          AndroidAppInfo_InstalledSource_entries_by_number,
          4, AndroidAppInfo_InstalledSource_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AndroidAppInfo_InstalledSource_entries,
      AndroidAppInfo_InstalledSource_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AndroidAppInfo_InstalledSource_strings[idx].get();
}
bool AndroidAppInfo_InstalledSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AndroidAppInfo_InstalledSource* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AndroidAppInfo_InstalledSource_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<AndroidAppInfo_InstalledSource>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AndroidAppInfo_InstalledSource AndroidAppInfo::SOURCE_UNKNOWN;
constexpr AndroidAppInfo_InstalledSource AndroidAppInfo::SOURCE_BY_ADMIN;
constexpr AndroidAppInfo_InstalledSource AndroidAppInfo::SOURCE_BY_USER;
constexpr AndroidAppInfo_InstalledSource AndroidAppInfo::SOURCE_NOT_INSTALLED;
constexpr AndroidAppInfo_InstalledSource AndroidAppInfo::InstalledSource_MIN;
constexpr AndroidAppInfo_InstalledSource AndroidAppInfo::InstalledSource_MAX;
constexpr int AndroidAppInfo::InstalledSource_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Extension_ExtensionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Extension_ExtensionType_strings[10] = {};

static const char Extension_ExtensionType_names[] =
  "TYPE_CHROMEOS_SYSTEM_EXTENSION"
  "TYPE_EXTENSION"
  "TYPE_HOSTED_APP"
  "TYPE_LEGACY_PACKAGED_APP"
  "TYPE_LOGIN_SCREEN_EXTENSION"
  "TYPE_PACKAGED_APP"
  "TYPE_PLATFORM_APP"
  "TYPE_THEME"
  "TYPE_UNKNOWN"
  "TYPE_USER_SCRIPT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Extension_ExtensionType_entries[] = {
  { {Extension_ExtensionType_names + 0, 30}, 9 },
  { {Extension_ExtensionType_names + 30, 14}, 1 },
  { {Extension_ExtensionType_names + 44, 15}, 2 },
  { {Extension_ExtensionType_names + 59, 24}, 4 },
  { {Extension_ExtensionType_names + 83, 27}, 8 },
  { {Extension_ExtensionType_names + 110, 17}, 3 },
  { {Extension_ExtensionType_names + 127, 17}, 7 },
  { {Extension_ExtensionType_names + 144, 10}, 5 },
  { {Extension_ExtensionType_names + 154, 12}, 0 },
  { {Extension_ExtensionType_names + 166, 16}, 6 },
};

static const int Extension_ExtensionType_entries_by_number[] = {
  8, // 0 -> TYPE_UNKNOWN
  1, // 1 -> TYPE_EXTENSION
  2, // 2 -> TYPE_HOSTED_APP
  5, // 3 -> TYPE_PACKAGED_APP
  3, // 4 -> TYPE_LEGACY_PACKAGED_APP
  7, // 5 -> TYPE_THEME
  9, // 6 -> TYPE_USER_SCRIPT
  6, // 7 -> TYPE_PLATFORM_APP
  4, // 8 -> TYPE_LOGIN_SCREEN_EXTENSION
  0, // 9 -> TYPE_CHROMEOS_SYSTEM_EXTENSION
};

const std::string& Extension_ExtensionType_Name(
    Extension_ExtensionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Extension_ExtensionType_entries,
          Extension_ExtensionType_entries_by_number,
          10, Extension_ExtensionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Extension_ExtensionType_entries,
      Extension_ExtensionType_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Extension_ExtensionType_strings[idx].get();
}
bool Extension_ExtensionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Extension_ExtensionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Extension_ExtensionType_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<Extension_ExtensionType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Extension_ExtensionType Extension::TYPE_UNKNOWN;
constexpr Extension_ExtensionType Extension::TYPE_EXTENSION;
constexpr Extension_ExtensionType Extension::TYPE_HOSTED_APP;
constexpr Extension_ExtensionType Extension::TYPE_PACKAGED_APP;
constexpr Extension_ExtensionType Extension::TYPE_LEGACY_PACKAGED_APP;
constexpr Extension_ExtensionType Extension::TYPE_THEME;
constexpr Extension_ExtensionType Extension::TYPE_USER_SCRIPT;
constexpr Extension_ExtensionType Extension::TYPE_PLATFORM_APP;
constexpr Extension_ExtensionType Extension::TYPE_LOGIN_SCREEN_EXTENSION;
constexpr Extension_ExtensionType Extension::TYPE_CHROMEOS_SYSTEM_EXTENSION;
constexpr Extension_ExtensionType Extension::ExtensionType_MIN;
constexpr Extension_ExtensionType Extension::ExtensionType_MAX;
constexpr int Extension::ExtensionType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Extension_InstallType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Extension_InstallType_strings[5] = {};

static const char Extension_InstallType_names[] =
  "TYPE_ADMIN"
  "TYPE_DEVELOPMENT"
  "TYPE_NORMAL"
  "TYPE_OTHER"
  "TYPE_SIDELOAD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Extension_InstallType_entries[] = {
  { {Extension_InstallType_names + 0, 10}, 3 },
  { {Extension_InstallType_names + 10, 16}, 1 },
  { {Extension_InstallType_names + 26, 11}, 0 },
  { {Extension_InstallType_names + 37, 10}, 4 },
  { {Extension_InstallType_names + 47, 13}, 2 },
};

static const int Extension_InstallType_entries_by_number[] = {
  2, // 0 -> TYPE_NORMAL
  1, // 1 -> TYPE_DEVELOPMENT
  4, // 2 -> TYPE_SIDELOAD
  0, // 3 -> TYPE_ADMIN
  3, // 4 -> TYPE_OTHER
};

const std::string& Extension_InstallType_Name(
    Extension_InstallType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Extension_InstallType_entries,
          Extension_InstallType_entries_by_number,
          5, Extension_InstallType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Extension_InstallType_entries,
      Extension_InstallType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Extension_InstallType_strings[idx].get();
}
bool Extension_InstallType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Extension_InstallType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Extension_InstallType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<Extension_InstallType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Extension_InstallType Extension::TYPE_NORMAL;
constexpr Extension_InstallType Extension::TYPE_DEVELOPMENT;
constexpr Extension_InstallType Extension::TYPE_SIDELOAD;
constexpr Extension_InstallType Extension::TYPE_ADMIN;
constexpr Extension_InstallType Extension::TYPE_OTHER;
constexpr Extension_InstallType Extension::InstallType_MIN;
constexpr Extension_InstallType Extension::InstallType_MAX;
constexpr int Extension::InstallType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Policy_PolicyLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Policy_PolicyLevel_strings[3] = {};

static const char Policy_PolicyLevel_names[] =
  "LEVEL_MANDATORY"
  "LEVEL_RECOMMENDED"
  "LEVEL_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Policy_PolicyLevel_entries[] = {
  { {Policy_PolicyLevel_names + 0, 15}, 2 },
  { {Policy_PolicyLevel_names + 15, 17}, 1 },
  { {Policy_PolicyLevel_names + 32, 13}, 0 },
};

static const int Policy_PolicyLevel_entries_by_number[] = {
  2, // 0 -> LEVEL_UNKNOWN
  1, // 1 -> LEVEL_RECOMMENDED
  0, // 2 -> LEVEL_MANDATORY
};

const std::string& Policy_PolicyLevel_Name(
    Policy_PolicyLevel value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Policy_PolicyLevel_entries,
          Policy_PolicyLevel_entries_by_number,
          3, Policy_PolicyLevel_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Policy_PolicyLevel_entries,
      Policy_PolicyLevel_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Policy_PolicyLevel_strings[idx].get();
}
bool Policy_PolicyLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Policy_PolicyLevel* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Policy_PolicyLevel_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<Policy_PolicyLevel>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Policy_PolicyLevel Policy::LEVEL_UNKNOWN;
constexpr Policy_PolicyLevel Policy::LEVEL_RECOMMENDED;
constexpr Policy_PolicyLevel Policy::LEVEL_MANDATORY;
constexpr Policy_PolicyLevel Policy::PolicyLevel_MIN;
constexpr Policy_PolicyLevel Policy::PolicyLevel_MAX;
constexpr int Policy::PolicyLevel_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Policy_PolicyScope_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Policy_PolicyScope_strings[3] = {};

static const char Policy_PolicyScope_names[] =
  "SCOPE_MACHINE"
  "SCOPE_UNKNOWN"
  "SCOPE_USER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Policy_PolicyScope_entries[] = {
  { {Policy_PolicyScope_names + 0, 13}, 2 },
  { {Policy_PolicyScope_names + 13, 13}, 0 },
  { {Policy_PolicyScope_names + 26, 10}, 1 },
};

static const int Policy_PolicyScope_entries_by_number[] = {
  1, // 0 -> SCOPE_UNKNOWN
  2, // 1 -> SCOPE_USER
  0, // 2 -> SCOPE_MACHINE
};

const std::string& Policy_PolicyScope_Name(
    Policy_PolicyScope value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Policy_PolicyScope_entries,
          Policy_PolicyScope_entries_by_number,
          3, Policy_PolicyScope_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Policy_PolicyScope_entries,
      Policy_PolicyScope_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Policy_PolicyScope_strings[idx].get();
}
bool Policy_PolicyScope_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Policy_PolicyScope* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Policy_PolicyScope_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<Policy_PolicyScope>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Policy_PolicyScope Policy::SCOPE_UNKNOWN;
constexpr Policy_PolicyScope Policy::SCOPE_USER;
constexpr Policy_PolicyScope Policy::SCOPE_MACHINE;
constexpr Policy_PolicyScope Policy::PolicyScope_MIN;
constexpr Policy_PolicyScope Policy::PolicyScope_MAX;
constexpr int Policy::PolicyScope_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Policy_PolicySource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Policy_PolicySource_strings[11] = {};

static const char Policy_PolicySource_names[] =
  "SOURCE_ACTIVE_DIRECTORY"
  "SOURCE_CLOUD"
  "SOURCE_CLOUD_FROM_ASH"
  "SOURCE_COMMAND_LINE"
  "SOURCE_DEVICE_LOCAL_ACCOUNT_OVERRIDE_DEPRECATED"
  "SOURCE_ENTERPRISE_DEFAULT"
  "SOURCE_MERGED"
  "SOURCE_PLATFORM"
  "SOURCE_PRIORITY_CLOUD_DEPRECATED"
  "SOURCE_RESTRICTED_MANAGED_GUEST_SESSION_OVERRIDE"
  "SOURCE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Policy_PolicySource_entries[] = {
  { {Policy_PolicySource_names + 0, 23}, 3 },
  { {Policy_PolicySource_names + 23, 12}, 2 },
  { {Policy_PolicySource_names + 35, 21}, 9 },
  { {Policy_PolicySource_names + 56, 19}, 8 },
  { {Policy_PolicySource_names + 75, 47}, 4 },
  { {Policy_PolicySource_names + 122, 25}, 1 },
  { {Policy_PolicySource_names + 147, 13}, 7 },
  { {Policy_PolicySource_names + 160, 15}, 5 },
  { {Policy_PolicySource_names + 175, 32}, 6 },
  { {Policy_PolicySource_names + 207, 48}, 10 },
  { {Policy_PolicySource_names + 255, 14}, 0 },
};

static const int Policy_PolicySource_entries_by_number[] = {
  10, // 0 -> SOURCE_UNKNOWN
  5, // 1 -> SOURCE_ENTERPRISE_DEFAULT
  1, // 2 -> SOURCE_CLOUD
  0, // 3 -> SOURCE_ACTIVE_DIRECTORY
  4, // 4 -> SOURCE_DEVICE_LOCAL_ACCOUNT_OVERRIDE_DEPRECATED
  7, // 5 -> SOURCE_PLATFORM
  8, // 6 -> SOURCE_PRIORITY_CLOUD_DEPRECATED
  6, // 7 -> SOURCE_MERGED
  3, // 8 -> SOURCE_COMMAND_LINE
  2, // 9 -> SOURCE_CLOUD_FROM_ASH
  9, // 10 -> SOURCE_RESTRICTED_MANAGED_GUEST_SESSION_OVERRIDE
};

const std::string& Policy_PolicySource_Name(
    Policy_PolicySource value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Policy_PolicySource_entries,
          Policy_PolicySource_entries_by_number,
          11, Policy_PolicySource_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Policy_PolicySource_entries,
      Policy_PolicySource_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Policy_PolicySource_strings[idx].get();
}
bool Policy_PolicySource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Policy_PolicySource* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Policy_PolicySource_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<Policy_PolicySource>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Policy_PolicySource Policy::SOURCE_UNKNOWN;
constexpr Policy_PolicySource Policy::SOURCE_ENTERPRISE_DEFAULT;
constexpr Policy_PolicySource Policy::SOURCE_CLOUD;
constexpr Policy_PolicySource Policy::SOURCE_ACTIVE_DIRECTORY;
constexpr Policy_PolicySource Policy::SOURCE_DEVICE_LOCAL_ACCOUNT_OVERRIDE_DEPRECATED;
constexpr Policy_PolicySource Policy::SOURCE_PLATFORM;
constexpr Policy_PolicySource Policy::SOURCE_PRIORITY_CLOUD_DEPRECATED;
constexpr Policy_PolicySource Policy::SOURCE_MERGED;
constexpr Policy_PolicySource Policy::SOURCE_COMMAND_LINE;
constexpr Policy_PolicySource Policy::SOURCE_CLOUD_FROM_ASH;
constexpr Policy_PolicySource Policy::SOURCE_RESTRICTED_MANAGED_GUEST_SESSION_OVERRIDE;
constexpr Policy_PolicySource Policy::PolicySource_MIN;
constexpr Policy_PolicySource Policy::PolicySource_MAX;
constexpr int Policy::PolicySource_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool OSReport_VersionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OSReport_VersionType_strings[7] = {};

static const char OSReport_VersionType_names[] =
  "EDUCATION"
  "EDUCATION_PRO"
  "ENTERPRISE"
  "HOME"
  "PROFESSIONAL"
  "SERVER"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OSReport_VersionType_entries[] = {
  { {OSReport_VersionType_names + 0, 9}, 5 },
  { {OSReport_VersionType_names + 9, 13}, 6 },
  { {OSReport_VersionType_names + 22, 10}, 4 },
  { {OSReport_VersionType_names + 32, 4}, 1 },
  { {OSReport_VersionType_names + 36, 12}, 2 },
  { {OSReport_VersionType_names + 48, 6}, 3 },
  { {OSReport_VersionType_names + 54, 7}, 0 },
};

static const int OSReport_VersionType_entries_by_number[] = {
  6, // 0 -> UNKNOWN
  3, // 1 -> HOME
  4, // 2 -> PROFESSIONAL
  5, // 3 -> SERVER
  2, // 4 -> ENTERPRISE
  0, // 5 -> EDUCATION
  1, // 6 -> EDUCATION_PRO
};

const std::string& OSReport_VersionType_Name(
    OSReport_VersionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          OSReport_VersionType_entries,
          OSReport_VersionType_entries_by_number,
          7, OSReport_VersionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      OSReport_VersionType_entries,
      OSReport_VersionType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     OSReport_VersionType_strings[idx].get();
}
bool OSReport_VersionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OSReport_VersionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      OSReport_VersionType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<OSReport_VersionType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr OSReport_VersionType OSReport::UNKNOWN;
constexpr OSReport_VersionType OSReport::HOME;
constexpr OSReport_VersionType OSReport::PROFESSIONAL;
constexpr OSReport_VersionType OSReport::SERVER;
constexpr OSReport_VersionType OSReport::ENTERPRISE;
constexpr OSReport_VersionType OSReport::EDUCATION;
constexpr OSReport_VersionType OSReport::EDUCATION_PRO;
constexpr OSReport_VersionType OSReport::VersionType_MIN;
constexpr OSReport_VersionType OSReport::VersionType_MAX;
constexpr int OSReport::VersionType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PolicyValueValidationIssue_ValueValidationIssueSeverity_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PolicyValueValidationIssue_ValueValidationIssueSeverity_strings[3] = {};

static const char PolicyValueValidationIssue_ValueValidationIssueSeverity_names[] =
  "VALUE_VALIDATION_ISSUE_SEVERITY_ERROR"
  "VALUE_VALIDATION_ISSUE_SEVERITY_UNSPECIFIED"
  "VALUE_VALIDATION_ISSUE_SEVERITY_WARNING";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PolicyValueValidationIssue_ValueValidationIssueSeverity_entries[] = {
  { {PolicyValueValidationIssue_ValueValidationIssueSeverity_names + 0, 37}, 2 },
  { {PolicyValueValidationIssue_ValueValidationIssueSeverity_names + 37, 43}, 0 },
  { {PolicyValueValidationIssue_ValueValidationIssueSeverity_names + 80, 39}, 1 },
};

static const int PolicyValueValidationIssue_ValueValidationIssueSeverity_entries_by_number[] = {
  1, // 0 -> VALUE_VALIDATION_ISSUE_SEVERITY_UNSPECIFIED
  2, // 1 -> VALUE_VALIDATION_ISSUE_SEVERITY_WARNING
  0, // 2 -> VALUE_VALIDATION_ISSUE_SEVERITY_ERROR
};

const std::string& PolicyValueValidationIssue_ValueValidationIssueSeverity_Name(
    PolicyValueValidationIssue_ValueValidationIssueSeverity value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PolicyValueValidationIssue_ValueValidationIssueSeverity_entries,
          PolicyValueValidationIssue_ValueValidationIssueSeverity_entries_by_number,
          3, PolicyValueValidationIssue_ValueValidationIssueSeverity_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PolicyValueValidationIssue_ValueValidationIssueSeverity_entries,
      PolicyValueValidationIssue_ValueValidationIssueSeverity_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PolicyValueValidationIssue_ValueValidationIssueSeverity_strings[idx].get();
}
bool PolicyValueValidationIssue_ValueValidationIssueSeverity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolicyValueValidationIssue_ValueValidationIssueSeverity* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PolicyValueValidationIssue_ValueValidationIssueSeverity_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PolicyValueValidationIssue_ValueValidationIssueSeverity>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PolicyValueValidationIssue_ValueValidationIssueSeverity PolicyValueValidationIssue::VALUE_VALIDATION_ISSUE_SEVERITY_UNSPECIFIED;
constexpr PolicyValueValidationIssue_ValueValidationIssueSeverity PolicyValueValidationIssue::VALUE_VALIDATION_ISSUE_SEVERITY_WARNING;
constexpr PolicyValueValidationIssue_ValueValidationIssueSeverity PolicyValueValidationIssue::VALUE_VALIDATION_ISSUE_SEVERITY_ERROR;
constexpr PolicyValueValidationIssue_ValueValidationIssueSeverity PolicyValueValidationIssue::ValueValidationIssueSeverity_MIN;
constexpr PolicyValueValidationIssue_ValueValidationIssueSeverity PolicyValueValidationIssue::ValueValidationIssueSeverity_MAX;
constexpr int PolicyValueValidationIssue::ValueValidationIssueSeverity_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PolicyValidationReportRequest_ValidationResultType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PolicyValidationReportRequest_ValidationResultType_strings[16] = {};

static const char PolicyValidationReportRequest_ValidationResultType_names[] =
  "VALIDATION_RESULT_TYPE_BAD_DEVICE_ID"
  "VALIDATION_RESULT_TYPE_BAD_DM_TOKEN"
  "VALIDATION_RESULT_TYPE_BAD_INITIAL_SIGNATURE"
  "VALIDATION_RESULT_TYPE_BAD_KEY_VERIFICATION_SIGNATURE"
  "VALIDATION_RESULT_TYPE_BAD_SIGNATURE"
  "VALIDATION_RESULT_TYPE_BAD_TIMESTAMP"
  "VALIDATION_RESULT_TYPE_BAD_USER"
  "VALIDATION_RESULT_TYPE_ERROR_CODE_PRESENT"
  "VALIDATION_RESULT_TYPE_ERROR_UNSPECIFIED"
  "VALIDATION_RESULT_TYPE_PAYLOAD_PARSE_ERROR"
  "VALIDATION_RESULT_TYPE_POLICY_PARSE_ERROR"
  "VALIDATION_RESULT_TYPE_SUCCESS"
  "VALIDATION_RESULT_TYPE_VALUE_ERROR"
  "VALIDATION_RESULT_TYPE_VALUE_WARNING"
  "VALIDATION_RESULT_TYPE_WRONG_POLICY_TYPE"
  "VALIDATION_RESULT_TYPE_WRONG_SETTINGS_ENTITY_ID";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PolicyValidationReportRequest_ValidationResultType_entries[] = {
  { {PolicyValidationReportRequest_ValidationResultType_names + 0, 36}, 10 },
  { {PolicyValidationReportRequest_ValidationResultType_names + 36, 35}, 9 },
  { {PolicyValidationReportRequest_ValidationResultType_names + 71, 44}, 2 },
  { {PolicyValidationReportRequest_ValidationResultType_names + 115, 53}, 13 },
  { {PolicyValidationReportRequest_ValidationResultType_names + 168, 36}, 3 },
  { {PolicyValidationReportRequest_ValidationResultType_names + 204, 36}, 8 },
  { {PolicyValidationReportRequest_ValidationResultType_names + 240, 31}, 11 },
  { {PolicyValidationReportRequest_ValidationResultType_names + 271, 41}, 4 },
  { {PolicyValidationReportRequest_ValidationResultType_names + 312, 40}, 0 },
  { {PolicyValidationReportRequest_ValidationResultType_names + 352, 42}, 5 },
  { {PolicyValidationReportRequest_ValidationResultType_names + 394, 41}, 12 },
  { {PolicyValidationReportRequest_ValidationResultType_names + 435, 30}, 1 },
  { {PolicyValidationReportRequest_ValidationResultType_names + 465, 34}, 15 },
  { {PolicyValidationReportRequest_ValidationResultType_names + 499, 36}, 14 },
  { {PolicyValidationReportRequest_ValidationResultType_names + 535, 40}, 6 },
  { {PolicyValidationReportRequest_ValidationResultType_names + 575, 47}, 7 },
};

static const int PolicyValidationReportRequest_ValidationResultType_entries_by_number[] = {
  8, // 0 -> VALIDATION_RESULT_TYPE_ERROR_UNSPECIFIED
  11, // 1 -> VALIDATION_RESULT_TYPE_SUCCESS
  2, // 2 -> VALIDATION_RESULT_TYPE_BAD_INITIAL_SIGNATURE
  4, // 3 -> VALIDATION_RESULT_TYPE_BAD_SIGNATURE
  7, // 4 -> VALIDATION_RESULT_TYPE_ERROR_CODE_PRESENT
  9, // 5 -> VALIDATION_RESULT_TYPE_PAYLOAD_PARSE_ERROR
  14, // 6 -> VALIDATION_RESULT_TYPE_WRONG_POLICY_TYPE
  15, // 7 -> VALIDATION_RESULT_TYPE_WRONG_SETTINGS_ENTITY_ID
  5, // 8 -> VALIDATION_RESULT_TYPE_BAD_TIMESTAMP
  1, // 9 -> VALIDATION_RESULT_TYPE_BAD_DM_TOKEN
  0, // 10 -> VALIDATION_RESULT_TYPE_BAD_DEVICE_ID
  6, // 11 -> VALIDATION_RESULT_TYPE_BAD_USER
  10, // 12 -> VALIDATION_RESULT_TYPE_POLICY_PARSE_ERROR
  3, // 13 -> VALIDATION_RESULT_TYPE_BAD_KEY_VERIFICATION_SIGNATURE
  13, // 14 -> VALIDATION_RESULT_TYPE_VALUE_WARNING
  12, // 15 -> VALIDATION_RESULT_TYPE_VALUE_ERROR
};

const std::string& PolicyValidationReportRequest_ValidationResultType_Name(
    PolicyValidationReportRequest_ValidationResultType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PolicyValidationReportRequest_ValidationResultType_entries,
          PolicyValidationReportRequest_ValidationResultType_entries_by_number,
          16, PolicyValidationReportRequest_ValidationResultType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PolicyValidationReportRequest_ValidationResultType_entries,
      PolicyValidationReportRequest_ValidationResultType_entries_by_number,
      16, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PolicyValidationReportRequest_ValidationResultType_strings[idx].get();
}
bool PolicyValidationReportRequest_ValidationResultType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolicyValidationReportRequest_ValidationResultType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PolicyValidationReportRequest_ValidationResultType_entries, 16, name, &int_value);
  if (success) {
    *value = static_cast<PolicyValidationReportRequest_ValidationResultType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::VALIDATION_RESULT_TYPE_ERROR_UNSPECIFIED;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::VALIDATION_RESULT_TYPE_SUCCESS;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::VALIDATION_RESULT_TYPE_BAD_INITIAL_SIGNATURE;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::VALIDATION_RESULT_TYPE_BAD_SIGNATURE;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::VALIDATION_RESULT_TYPE_ERROR_CODE_PRESENT;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::VALIDATION_RESULT_TYPE_PAYLOAD_PARSE_ERROR;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::VALIDATION_RESULT_TYPE_WRONG_POLICY_TYPE;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::VALIDATION_RESULT_TYPE_WRONG_SETTINGS_ENTITY_ID;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::VALIDATION_RESULT_TYPE_BAD_TIMESTAMP;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::VALIDATION_RESULT_TYPE_BAD_DM_TOKEN;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::VALIDATION_RESULT_TYPE_BAD_DEVICE_ID;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::VALIDATION_RESULT_TYPE_BAD_USER;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::VALIDATION_RESULT_TYPE_POLICY_PARSE_ERROR;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::VALIDATION_RESULT_TYPE_BAD_KEY_VERIFICATION_SIGNATURE;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::VALIDATION_RESULT_TYPE_VALUE_WARNING;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::VALIDATION_RESULT_TYPE_VALUE_ERROR;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::ValidationResultType_MIN;
constexpr PolicyValidationReportRequest_ValidationResultType PolicyValidationReportRequest::ValidationResultType_MAX;
constexpr int PolicyValidationReportRequest::ValidationResultType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceAutoEnrollmentRequest_EnrollmentCheckType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceAutoEnrollmentRequest_EnrollmentCheckType_strings[3] = {};

static const char DeviceAutoEnrollmentRequest_EnrollmentCheckType_names[] =
  "ENROLLMENT_CHECK_TYPE_FORCED_ENROLLMENT"
  "ENROLLMENT_CHECK_TYPE_FRE"
  "ENROLLMENT_CHECK_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceAutoEnrollmentRequest_EnrollmentCheckType_entries[] = {
  { {DeviceAutoEnrollmentRequest_EnrollmentCheckType_names + 0, 39}, 2 },
  { {DeviceAutoEnrollmentRequest_EnrollmentCheckType_names + 39, 25}, 1 },
  { {DeviceAutoEnrollmentRequest_EnrollmentCheckType_names + 64, 33}, 0 },
};

static const int DeviceAutoEnrollmentRequest_EnrollmentCheckType_entries_by_number[] = {
  2, // 0 -> ENROLLMENT_CHECK_TYPE_UNSPECIFIED
  1, // 1 -> ENROLLMENT_CHECK_TYPE_FRE
  0, // 2 -> ENROLLMENT_CHECK_TYPE_FORCED_ENROLLMENT
};

const std::string& DeviceAutoEnrollmentRequest_EnrollmentCheckType_Name(
    DeviceAutoEnrollmentRequest_EnrollmentCheckType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceAutoEnrollmentRequest_EnrollmentCheckType_entries,
          DeviceAutoEnrollmentRequest_EnrollmentCheckType_entries_by_number,
          3, DeviceAutoEnrollmentRequest_EnrollmentCheckType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceAutoEnrollmentRequest_EnrollmentCheckType_entries,
      DeviceAutoEnrollmentRequest_EnrollmentCheckType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceAutoEnrollmentRequest_EnrollmentCheckType_strings[idx].get();
}
bool DeviceAutoEnrollmentRequest_EnrollmentCheckType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceAutoEnrollmentRequest_EnrollmentCheckType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceAutoEnrollmentRequest_EnrollmentCheckType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DeviceAutoEnrollmentRequest_EnrollmentCheckType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceAutoEnrollmentRequest_EnrollmentCheckType DeviceAutoEnrollmentRequest::ENROLLMENT_CHECK_TYPE_UNSPECIFIED;
constexpr DeviceAutoEnrollmentRequest_EnrollmentCheckType DeviceAutoEnrollmentRequest::ENROLLMENT_CHECK_TYPE_FRE;
constexpr DeviceAutoEnrollmentRequest_EnrollmentCheckType DeviceAutoEnrollmentRequest::ENROLLMENT_CHECK_TYPE_FORCED_ENROLLMENT;
constexpr DeviceAutoEnrollmentRequest_EnrollmentCheckType DeviceAutoEnrollmentRequest::EnrollmentCheckType_MIN;
constexpr DeviceAutoEnrollmentRequest_EnrollmentCheckType DeviceAutoEnrollmentRequest::EnrollmentCheckType_MAX;
constexpr int DeviceAutoEnrollmentRequest::EnrollmentCheckType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceStateRetrievalResponse_RestoreMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceStateRetrievalResponse_RestoreMode_strings[5] = {};

static const char DeviceStateRetrievalResponse_RestoreMode_names[] =
  "RESTORE_MODE_DISABLED"
  "RESTORE_MODE_NONE"
  "RESTORE_MODE_REENROLLMENT_ENFORCED"
  "RESTORE_MODE_REENROLLMENT_REQUESTED"
  "RESTORE_MODE_REENROLLMENT_ZERO_TOUCH";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceStateRetrievalResponse_RestoreMode_entries[] = {
  { {DeviceStateRetrievalResponse_RestoreMode_names + 0, 21}, 3 },
  { {DeviceStateRetrievalResponse_RestoreMode_names + 21, 17}, 0 },
  { {DeviceStateRetrievalResponse_RestoreMode_names + 38, 34}, 2 },
  { {DeviceStateRetrievalResponse_RestoreMode_names + 72, 35}, 1 },
  { {DeviceStateRetrievalResponse_RestoreMode_names + 107, 36}, 4 },
};

static const int DeviceStateRetrievalResponse_RestoreMode_entries_by_number[] = {
  1, // 0 -> RESTORE_MODE_NONE
  3, // 1 -> RESTORE_MODE_REENROLLMENT_REQUESTED
  2, // 2 -> RESTORE_MODE_REENROLLMENT_ENFORCED
  0, // 3 -> RESTORE_MODE_DISABLED
  4, // 4 -> RESTORE_MODE_REENROLLMENT_ZERO_TOUCH
};

const std::string& DeviceStateRetrievalResponse_RestoreMode_Name(
    DeviceStateRetrievalResponse_RestoreMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceStateRetrievalResponse_RestoreMode_entries,
          DeviceStateRetrievalResponse_RestoreMode_entries_by_number,
          5, DeviceStateRetrievalResponse_RestoreMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceStateRetrievalResponse_RestoreMode_entries,
      DeviceStateRetrievalResponse_RestoreMode_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceStateRetrievalResponse_RestoreMode_strings[idx].get();
}
bool DeviceStateRetrievalResponse_RestoreMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceStateRetrievalResponse_RestoreMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceStateRetrievalResponse_RestoreMode_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<DeviceStateRetrievalResponse_RestoreMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceStateRetrievalResponse_RestoreMode DeviceStateRetrievalResponse::RESTORE_MODE_NONE;
constexpr DeviceStateRetrievalResponse_RestoreMode DeviceStateRetrievalResponse::RESTORE_MODE_REENROLLMENT_REQUESTED;
constexpr DeviceStateRetrievalResponse_RestoreMode DeviceStateRetrievalResponse::RESTORE_MODE_REENROLLMENT_ENFORCED;
constexpr DeviceStateRetrievalResponse_RestoreMode DeviceStateRetrievalResponse::RESTORE_MODE_DISABLED;
constexpr DeviceStateRetrievalResponse_RestoreMode DeviceStateRetrievalResponse::RESTORE_MODE_REENROLLMENT_ZERO_TOUCH;
constexpr DeviceStateRetrievalResponse_RestoreMode DeviceStateRetrievalResponse::RestoreMode_MIN;
constexpr DeviceStateRetrievalResponse_RestoreMode DeviceStateRetrievalResponse::RestoreMode_MAX;
constexpr int DeviceStateRetrievalResponse::RestoreMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_strings[4] = {};

static const char DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_names[] =
  "INITIAL_ENROLLMENT_MODE_DISABLED"
  "INITIAL_ENROLLMENT_MODE_ENROLLMENT_ENFORCED"
  "INITIAL_ENROLLMENT_MODE_NONE"
  "INITIAL_ENROLLMENT_MODE_ZERO_TOUCH_ENFORCED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_entries[] = {
  { {DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_names + 0, 32}, 3 },
  { {DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_names + 32, 43}, 1 },
  { {DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_names + 75, 28}, 0 },
  { {DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_names + 103, 43}, 2 },
};

static const int DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_entries_by_number[] = {
  2, // 0 -> INITIAL_ENROLLMENT_MODE_NONE
  1, // 1 -> INITIAL_ENROLLMENT_MODE_ENROLLMENT_ENFORCED
  3, // 2 -> INITIAL_ENROLLMENT_MODE_ZERO_TOUCH_ENFORCED
  0, // 3 -> INITIAL_ENROLLMENT_MODE_DISABLED
};

const std::string& DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_Name(
    DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_entries,
          DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_entries_by_number,
          4, DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_entries,
      DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_strings[idx].get();
}
bool DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode DeviceInitialEnrollmentStateResponse::INITIAL_ENROLLMENT_MODE_NONE;
constexpr DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode DeviceInitialEnrollmentStateResponse::INITIAL_ENROLLMENT_MODE_ENROLLMENT_ENFORCED;
constexpr DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode DeviceInitialEnrollmentStateResponse::INITIAL_ENROLLMENT_MODE_ZERO_TOUCH_ENFORCED;
constexpr DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode DeviceInitialEnrollmentStateResponse::INITIAL_ENROLLMENT_MODE_DISABLED;
constexpr DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode DeviceInitialEnrollmentStateResponse::InitialEnrollmentMode_MIN;
constexpr DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode DeviceInitialEnrollmentStateResponse::InitialEnrollmentMode_MAX;
constexpr int DeviceInitialEnrollmentStateResponse::InitialEnrollmentMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_strings[4] = {};

static const char DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_names[] =
  "CHROME_EDUCATION"
  "CHROME_ENTERPRISE"
  "CHROME_TERMINAL"
  "NOT_EXIST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_entries[] = {
  { {DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_names + 0, 16}, 2 },
  { {DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_names + 16, 17}, 1 },
  { {DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_names + 33, 15}, 3 },
  { {DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_names + 48, 9}, 0 },
};

static const int DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_entries_by_number[] = {
  3, // 0 -> NOT_EXIST
  1, // 1 -> CHROME_ENTERPRISE
  0, // 2 -> CHROME_EDUCATION
  2, // 3 -> CHROME_TERMINAL
};

const std::string& DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_Name(
    DeviceInitialEnrollmentStateResponse_LicensePackagingSKU value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_entries,
          DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_entries_by_number,
          4, DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_entries,
      DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_strings[idx].get();
}
bool DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceInitialEnrollmentStateResponse_LicensePackagingSKU* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DeviceInitialEnrollmentStateResponse_LicensePackagingSKU>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceInitialEnrollmentStateResponse_LicensePackagingSKU DeviceInitialEnrollmentStateResponse::NOT_EXIST;
constexpr DeviceInitialEnrollmentStateResponse_LicensePackagingSKU DeviceInitialEnrollmentStateResponse::CHROME_ENTERPRISE;
constexpr DeviceInitialEnrollmentStateResponse_LicensePackagingSKU DeviceInitialEnrollmentStateResponse::CHROME_EDUCATION;
constexpr DeviceInitialEnrollmentStateResponse_LicensePackagingSKU DeviceInitialEnrollmentStateResponse::CHROME_TERMINAL;
constexpr DeviceInitialEnrollmentStateResponse_LicensePackagingSKU DeviceInitialEnrollmentStateResponse::LicensePackagingSKU_MIN;
constexpr DeviceInitialEnrollmentStateResponse_LicensePackagingSKU DeviceInitialEnrollmentStateResponse::LicensePackagingSKU_MAX;
constexpr int DeviceInitialEnrollmentStateResponse::LicensePackagingSKU_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_strings[3] = {};

static const char DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_names[] =
  "ASSIGNED_UPGRADE_TYPE_CHROME_ENTERPRISE"
  "ASSIGNED_UPGRADE_TYPE_KIOSK_AND_SIGNAGE"
  "ASSIGNED_UPGRADE_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_entries[] = {
  { {DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_names + 0, 39}, 1 },
  { {DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_names + 39, 39}, 2 },
  { {DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_names + 78, 33}, 0 },
};

static const int DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_entries_by_number[] = {
  2, // 0 -> ASSIGNED_UPGRADE_TYPE_UNSPECIFIED
  0, // 1 -> ASSIGNED_UPGRADE_TYPE_CHROME_ENTERPRISE
  1, // 2 -> ASSIGNED_UPGRADE_TYPE_KIOSK_AND_SIGNAGE
};

const std::string& DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_Name(
    DeviceInitialEnrollmentStateResponse_AssignedUpgradeType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_entries,
          DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_entries_by_number,
          3, DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_entries,
      DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_strings[idx].get();
}
bool DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceInitialEnrollmentStateResponse_AssignedUpgradeType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DeviceInitialEnrollmentStateResponse_AssignedUpgradeType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceInitialEnrollmentStateResponse_AssignedUpgradeType DeviceInitialEnrollmentStateResponse::ASSIGNED_UPGRADE_TYPE_UNSPECIFIED;
constexpr DeviceInitialEnrollmentStateResponse_AssignedUpgradeType DeviceInitialEnrollmentStateResponse::ASSIGNED_UPGRADE_TYPE_CHROME_ENTERPRISE;
constexpr DeviceInitialEnrollmentStateResponse_AssignedUpgradeType DeviceInitialEnrollmentStateResponse::ASSIGNED_UPGRADE_TYPE_KIOSK_AND_SIGNAGE;
constexpr DeviceInitialEnrollmentStateResponse_AssignedUpgradeType DeviceInitialEnrollmentStateResponse::AssignedUpgradeType_MIN;
constexpr DeviceInitialEnrollmentStateResponse_AssignedUpgradeType DeviceInitialEnrollmentStateResponse::AssignedUpgradeType_MAX;
constexpr int DeviceInitialEnrollmentStateResponse::AssignedUpgradeType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DevicePairingResponse_StatusCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DevicePairingResponse_StatusCode_strings[6] = {};

static const char DevicePairingResponse_StatusCode_names[] =
  "CONTROLLER_DEVICE_DEPROVISIONED"
  "CONTROLLER_DEVICE_NOT_FOUND"
  "FAILED"
  "HOST_DEVICE_DEPROVISIONED"
  "HOST_DEVICE_NOT_FOUND"
  "SUCCESS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DevicePairingResponse_StatusCode_entries[] = {
  { {DevicePairingResponse_StatusCode_names + 0, 31}, 5 },
  { {DevicePairingResponse_StatusCode_names + 31, 27}, 3 },
  { {DevicePairingResponse_StatusCode_names + 58, 6}, 1 },
  { {DevicePairingResponse_StatusCode_names + 64, 25}, 4 },
  { {DevicePairingResponse_StatusCode_names + 89, 21}, 2 },
  { {DevicePairingResponse_StatusCode_names + 110, 7}, 0 },
};

static const int DevicePairingResponse_StatusCode_entries_by_number[] = {
  5, // 0 -> SUCCESS
  2, // 1 -> FAILED
  4, // 2 -> HOST_DEVICE_NOT_FOUND
  1, // 3 -> CONTROLLER_DEVICE_NOT_FOUND
  3, // 4 -> HOST_DEVICE_DEPROVISIONED
  0, // 5 -> CONTROLLER_DEVICE_DEPROVISIONED
};

const std::string& DevicePairingResponse_StatusCode_Name(
    DevicePairingResponse_StatusCode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DevicePairingResponse_StatusCode_entries,
          DevicePairingResponse_StatusCode_entries_by_number,
          6, DevicePairingResponse_StatusCode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DevicePairingResponse_StatusCode_entries,
      DevicePairingResponse_StatusCode_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DevicePairingResponse_StatusCode_strings[idx].get();
}
bool DevicePairingResponse_StatusCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DevicePairingResponse_StatusCode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DevicePairingResponse_StatusCode_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<DevicePairingResponse_StatusCode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DevicePairingResponse_StatusCode DevicePairingResponse::SUCCESS;
constexpr DevicePairingResponse_StatusCode DevicePairingResponse::FAILED;
constexpr DevicePairingResponse_StatusCode DevicePairingResponse::HOST_DEVICE_NOT_FOUND;
constexpr DevicePairingResponse_StatusCode DevicePairingResponse::CONTROLLER_DEVICE_NOT_FOUND;
constexpr DevicePairingResponse_StatusCode DevicePairingResponse::HOST_DEVICE_DEPROVISIONED;
constexpr DevicePairingResponse_StatusCode DevicePairingResponse::CONTROLLER_DEVICE_DEPROVISIONED;
constexpr DevicePairingResponse_StatusCode DevicePairingResponse::StatusCode_MIN;
constexpr DevicePairingResponse_StatusCode DevicePairingResponse::StatusCode_MAX;
constexpr int DevicePairingResponse::StatusCode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CheckDevicePairingResponse_StatusCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CheckDevicePairingResponse_StatusCode_strings[7] = {};

static const char CheckDevicePairingResponse_StatusCode_names[] =
  "CONTROLLER_DEVICE_DEPROVISIONED"
  "CONTROLLER_DEVICE_NOT_FOUND"
  "HOST_DEVICE_DEPROVISIONED"
  "HOST_DEVICE_NOT_FOUND"
  "INVALID_CONTROLLER_DEVICE_IDENTITY"
  "NOT_PAIRED"
  "PAIRED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CheckDevicePairingResponse_StatusCode_entries[] = {
  { {CheckDevicePairingResponse_StatusCode_names + 0, 31}, 5 },
  { {CheckDevicePairingResponse_StatusCode_names + 31, 27}, 3 },
  { {CheckDevicePairingResponse_StatusCode_names + 58, 25}, 4 },
  { {CheckDevicePairingResponse_StatusCode_names + 83, 21}, 2 },
  { {CheckDevicePairingResponse_StatusCode_names + 104, 34}, 6 },
  { {CheckDevicePairingResponse_StatusCode_names + 138, 10}, 1 },
  { {CheckDevicePairingResponse_StatusCode_names + 148, 6}, 0 },
};

static const int CheckDevicePairingResponse_StatusCode_entries_by_number[] = {
  6, // 0 -> PAIRED
  5, // 1 -> NOT_PAIRED
  3, // 2 -> HOST_DEVICE_NOT_FOUND
  1, // 3 -> CONTROLLER_DEVICE_NOT_FOUND
  2, // 4 -> HOST_DEVICE_DEPROVISIONED
  0, // 5 -> CONTROLLER_DEVICE_DEPROVISIONED
  4, // 6 -> INVALID_CONTROLLER_DEVICE_IDENTITY
};

const std::string& CheckDevicePairingResponse_StatusCode_Name(
    CheckDevicePairingResponse_StatusCode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CheckDevicePairingResponse_StatusCode_entries,
          CheckDevicePairingResponse_StatusCode_entries_by_number,
          7, CheckDevicePairingResponse_StatusCode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CheckDevicePairingResponse_StatusCode_entries,
      CheckDevicePairingResponse_StatusCode_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CheckDevicePairingResponse_StatusCode_strings[idx].get();
}
bool CheckDevicePairingResponse_StatusCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CheckDevicePairingResponse_StatusCode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CheckDevicePairingResponse_StatusCode_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<CheckDevicePairingResponse_StatusCode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse::PAIRED;
constexpr CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse::NOT_PAIRED;
constexpr CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse::HOST_DEVICE_NOT_FOUND;
constexpr CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse::CONTROLLER_DEVICE_NOT_FOUND;
constexpr CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse::HOST_DEVICE_DEPROVISIONED;
constexpr CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse::CONTROLLER_DEVICE_DEPROVISIONED;
constexpr CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse::INVALID_CONTROLLER_DEVICE_IDENTITY;
constexpr CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse::StatusCode_MIN;
constexpr CheckDevicePairingResponse_StatusCode CheckDevicePairingResponse::StatusCode_MAX;
constexpr int CheckDevicePairingResponse::StatusCode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool RemoteCommand_Type_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RemoteCommand_Type_strings[18] = {};

static const char RemoteCommand_Type_names[] =
  "BROWSER_CLEAR_BROWSING_DATA"
  "BROWSER_ROTATE_ATTESTATION_CREDENTIAL"
  "COMMAND_ECHO_TEST"
  "DEVICE_FETCH_STATUS"
  "DEVICE_GET_AVAILABLE_DIAGNOSTIC_ROUTINES"
  "DEVICE_GET_DIAGNOSTIC_ROUTINE_UPDATE"
  "DEVICE_REBOOT"
  "DEVICE_REFRESH_ENTERPRISE_MACHINE_CERTIFICATE"
  "DEVICE_REMOTE_POWERWASH"
  "DEVICE_RESET_EUICC"
  "DEVICE_RUN_DIAGNOSTIC_ROUTINE"
  "DEVICE_SCREENSHOT"
  "DEVICE_SET_VOLUME"
  "DEVICE_START_CRD_SESSION"
  "DEVICE_WIPE_USERS"
  "FETCH_CRD_AVAILABILITY_INFO"
  "FETCH_SUPPORT_PACKET"
  "USER_ARC_COMMAND";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RemoteCommand_Type_entries[] = {
  { {RemoteCommand_Type_names + 0, 27}, 12 },
  { {RemoteCommand_Type_names + 27, 37}, 14 },
  { {RemoteCommand_Type_names + 64, 17}, -1 },
  { {RemoteCommand_Type_names + 81, 19}, 3 },
  { {RemoteCommand_Type_names + 100, 40}, 9 },
  { {RemoteCommand_Type_names + 140, 36}, 11 },
  { {RemoteCommand_Type_names + 176, 13}, 0 },
  { {RemoteCommand_Type_names + 189, 45}, 8 },
  { {RemoteCommand_Type_names + 234, 23}, 7 },
  { {RemoteCommand_Type_names + 257, 18}, 13 },
  { {RemoteCommand_Type_names + 275, 29}, 10 },
  { {RemoteCommand_Type_names + 304, 17}, 1 },
  { {RemoteCommand_Type_names + 321, 17}, 2 },
  { {RemoteCommand_Type_names + 338, 24}, 6 },
  { {RemoteCommand_Type_names + 362, 17}, 5 },
  { {RemoteCommand_Type_names + 379, 27}, 15 },
  { {RemoteCommand_Type_names + 406, 20}, 16 },
  { {RemoteCommand_Type_names + 426, 16}, 4 },
};

static const int RemoteCommand_Type_entries_by_number[] = {
  2, // -1 -> COMMAND_ECHO_TEST
  6, // 0 -> DEVICE_REBOOT
  11, // 1 -> DEVICE_SCREENSHOT
  12, // 2 -> DEVICE_SET_VOLUME
  3, // 3 -> DEVICE_FETCH_STATUS
  17, // 4 -> USER_ARC_COMMAND
  14, // 5 -> DEVICE_WIPE_USERS
  13, // 6 -> DEVICE_START_CRD_SESSION
  8, // 7 -> DEVICE_REMOTE_POWERWASH
  7, // 8 -> DEVICE_REFRESH_ENTERPRISE_MACHINE_CERTIFICATE
  4, // 9 -> DEVICE_GET_AVAILABLE_DIAGNOSTIC_ROUTINES
  10, // 10 -> DEVICE_RUN_DIAGNOSTIC_ROUTINE
  5, // 11 -> DEVICE_GET_DIAGNOSTIC_ROUTINE_UPDATE
  0, // 12 -> BROWSER_CLEAR_BROWSING_DATA
  9, // 13 -> DEVICE_RESET_EUICC
  1, // 14 -> BROWSER_ROTATE_ATTESTATION_CREDENTIAL
  15, // 15 -> FETCH_CRD_AVAILABILITY_INFO
  16, // 16 -> FETCH_SUPPORT_PACKET
};

const std::string& RemoteCommand_Type_Name(
    RemoteCommand_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RemoteCommand_Type_entries,
          RemoteCommand_Type_entries_by_number,
          18, RemoteCommand_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RemoteCommand_Type_entries,
      RemoteCommand_Type_entries_by_number,
      18, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RemoteCommand_Type_strings[idx].get();
}
bool RemoteCommand_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RemoteCommand_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RemoteCommand_Type_entries, 18, name, &int_value);
  if (success) {
    *value = static_cast<RemoteCommand_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RemoteCommand_Type RemoteCommand::COMMAND_ECHO_TEST;
constexpr RemoteCommand_Type RemoteCommand::DEVICE_REBOOT;
constexpr RemoteCommand_Type RemoteCommand::DEVICE_SCREENSHOT;
constexpr RemoteCommand_Type RemoteCommand::DEVICE_SET_VOLUME;
constexpr RemoteCommand_Type RemoteCommand::DEVICE_FETCH_STATUS;
constexpr RemoteCommand_Type RemoteCommand::USER_ARC_COMMAND;
constexpr RemoteCommand_Type RemoteCommand::DEVICE_WIPE_USERS;
constexpr RemoteCommand_Type RemoteCommand::DEVICE_START_CRD_SESSION;
constexpr RemoteCommand_Type RemoteCommand::DEVICE_REMOTE_POWERWASH;
constexpr RemoteCommand_Type RemoteCommand::DEVICE_REFRESH_ENTERPRISE_MACHINE_CERTIFICATE;
constexpr RemoteCommand_Type RemoteCommand::DEVICE_GET_AVAILABLE_DIAGNOSTIC_ROUTINES;
constexpr RemoteCommand_Type RemoteCommand::DEVICE_RUN_DIAGNOSTIC_ROUTINE;
constexpr RemoteCommand_Type RemoteCommand::DEVICE_GET_DIAGNOSTIC_ROUTINE_UPDATE;
constexpr RemoteCommand_Type RemoteCommand::BROWSER_CLEAR_BROWSING_DATA;
constexpr RemoteCommand_Type RemoteCommand::DEVICE_RESET_EUICC;
constexpr RemoteCommand_Type RemoteCommand::BROWSER_ROTATE_ATTESTATION_CREDENTIAL;
constexpr RemoteCommand_Type RemoteCommand::FETCH_CRD_AVAILABILITY_INFO;
constexpr RemoteCommand_Type RemoteCommand::FETCH_SUPPORT_PACKET;
constexpr RemoteCommand_Type RemoteCommand::Type_MIN;
constexpr RemoteCommand_Type RemoteCommand::Type_MAX;
constexpr int RemoteCommand::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool RemoteCommandResult_ResultType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RemoteCommandResult_ResultType_strings[3] = {};

static const char RemoteCommandResult_ResultType_names[] =
  "RESULT_FAILURE"
  "RESULT_IGNORED"
  "RESULT_SUCCESS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RemoteCommandResult_ResultType_entries[] = {
  { {RemoteCommandResult_ResultType_names + 0, 14}, 1 },
  { {RemoteCommandResult_ResultType_names + 14, 14}, 0 },
  { {RemoteCommandResult_ResultType_names + 28, 14}, 2 },
};

static const int RemoteCommandResult_ResultType_entries_by_number[] = {
  1, // 0 -> RESULT_IGNORED
  0, // 1 -> RESULT_FAILURE
  2, // 2 -> RESULT_SUCCESS
};

const std::string& RemoteCommandResult_ResultType_Name(
    RemoteCommandResult_ResultType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RemoteCommandResult_ResultType_entries,
          RemoteCommandResult_ResultType_entries_by_number,
          3, RemoteCommandResult_ResultType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RemoteCommandResult_ResultType_entries,
      RemoteCommandResult_ResultType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RemoteCommandResult_ResultType_strings[idx].get();
}
bool RemoteCommandResult_ResultType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RemoteCommandResult_ResultType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RemoteCommandResult_ResultType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<RemoteCommandResult_ResultType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RemoteCommandResult_ResultType RemoteCommandResult::RESULT_IGNORED;
constexpr RemoteCommandResult_ResultType RemoteCommandResult::RESULT_FAILURE;
constexpr RemoteCommandResult_ResultType RemoteCommandResult::RESULT_SUCCESS;
constexpr RemoteCommandResult_ResultType RemoteCommandResult::ResultType_MIN;
constexpr RemoteCommandResult_ResultType RemoteCommandResult::ResultType_MAX;
constexpr int RemoteCommandResult::ResultType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceAttributeUpdatePermissionResponse_ResultType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceAttributeUpdatePermissionResponse_ResultType_strings[2] = {};

static const char DeviceAttributeUpdatePermissionResponse_ResultType_names[] =
  "ATTRIBUTE_UPDATE_ALLOWED"
  "ATTRIBUTE_UPDATE_DISALLOWED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceAttributeUpdatePermissionResponse_ResultType_entries[] = {
  { {DeviceAttributeUpdatePermissionResponse_ResultType_names + 0, 24}, 1 },
  { {DeviceAttributeUpdatePermissionResponse_ResultType_names + 24, 27}, 0 },
};

static const int DeviceAttributeUpdatePermissionResponse_ResultType_entries_by_number[] = {
  1, // 0 -> ATTRIBUTE_UPDATE_DISALLOWED
  0, // 1 -> ATTRIBUTE_UPDATE_ALLOWED
};

const std::string& DeviceAttributeUpdatePermissionResponse_ResultType_Name(
    DeviceAttributeUpdatePermissionResponse_ResultType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceAttributeUpdatePermissionResponse_ResultType_entries,
          DeviceAttributeUpdatePermissionResponse_ResultType_entries_by_number,
          2, DeviceAttributeUpdatePermissionResponse_ResultType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceAttributeUpdatePermissionResponse_ResultType_entries,
      DeviceAttributeUpdatePermissionResponse_ResultType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceAttributeUpdatePermissionResponse_ResultType_strings[idx].get();
}
bool DeviceAttributeUpdatePermissionResponse_ResultType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceAttributeUpdatePermissionResponse_ResultType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceAttributeUpdatePermissionResponse_ResultType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<DeviceAttributeUpdatePermissionResponse_ResultType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceAttributeUpdatePermissionResponse_ResultType DeviceAttributeUpdatePermissionResponse::ATTRIBUTE_UPDATE_DISALLOWED;
constexpr DeviceAttributeUpdatePermissionResponse_ResultType DeviceAttributeUpdatePermissionResponse::ATTRIBUTE_UPDATE_ALLOWED;
constexpr DeviceAttributeUpdatePermissionResponse_ResultType DeviceAttributeUpdatePermissionResponse::ResultType_MIN;
constexpr DeviceAttributeUpdatePermissionResponse_ResultType DeviceAttributeUpdatePermissionResponse::ResultType_MAX;
constexpr int DeviceAttributeUpdatePermissionResponse::ResultType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DeviceAttributeUpdateResponse_ResultType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceAttributeUpdateResponse_ResultType_strings[2] = {};

static const char DeviceAttributeUpdateResponse_ResultType_names[] =
  "ATTRIBUTE_UPDATE_ERROR"
  "ATTRIBUTE_UPDATE_SUCCESS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceAttributeUpdateResponse_ResultType_entries[] = {
  { {DeviceAttributeUpdateResponse_ResultType_names + 0, 22}, 0 },
  { {DeviceAttributeUpdateResponse_ResultType_names + 22, 24}, 1 },
};

static const int DeviceAttributeUpdateResponse_ResultType_entries_by_number[] = {
  0, // 0 -> ATTRIBUTE_UPDATE_ERROR
  1, // 1 -> ATTRIBUTE_UPDATE_SUCCESS
};

const std::string& DeviceAttributeUpdateResponse_ResultType_Name(
    DeviceAttributeUpdateResponse_ResultType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceAttributeUpdateResponse_ResultType_entries,
          DeviceAttributeUpdateResponse_ResultType_entries_by_number,
          2, DeviceAttributeUpdateResponse_ResultType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceAttributeUpdateResponse_ResultType_entries,
      DeviceAttributeUpdateResponse_ResultType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceAttributeUpdateResponse_ResultType_strings[idx].get();
}
bool DeviceAttributeUpdateResponse_ResultType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceAttributeUpdateResponse_ResultType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceAttributeUpdateResponse_ResultType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<DeviceAttributeUpdateResponse_ResultType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DeviceAttributeUpdateResponse_ResultType DeviceAttributeUpdateResponse::ATTRIBUTE_UPDATE_ERROR;
constexpr DeviceAttributeUpdateResponse_ResultType DeviceAttributeUpdateResponse::ATTRIBUTE_UPDATE_SUCCESS;
constexpr DeviceAttributeUpdateResponse_ResultType DeviceAttributeUpdateResponse::ResultType_MIN;
constexpr DeviceAttributeUpdateResponse_ResultType DeviceAttributeUpdateResponse::ResultType_MAX;
constexpr int DeviceAttributeUpdateResponse::ResultType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CertificateBasedDeviceRegistrationData_CertificateType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CertificateBasedDeviceRegistrationData_CertificateType_strings[2] = {};

static const char CertificateBasedDeviceRegistrationData_CertificateType_names[] =
  "ENTERPRISE_ENROLLMENT_CERTIFICATE"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CertificateBasedDeviceRegistrationData_CertificateType_entries[] = {
  { {CertificateBasedDeviceRegistrationData_CertificateType_names + 0, 33}, 1 },
  { {CertificateBasedDeviceRegistrationData_CertificateType_names + 33, 7}, 0 },
};

static const int CertificateBasedDeviceRegistrationData_CertificateType_entries_by_number[] = {
  1, // 0 -> UNKNOWN
  0, // 1 -> ENTERPRISE_ENROLLMENT_CERTIFICATE
};

const std::string& CertificateBasedDeviceRegistrationData_CertificateType_Name(
    CertificateBasedDeviceRegistrationData_CertificateType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CertificateBasedDeviceRegistrationData_CertificateType_entries,
          CertificateBasedDeviceRegistrationData_CertificateType_entries_by_number,
          2, CertificateBasedDeviceRegistrationData_CertificateType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CertificateBasedDeviceRegistrationData_CertificateType_entries,
      CertificateBasedDeviceRegistrationData_CertificateType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CertificateBasedDeviceRegistrationData_CertificateType_strings[idx].get();
}
bool CertificateBasedDeviceRegistrationData_CertificateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CertificateBasedDeviceRegistrationData_CertificateType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CertificateBasedDeviceRegistrationData_CertificateType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<CertificateBasedDeviceRegistrationData_CertificateType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CertificateBasedDeviceRegistrationData_CertificateType CertificateBasedDeviceRegistrationData::UNKNOWN;
constexpr CertificateBasedDeviceRegistrationData_CertificateType CertificateBasedDeviceRegistrationData::ENTERPRISE_ENROLLMENT_CERTIFICATE;
constexpr CertificateBasedDeviceRegistrationData_CertificateType CertificateBasedDeviceRegistrationData::CertificateType_MIN;
constexpr CertificateBasedDeviceRegistrationData_CertificateType CertificateBasedDeviceRegistrationData::CertificateType_MAX;
constexpr int CertificateBasedDeviceRegistrationData::CertificateType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CheckDeviceLicenseResponse_LicenseSelectionMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CheckDeviceLicenseResponse_LicenseSelectionMode_strings[3] = {};

static const char CheckDeviceLicenseResponse_LicenseSelectionMode_names[] =
  "ADMIN_SELECTION"
  "UNDEFINED"
  "USER_SELECTION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CheckDeviceLicenseResponse_LicenseSelectionMode_entries[] = {
  { {CheckDeviceLicenseResponse_LicenseSelectionMode_names + 0, 15}, 2 },
  { {CheckDeviceLicenseResponse_LicenseSelectionMode_names + 15, 9}, 0 },
  { {CheckDeviceLicenseResponse_LicenseSelectionMode_names + 24, 14}, 1 },
};

static const int CheckDeviceLicenseResponse_LicenseSelectionMode_entries_by_number[] = {
  1, // 0 -> UNDEFINED
  2, // 1 -> USER_SELECTION
  0, // 2 -> ADMIN_SELECTION
};

const std::string& CheckDeviceLicenseResponse_LicenseSelectionMode_Name(
    CheckDeviceLicenseResponse_LicenseSelectionMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CheckDeviceLicenseResponse_LicenseSelectionMode_entries,
          CheckDeviceLicenseResponse_LicenseSelectionMode_entries_by_number,
          3, CheckDeviceLicenseResponse_LicenseSelectionMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CheckDeviceLicenseResponse_LicenseSelectionMode_entries,
      CheckDeviceLicenseResponse_LicenseSelectionMode_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CheckDeviceLicenseResponse_LicenseSelectionMode_strings[idx].get();
}
bool CheckDeviceLicenseResponse_LicenseSelectionMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CheckDeviceLicenseResponse_LicenseSelectionMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CheckDeviceLicenseResponse_LicenseSelectionMode_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CheckDeviceLicenseResponse_LicenseSelectionMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CheckDeviceLicenseResponse_LicenseSelectionMode CheckDeviceLicenseResponse::UNDEFINED;
constexpr CheckDeviceLicenseResponse_LicenseSelectionMode CheckDeviceLicenseResponse::USER_SELECTION;
constexpr CheckDeviceLicenseResponse_LicenseSelectionMode CheckDeviceLicenseResponse::ADMIN_SELECTION;
constexpr CheckDeviceLicenseResponse_LicenseSelectionMode CheckDeviceLicenseResponse::LicenseSelectionMode_MIN;
constexpr CheckDeviceLicenseResponse_LicenseSelectionMode CheckDeviceLicenseResponse::LicenseSelectionMode_MAX;
constexpr int CheckDeviceLicenseResponse::LicenseSelectionMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TpmVersionInfo_GscVersion_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TpmVersionInfo_GscVersion_strings[4] = {};

static const char TpmVersionInfo_GscVersion_names[] =
  "GSC_VERSION_CR50"
  "GSC_VERSION_NOT_GSC"
  "GSC_VERSION_TI50"
  "GSC_VERSION_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TpmVersionInfo_GscVersion_entries[] = {
  { {TpmVersionInfo_GscVersion_names + 0, 16}, 2 },
  { {TpmVersionInfo_GscVersion_names + 16, 19}, 1 },
  { {TpmVersionInfo_GscVersion_names + 35, 16}, 3 },
  { {TpmVersionInfo_GscVersion_names + 51, 23}, 0 },
};

static const int TpmVersionInfo_GscVersion_entries_by_number[] = {
  3, // 0 -> GSC_VERSION_UNSPECIFIED
  1, // 1 -> GSC_VERSION_NOT_GSC
  0, // 2 -> GSC_VERSION_CR50
  2, // 3 -> GSC_VERSION_TI50
};

const std::string& TpmVersionInfo_GscVersion_Name(
    TpmVersionInfo_GscVersion value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TpmVersionInfo_GscVersion_entries,
          TpmVersionInfo_GscVersion_entries_by_number,
          4, TpmVersionInfo_GscVersion_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TpmVersionInfo_GscVersion_entries,
      TpmVersionInfo_GscVersion_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TpmVersionInfo_GscVersion_strings[idx].get();
}
bool TpmVersionInfo_GscVersion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TpmVersionInfo_GscVersion* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TpmVersionInfo_GscVersion_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TpmVersionInfo_GscVersion>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TpmVersionInfo_GscVersion TpmVersionInfo::GSC_VERSION_UNSPECIFIED;
constexpr TpmVersionInfo_GscVersion TpmVersionInfo::GSC_VERSION_NOT_GSC;
constexpr TpmVersionInfo_GscVersion TpmVersionInfo::GSC_VERSION_CR50;
constexpr TpmVersionInfo_GscVersion TpmVersionInfo::GSC_VERSION_TI50;
constexpr TpmVersionInfo_GscVersion TpmVersionInfo::GscVersion_MIN;
constexpr TpmVersionInfo_GscVersion TpmVersionInfo::GscVersion_MAX;
constexpr int TpmVersionInfo::GscVersion_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionInstallReportLogEvent_EventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtensionInstallReportLogEvent_EventType_strings[7] = {};

static const char ExtensionInstallReportLogEvent_EventType_names[] =
  "CANCELED"
  "CONNECTIVITY_CHANGE"
  "INSTALLATION_FAILED"
  "LOG_EVENT_TYPE_UNKNOWN"
  "POLICY_REQUEST"
  "SESSION_STATE_CHANGE"
  "SUCCESS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionInstallReportLogEvent_EventType_entries[] = {
  { {ExtensionInstallReportLogEvent_EventType_names + 0, 8}, 3 },
  { {ExtensionInstallReportLogEvent_EventType_names + 8, 19}, 4 },
  { {ExtensionInstallReportLogEvent_EventType_names + 27, 19}, 6 },
  { {ExtensionInstallReportLogEvent_EventType_names + 46, 22}, 0 },
  { {ExtensionInstallReportLogEvent_EventType_names + 68, 14}, 1 },
  { {ExtensionInstallReportLogEvent_EventType_names + 82, 20}, 5 },
  { {ExtensionInstallReportLogEvent_EventType_names + 102, 7}, 2 },
};

static const int ExtensionInstallReportLogEvent_EventType_entries_by_number[] = {
  3, // 0 -> LOG_EVENT_TYPE_UNKNOWN
  4, // 1 -> POLICY_REQUEST
  6, // 2 -> SUCCESS
  0, // 3 -> CANCELED
  1, // 4 -> CONNECTIVITY_CHANGE
  5, // 5 -> SESSION_STATE_CHANGE
  2, // 6 -> INSTALLATION_FAILED
};

const std::string& ExtensionInstallReportLogEvent_EventType_Name(
    ExtensionInstallReportLogEvent_EventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ExtensionInstallReportLogEvent_EventType_entries,
          ExtensionInstallReportLogEvent_EventType_entries_by_number,
          7, ExtensionInstallReportLogEvent_EventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ExtensionInstallReportLogEvent_EventType_entries,
      ExtensionInstallReportLogEvent_EventType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ExtensionInstallReportLogEvent_EventType_strings[idx].get();
}
bool ExtensionInstallReportLogEvent_EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_EventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ExtensionInstallReportLogEvent_EventType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<ExtensionInstallReportLogEvent_EventType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionInstallReportLogEvent_EventType ExtensionInstallReportLogEvent::LOG_EVENT_TYPE_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_EventType ExtensionInstallReportLogEvent::POLICY_REQUEST;
constexpr ExtensionInstallReportLogEvent_EventType ExtensionInstallReportLogEvent::SUCCESS;
constexpr ExtensionInstallReportLogEvent_EventType ExtensionInstallReportLogEvent::CANCELED;
constexpr ExtensionInstallReportLogEvent_EventType ExtensionInstallReportLogEvent::CONNECTIVITY_CHANGE;
constexpr ExtensionInstallReportLogEvent_EventType ExtensionInstallReportLogEvent::SESSION_STATE_CHANGE;
constexpr ExtensionInstallReportLogEvent_EventType ExtensionInstallReportLogEvent::INSTALLATION_FAILED;
constexpr ExtensionInstallReportLogEvent_EventType ExtensionInstallReportLogEvent::EventType_MIN;
constexpr ExtensionInstallReportLogEvent_EventType ExtensionInstallReportLogEvent::EventType_MAX;
constexpr int ExtensionInstallReportLogEvent::EventType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionInstallReportLogEvent_SessionStateChangeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtensionInstallReportLogEvent_SessionStateChangeType_strings[5] = {};

static const char ExtensionInstallReportLogEvent_SessionStateChangeType_names[] =
  "LOGIN"
  "LOGOUT"
  "RESUME"
  "SESSION_STATE_CHANGE_TYPE_UNKNOWN"
  "SUSPEND";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionInstallReportLogEvent_SessionStateChangeType_entries[] = {
  { {ExtensionInstallReportLogEvent_SessionStateChangeType_names + 0, 5}, 1 },
  { {ExtensionInstallReportLogEvent_SessionStateChangeType_names + 5, 6}, 2 },
  { {ExtensionInstallReportLogEvent_SessionStateChangeType_names + 11, 6}, 4 },
  { {ExtensionInstallReportLogEvent_SessionStateChangeType_names + 17, 33}, 0 },
  { {ExtensionInstallReportLogEvent_SessionStateChangeType_names + 50, 7}, 3 },
};

static const int ExtensionInstallReportLogEvent_SessionStateChangeType_entries_by_number[] = {
  3, // 0 -> SESSION_STATE_CHANGE_TYPE_UNKNOWN
  0, // 1 -> LOGIN
  1, // 2 -> LOGOUT
  4, // 3 -> SUSPEND
  2, // 4 -> RESUME
};

const std::string& ExtensionInstallReportLogEvent_SessionStateChangeType_Name(
    ExtensionInstallReportLogEvent_SessionStateChangeType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ExtensionInstallReportLogEvent_SessionStateChangeType_entries,
          ExtensionInstallReportLogEvent_SessionStateChangeType_entries_by_number,
          5, ExtensionInstallReportLogEvent_SessionStateChangeType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ExtensionInstallReportLogEvent_SessionStateChangeType_entries,
      ExtensionInstallReportLogEvent_SessionStateChangeType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ExtensionInstallReportLogEvent_SessionStateChangeType_strings[idx].get();
}
bool ExtensionInstallReportLogEvent_SessionStateChangeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_SessionStateChangeType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ExtensionInstallReportLogEvent_SessionStateChangeType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ExtensionInstallReportLogEvent_SessionStateChangeType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionInstallReportLogEvent_SessionStateChangeType ExtensionInstallReportLogEvent::SESSION_STATE_CHANGE_TYPE_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_SessionStateChangeType ExtensionInstallReportLogEvent::LOGIN;
constexpr ExtensionInstallReportLogEvent_SessionStateChangeType ExtensionInstallReportLogEvent::LOGOUT;
constexpr ExtensionInstallReportLogEvent_SessionStateChangeType ExtensionInstallReportLogEvent::SUSPEND;
constexpr ExtensionInstallReportLogEvent_SessionStateChangeType ExtensionInstallReportLogEvent::RESUME;
constexpr ExtensionInstallReportLogEvent_SessionStateChangeType ExtensionInstallReportLogEvent::SessionStateChangeType_MIN;
constexpr ExtensionInstallReportLogEvent_SessionStateChangeType ExtensionInstallReportLogEvent::SessionStateChangeType_MAX;
constexpr int ExtensionInstallReportLogEvent::SessionStateChangeType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionInstallReportLogEvent_FailureReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtensionInstallReportLogEvent_FailureReason_strings[29] = {};

static const char ExtensionInstallReportLogEvent_FailureReason_names[] =
  "ALREADY_INSTALLED"
  "CRX_FETCH_FAILED"
  "CRX_FETCH_URL_EMPTY"
  "CRX_FETCH_URL_INVALID"
  "CRX_INSTALL_ERROR_DECLINED"
  "CRX_INSTALL_ERROR_OTHER"
  "CRX_INSTALL_ERROR_SANDBOXED_UNPACKER_FAILURE"
  "DOWNLOADER_ADD_FAILED"
  "DO_NOT_INSTALL_FOR_ENTERPRISE"
  "FAILURE_REASON_UNKNOWN"
  "INVALID_ID"
  "IN_PROGRESS"
  "LOCALE_NOT_SUPPORTED"
  "MALFORMED_EXTENSION_DICT"
  "MALFORMED_EXTENSION_DICT_FILE_PATH"
  "MALFORMED_EXTENSION_DICT_UPDATE_URL"
  "MALFORMED_EXTENSION_DICT_VERSION"
  "MALFORMED_EXTENSION_SETTINGS"
  "MANIFEST_FETCH_FAILED"
  "MANIFEST_INVALID"
  "NOT_PERFORMING_NEW_INSTALL"
  "NOT_SUPPORTED_EXTENSION_DICT"
  "NO_UPDATE"
  "NO_UPDATE_URL"
  "OVERRIDDEN_BY_SETTINGS"
  "PENDING_ADD_FAILED"
  "REPLACED_BY_ARC_APP"
  "REPLACED_BY_SYSTEM_APP"
  "TOO_OLD_PROFILE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionInstallReportLogEvent_FailureReason_entries[] = {
  { {ExtensionInstallReportLogEvent_FailureReason_names + 0, 17}, 13 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 17, 16}, 14 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 33, 19}, 25 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 52, 21}, 26 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 73, 26}, 18 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 99, 23}, 20 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 122, 44}, 19 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 166, 21}, 23 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 187, 29}, 12 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 216, 22}, 0 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 238, 10}, 1 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 248, 11}, 24 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 259, 20}, 9 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 279, 24}, 4 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 303, 34}, 6 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 337, 35}, 8 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 372, 32}, 7 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 404, 28}, 2 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 432, 21}, 15 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 453, 16}, 16 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 469, 26}, 10 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 495, 28}, 5 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 523, 9}, 17 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 532, 13}, 21 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 545, 22}, 27 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 567, 18}, 22 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 585, 19}, 3 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 604, 22}, 28 },
  { {ExtensionInstallReportLogEvent_FailureReason_names + 626, 15}, 11 },
};

static const int ExtensionInstallReportLogEvent_FailureReason_entries_by_number[] = {
  9, // 0 -> FAILURE_REASON_UNKNOWN
  10, // 1 -> INVALID_ID
  17, // 2 -> MALFORMED_EXTENSION_SETTINGS
  26, // 3 -> REPLACED_BY_ARC_APP
  13, // 4 -> MALFORMED_EXTENSION_DICT
  21, // 5 -> NOT_SUPPORTED_EXTENSION_DICT
  14, // 6 -> MALFORMED_EXTENSION_DICT_FILE_PATH
  16, // 7 -> MALFORMED_EXTENSION_DICT_VERSION
  15, // 8 -> MALFORMED_EXTENSION_DICT_UPDATE_URL
  12, // 9 -> LOCALE_NOT_SUPPORTED
  20, // 10 -> NOT_PERFORMING_NEW_INSTALL
  28, // 11 -> TOO_OLD_PROFILE
  8, // 12 -> DO_NOT_INSTALL_FOR_ENTERPRISE
  0, // 13 -> ALREADY_INSTALLED
  1, // 14 -> CRX_FETCH_FAILED
  18, // 15 -> MANIFEST_FETCH_FAILED
  19, // 16 -> MANIFEST_INVALID
  22, // 17 -> NO_UPDATE
  4, // 18 -> CRX_INSTALL_ERROR_DECLINED
  6, // 19 -> CRX_INSTALL_ERROR_SANDBOXED_UNPACKER_FAILURE
  5, // 20 -> CRX_INSTALL_ERROR_OTHER
  23, // 21 -> NO_UPDATE_URL
  25, // 22 -> PENDING_ADD_FAILED
  7, // 23 -> DOWNLOADER_ADD_FAILED
  11, // 24 -> IN_PROGRESS
  2, // 25 -> CRX_FETCH_URL_EMPTY
  3, // 26 -> CRX_FETCH_URL_INVALID
  24, // 27 -> OVERRIDDEN_BY_SETTINGS
  27, // 28 -> REPLACED_BY_SYSTEM_APP
};

const std::string& ExtensionInstallReportLogEvent_FailureReason_Name(
    ExtensionInstallReportLogEvent_FailureReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ExtensionInstallReportLogEvent_FailureReason_entries,
          ExtensionInstallReportLogEvent_FailureReason_entries_by_number,
          29, ExtensionInstallReportLogEvent_FailureReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ExtensionInstallReportLogEvent_FailureReason_entries,
      ExtensionInstallReportLogEvent_FailureReason_entries_by_number,
      29, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ExtensionInstallReportLogEvent_FailureReason_strings[idx].get();
}
bool ExtensionInstallReportLogEvent_FailureReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_FailureReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ExtensionInstallReportLogEvent_FailureReason_entries, 29, name, &int_value);
  if (success) {
    *value = static_cast<ExtensionInstallReportLogEvent_FailureReason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::FAILURE_REASON_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::INVALID_ID;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::MALFORMED_EXTENSION_SETTINGS;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::REPLACED_BY_ARC_APP;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::MALFORMED_EXTENSION_DICT;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::NOT_SUPPORTED_EXTENSION_DICT;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::MALFORMED_EXTENSION_DICT_FILE_PATH;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::MALFORMED_EXTENSION_DICT_VERSION;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::MALFORMED_EXTENSION_DICT_UPDATE_URL;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::LOCALE_NOT_SUPPORTED;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::NOT_PERFORMING_NEW_INSTALL;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::TOO_OLD_PROFILE;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::DO_NOT_INSTALL_FOR_ENTERPRISE;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::ALREADY_INSTALLED;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::CRX_FETCH_FAILED;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::MANIFEST_FETCH_FAILED;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::MANIFEST_INVALID;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::NO_UPDATE;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::CRX_INSTALL_ERROR_DECLINED;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::CRX_INSTALL_ERROR_SANDBOXED_UNPACKER_FAILURE;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::CRX_INSTALL_ERROR_OTHER;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::NO_UPDATE_URL;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::PENDING_ADD_FAILED;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::DOWNLOADER_ADD_FAILED;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::IN_PROGRESS;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::CRX_FETCH_URL_EMPTY;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::CRX_FETCH_URL_INVALID;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::OVERRIDDEN_BY_SETTINGS;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::REPLACED_BY_SYSTEM_APP;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::FailureReason_MIN;
constexpr ExtensionInstallReportLogEvent_FailureReason ExtensionInstallReportLogEvent::FailureReason_MAX;
constexpr int ExtensionInstallReportLogEvent::FailureReason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionInstallReportLogEvent_InstallationStage_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtensionInstallReportLogEvent_InstallationStage_strings[6] = {};

static const char ExtensionInstallReportLogEvent_InstallationStage_names[] =
  "COMPLETE"
  "CREATED"
  "DOWNLOADING"
  "INSTALLATION_STAGE_UNKNOWN"
  "INSTALLING"
  "PENDING";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionInstallReportLogEvent_InstallationStage_entries[] = {
  { {ExtensionInstallReportLogEvent_InstallationStage_names + 0, 8}, 5 },
  { {ExtensionInstallReportLogEvent_InstallationStage_names + 8, 7}, 1 },
  { {ExtensionInstallReportLogEvent_InstallationStage_names + 15, 11}, 3 },
  { {ExtensionInstallReportLogEvent_InstallationStage_names + 26, 26}, 0 },
  { {ExtensionInstallReportLogEvent_InstallationStage_names + 52, 10}, 4 },
  { {ExtensionInstallReportLogEvent_InstallationStage_names + 62, 7}, 2 },
};

static const int ExtensionInstallReportLogEvent_InstallationStage_entries_by_number[] = {
  3, // 0 -> INSTALLATION_STAGE_UNKNOWN
  1, // 1 -> CREATED
  5, // 2 -> PENDING
  2, // 3 -> DOWNLOADING
  4, // 4 -> INSTALLING
  0, // 5 -> COMPLETE
};

const std::string& ExtensionInstallReportLogEvent_InstallationStage_Name(
    ExtensionInstallReportLogEvent_InstallationStage value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ExtensionInstallReportLogEvent_InstallationStage_entries,
          ExtensionInstallReportLogEvent_InstallationStage_entries_by_number,
          6, ExtensionInstallReportLogEvent_InstallationStage_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ExtensionInstallReportLogEvent_InstallationStage_entries,
      ExtensionInstallReportLogEvent_InstallationStage_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ExtensionInstallReportLogEvent_InstallationStage_strings[idx].get();
}
bool ExtensionInstallReportLogEvent_InstallationStage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_InstallationStage* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ExtensionInstallReportLogEvent_InstallationStage_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<ExtensionInstallReportLogEvent_InstallationStage>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionInstallReportLogEvent_InstallationStage ExtensionInstallReportLogEvent::INSTALLATION_STAGE_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_InstallationStage ExtensionInstallReportLogEvent::CREATED;
constexpr ExtensionInstallReportLogEvent_InstallationStage ExtensionInstallReportLogEvent::PENDING;
constexpr ExtensionInstallReportLogEvent_InstallationStage ExtensionInstallReportLogEvent::DOWNLOADING;
constexpr ExtensionInstallReportLogEvent_InstallationStage ExtensionInstallReportLogEvent::INSTALLING;
constexpr ExtensionInstallReportLogEvent_InstallationStage ExtensionInstallReportLogEvent::COMPLETE;
constexpr ExtensionInstallReportLogEvent_InstallationStage ExtensionInstallReportLogEvent::InstallationStage_MIN;
constexpr ExtensionInstallReportLogEvent_InstallationStage ExtensionInstallReportLogEvent::InstallationStage_MAX;
constexpr int ExtensionInstallReportLogEvent::InstallationStage_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionInstallReportLogEvent_UserType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtensionInstallReportLogEvent_UserType_strings[10] = {};

static const char ExtensionInstallReportLogEvent_UserType_names[] =
  "USER_TYPE_ACTIVE_DIRECTORY"
  "USER_TYPE_ARC_KIOSK_APP"
  "USER_TYPE_CHILD"
  "USER_TYPE_GUEST"
  "USER_TYPE_KIOSK_APP"
  "USER_TYPE_PUBLIC_ACCOUNT"
  "USER_TYPE_REGULAR"
  "USER_TYPE_SUPERVISED_DEPRECATED"
  "USER_TYPE_UNKNOWN"
  "USER_TYPE_WEB_KIOSK_APP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionInstallReportLogEvent_UserType_entries[] = {
  { {ExtensionInstallReportLogEvent_UserType_names + 0, 26}, 8 },
  { {ExtensionInstallReportLogEvent_UserType_names + 26, 23}, 7 },
  { {ExtensionInstallReportLogEvent_UserType_names + 49, 15}, 6 },
  { {ExtensionInstallReportLogEvent_UserType_names + 64, 15}, 2 },
  { {ExtensionInstallReportLogEvent_UserType_names + 79, 19}, 5 },
  { {ExtensionInstallReportLogEvent_UserType_names + 98, 24}, 3 },
  { {ExtensionInstallReportLogEvent_UserType_names + 122, 17}, 1 },
  { {ExtensionInstallReportLogEvent_UserType_names + 139, 31}, 4 },
  { {ExtensionInstallReportLogEvent_UserType_names + 170, 17}, 0 },
  { {ExtensionInstallReportLogEvent_UserType_names + 187, 23}, 9 },
};

static const int ExtensionInstallReportLogEvent_UserType_entries_by_number[] = {
  8, // 0 -> USER_TYPE_UNKNOWN
  6, // 1 -> USER_TYPE_REGULAR
  3, // 2 -> USER_TYPE_GUEST
  5, // 3 -> USER_TYPE_PUBLIC_ACCOUNT
  7, // 4 -> USER_TYPE_SUPERVISED_DEPRECATED
  4, // 5 -> USER_TYPE_KIOSK_APP
  2, // 6 -> USER_TYPE_CHILD
  1, // 7 -> USER_TYPE_ARC_KIOSK_APP
  0, // 8 -> USER_TYPE_ACTIVE_DIRECTORY
  9, // 9 -> USER_TYPE_WEB_KIOSK_APP
};

const std::string& ExtensionInstallReportLogEvent_UserType_Name(
    ExtensionInstallReportLogEvent_UserType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ExtensionInstallReportLogEvent_UserType_entries,
          ExtensionInstallReportLogEvent_UserType_entries_by_number,
          10, ExtensionInstallReportLogEvent_UserType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ExtensionInstallReportLogEvent_UserType_entries,
      ExtensionInstallReportLogEvent_UserType_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ExtensionInstallReportLogEvent_UserType_strings[idx].get();
}
bool ExtensionInstallReportLogEvent_UserType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_UserType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ExtensionInstallReportLogEvent_UserType_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<ExtensionInstallReportLogEvent_UserType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionInstallReportLogEvent_UserType ExtensionInstallReportLogEvent::USER_TYPE_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_UserType ExtensionInstallReportLogEvent::USER_TYPE_REGULAR;
constexpr ExtensionInstallReportLogEvent_UserType ExtensionInstallReportLogEvent::USER_TYPE_GUEST;
constexpr ExtensionInstallReportLogEvent_UserType ExtensionInstallReportLogEvent::USER_TYPE_PUBLIC_ACCOUNT;
constexpr ExtensionInstallReportLogEvent_UserType ExtensionInstallReportLogEvent::USER_TYPE_SUPERVISED_DEPRECATED;
constexpr ExtensionInstallReportLogEvent_UserType ExtensionInstallReportLogEvent::USER_TYPE_KIOSK_APP;
constexpr ExtensionInstallReportLogEvent_UserType ExtensionInstallReportLogEvent::USER_TYPE_CHILD;
constexpr ExtensionInstallReportLogEvent_UserType ExtensionInstallReportLogEvent::USER_TYPE_ARC_KIOSK_APP;
constexpr ExtensionInstallReportLogEvent_UserType ExtensionInstallReportLogEvent::USER_TYPE_ACTIVE_DIRECTORY;
constexpr ExtensionInstallReportLogEvent_UserType ExtensionInstallReportLogEvent::USER_TYPE_WEB_KIOSK_APP;
constexpr ExtensionInstallReportLogEvent_UserType ExtensionInstallReportLogEvent::UserType_MIN;
constexpr ExtensionInstallReportLogEvent_UserType ExtensionInstallReportLogEvent::UserType_MAX;
constexpr int ExtensionInstallReportLogEvent::UserType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionInstallReportLogEvent_DownloadingStage_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtensionInstallReportLogEvent_DownloadingStage_strings[11] = {};

static const char ExtensionInstallReportLogEvent_DownloadingStage_names[] =
  "DOWNLOADING_CRX"
  "DOWNLOADING_CRX_RETRY"
  "DOWNLOADING_MANIFEST"
  "DOWNLOADING_MANIFEST_RETRY"
  "DOWNLOADING_STAGE_UNKNOWN"
  "DOWNLOAD_PENDING"
  "FINISHED"
  "MANIFEST_LOADED"
  "PARSING_MANIFEST"
  "QUEUED_FOR_CRX"
  "QUEUED_FOR_MANIFEST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionInstallReportLogEvent_DownloadingStage_entries[] = {
  { {ExtensionInstallReportLogEvent_DownloadingStage_names + 0, 15}, 8 },
  { {ExtensionInstallReportLogEvent_DownloadingStage_names + 15, 21}, 9 },
  { {ExtensionInstallReportLogEvent_DownloadingStage_names + 36, 20}, 3 },
  { {ExtensionInstallReportLogEvent_DownloadingStage_names + 56, 26}, 4 },
  { {ExtensionInstallReportLogEvent_DownloadingStage_names + 82, 25}, 0 },
  { {ExtensionInstallReportLogEvent_DownloadingStage_names + 107, 16}, 1 },
  { {ExtensionInstallReportLogEvent_DownloadingStage_names + 123, 8}, 10 },
  { {ExtensionInstallReportLogEvent_DownloadingStage_names + 131, 15}, 6 },
  { {ExtensionInstallReportLogEvent_DownloadingStage_names + 146, 16}, 5 },
  { {ExtensionInstallReportLogEvent_DownloadingStage_names + 162, 14}, 7 },
  { {ExtensionInstallReportLogEvent_DownloadingStage_names + 176, 19}, 2 },
};

static const int ExtensionInstallReportLogEvent_DownloadingStage_entries_by_number[] = {
  4, // 0 -> DOWNLOADING_STAGE_UNKNOWN
  5, // 1 -> DOWNLOAD_PENDING
  10, // 2 -> QUEUED_FOR_MANIFEST
  2, // 3 -> DOWNLOADING_MANIFEST
  3, // 4 -> DOWNLOADING_MANIFEST_RETRY
  8, // 5 -> PARSING_MANIFEST
  7, // 6 -> MANIFEST_LOADED
  9, // 7 -> QUEUED_FOR_CRX
  0, // 8 -> DOWNLOADING_CRX
  1, // 9 -> DOWNLOADING_CRX_RETRY
  6, // 10 -> FINISHED
};

const std::string& ExtensionInstallReportLogEvent_DownloadingStage_Name(
    ExtensionInstallReportLogEvent_DownloadingStage value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ExtensionInstallReportLogEvent_DownloadingStage_entries,
          ExtensionInstallReportLogEvent_DownloadingStage_entries_by_number,
          11, ExtensionInstallReportLogEvent_DownloadingStage_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ExtensionInstallReportLogEvent_DownloadingStage_entries,
      ExtensionInstallReportLogEvent_DownloadingStage_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ExtensionInstallReportLogEvent_DownloadingStage_strings[idx].get();
}
bool ExtensionInstallReportLogEvent_DownloadingStage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_DownloadingStage* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ExtensionInstallReportLogEvent_DownloadingStage_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<ExtensionInstallReportLogEvent_DownloadingStage>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionInstallReportLogEvent_DownloadingStage ExtensionInstallReportLogEvent::DOWNLOADING_STAGE_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_DownloadingStage ExtensionInstallReportLogEvent::DOWNLOAD_PENDING;
constexpr ExtensionInstallReportLogEvent_DownloadingStage ExtensionInstallReportLogEvent::QUEUED_FOR_MANIFEST;
constexpr ExtensionInstallReportLogEvent_DownloadingStage ExtensionInstallReportLogEvent::DOWNLOADING_MANIFEST;
constexpr ExtensionInstallReportLogEvent_DownloadingStage ExtensionInstallReportLogEvent::DOWNLOADING_MANIFEST_RETRY;
constexpr ExtensionInstallReportLogEvent_DownloadingStage ExtensionInstallReportLogEvent::PARSING_MANIFEST;
constexpr ExtensionInstallReportLogEvent_DownloadingStage ExtensionInstallReportLogEvent::MANIFEST_LOADED;
constexpr ExtensionInstallReportLogEvent_DownloadingStage ExtensionInstallReportLogEvent::QUEUED_FOR_CRX;
constexpr ExtensionInstallReportLogEvent_DownloadingStage ExtensionInstallReportLogEvent::DOWNLOADING_CRX;
constexpr ExtensionInstallReportLogEvent_DownloadingStage ExtensionInstallReportLogEvent::DOWNLOADING_CRX_RETRY;
constexpr ExtensionInstallReportLogEvent_DownloadingStage ExtensionInstallReportLogEvent::FINISHED;
constexpr ExtensionInstallReportLogEvent_DownloadingStage ExtensionInstallReportLogEvent::DownloadingStage_MIN;
constexpr ExtensionInstallReportLogEvent_DownloadingStage ExtensionInstallReportLogEvent::DownloadingStage_MAX;
constexpr int ExtensionInstallReportLogEvent::DownloadingStage_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionInstallReportLogEvent_InstallCreationStage_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtensionInstallReportLogEvent_InstallCreationStage_strings[8] = {};

static const char ExtensionInstallReportLogEvent_InstallCreationStage_names[] =
  "CREATION_INITIATED"
  "INSTALL_CREATION_STAGE_UNKNOWN"
  "NOTIFIED_FROM_MANAGEMENT"
  "NOTIFIED_FROM_MANAGEMENT_INITIAL_CREATION_FORCED"
  "NOTIFIED_FROM_MANAGEMENT_INITIAL_CREATION_NOT_FORCED"
  "NOTIFIED_FROM_MANAGEMENT_NOT_FORCED"
  "SEEN_BY_EXTERNAL_PROVIDER"
  "SEEN_BY_POLICY_LOADER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionInstallReportLogEvent_InstallCreationStage_entries[] = {
  { {ExtensionInstallReportLogEvent_InstallCreationStage_names + 0, 18}, 1 },
  { {ExtensionInstallReportLogEvent_InstallCreationStage_names + 18, 30}, 0 },
  { {ExtensionInstallReportLogEvent_InstallCreationStage_names + 48, 24}, 4 },
  { {ExtensionInstallReportLogEvent_InstallCreationStage_names + 72, 48}, 2 },
  { {ExtensionInstallReportLogEvent_InstallCreationStage_names + 120, 52}, 3 },
  { {ExtensionInstallReportLogEvent_InstallCreationStage_names + 172, 35}, 5 },
  { {ExtensionInstallReportLogEvent_InstallCreationStage_names + 207, 25}, 7 },
  { {ExtensionInstallReportLogEvent_InstallCreationStage_names + 232, 21}, 6 },
};

static const int ExtensionInstallReportLogEvent_InstallCreationStage_entries_by_number[] = {
  1, // 0 -> INSTALL_CREATION_STAGE_UNKNOWN
  0, // 1 -> CREATION_INITIATED
  3, // 2 -> NOTIFIED_FROM_MANAGEMENT_INITIAL_CREATION_FORCED
  4, // 3 -> NOTIFIED_FROM_MANAGEMENT_INITIAL_CREATION_NOT_FORCED
  2, // 4 -> NOTIFIED_FROM_MANAGEMENT
  5, // 5 -> NOTIFIED_FROM_MANAGEMENT_NOT_FORCED
  7, // 6 -> SEEN_BY_POLICY_LOADER
  6, // 7 -> SEEN_BY_EXTERNAL_PROVIDER
};

const std::string& ExtensionInstallReportLogEvent_InstallCreationStage_Name(
    ExtensionInstallReportLogEvent_InstallCreationStage value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ExtensionInstallReportLogEvent_InstallCreationStage_entries,
          ExtensionInstallReportLogEvent_InstallCreationStage_entries_by_number,
          8, ExtensionInstallReportLogEvent_InstallCreationStage_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ExtensionInstallReportLogEvent_InstallCreationStage_entries,
      ExtensionInstallReportLogEvent_InstallCreationStage_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ExtensionInstallReportLogEvent_InstallCreationStage_strings[idx].get();
}
bool ExtensionInstallReportLogEvent_InstallCreationStage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_InstallCreationStage* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ExtensionInstallReportLogEvent_InstallCreationStage_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<ExtensionInstallReportLogEvent_InstallCreationStage>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionInstallReportLogEvent_InstallCreationStage ExtensionInstallReportLogEvent::INSTALL_CREATION_STAGE_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_InstallCreationStage ExtensionInstallReportLogEvent::CREATION_INITIATED;
constexpr ExtensionInstallReportLogEvent_InstallCreationStage ExtensionInstallReportLogEvent::NOTIFIED_FROM_MANAGEMENT_INITIAL_CREATION_FORCED;
constexpr ExtensionInstallReportLogEvent_InstallCreationStage ExtensionInstallReportLogEvent::NOTIFIED_FROM_MANAGEMENT_INITIAL_CREATION_NOT_FORCED;
constexpr ExtensionInstallReportLogEvent_InstallCreationStage ExtensionInstallReportLogEvent::NOTIFIED_FROM_MANAGEMENT;
constexpr ExtensionInstallReportLogEvent_InstallCreationStage ExtensionInstallReportLogEvent::NOTIFIED_FROM_MANAGEMENT_NOT_FORCED;
constexpr ExtensionInstallReportLogEvent_InstallCreationStage ExtensionInstallReportLogEvent::SEEN_BY_POLICY_LOADER;
constexpr ExtensionInstallReportLogEvent_InstallCreationStage ExtensionInstallReportLogEvent::SEEN_BY_EXTERNAL_PROVIDER;
constexpr ExtensionInstallReportLogEvent_InstallCreationStage ExtensionInstallReportLogEvent::InstallCreationStage_MIN;
constexpr ExtensionInstallReportLogEvent_InstallCreationStage ExtensionInstallReportLogEvent::InstallCreationStage_MAX;
constexpr int ExtensionInstallReportLogEvent::InstallCreationStage_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionInstallReportLogEvent_DownloadCacheStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtensionInstallReportLogEvent_DownloadCacheStatus_strings[6] = {};

static const char ExtensionInstallReportLogEvent_DownloadCacheStatus_names[] =
  "CACHE_DISABLED"
  "CACHE_HIT"
  "CACHE_HIT_ON_MANIFEST_FETCH_FAILURE"
  "CACHE_MISS"
  "CACHE_OUTDATED"
  "CACHE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionInstallReportLogEvent_DownloadCacheStatus_entries[] = {
  { {ExtensionInstallReportLogEvent_DownloadCacheStatus_names + 0, 14}, 1 },
  { {ExtensionInstallReportLogEvent_DownloadCacheStatus_names + 14, 9}, 4 },
  { {ExtensionInstallReportLogEvent_DownloadCacheStatus_names + 23, 35}, 5 },
  { {ExtensionInstallReportLogEvent_DownloadCacheStatus_names + 58, 10}, 2 },
  { {ExtensionInstallReportLogEvent_DownloadCacheStatus_names + 68, 14}, 3 },
  { {ExtensionInstallReportLogEvent_DownloadCacheStatus_names + 82, 13}, 0 },
};

static const int ExtensionInstallReportLogEvent_DownloadCacheStatus_entries_by_number[] = {
  5, // 0 -> CACHE_UNKNOWN
  0, // 1 -> CACHE_DISABLED
  3, // 2 -> CACHE_MISS
  4, // 3 -> CACHE_OUTDATED
  1, // 4 -> CACHE_HIT
  2, // 5 -> CACHE_HIT_ON_MANIFEST_FETCH_FAILURE
};

const std::string& ExtensionInstallReportLogEvent_DownloadCacheStatus_Name(
    ExtensionInstallReportLogEvent_DownloadCacheStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ExtensionInstallReportLogEvent_DownloadCacheStatus_entries,
          ExtensionInstallReportLogEvent_DownloadCacheStatus_entries_by_number,
          6, ExtensionInstallReportLogEvent_DownloadCacheStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ExtensionInstallReportLogEvent_DownloadCacheStatus_entries,
      ExtensionInstallReportLogEvent_DownloadCacheStatus_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ExtensionInstallReportLogEvent_DownloadCacheStatus_strings[idx].get();
}
bool ExtensionInstallReportLogEvent_DownloadCacheStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_DownloadCacheStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ExtensionInstallReportLogEvent_DownloadCacheStatus_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<ExtensionInstallReportLogEvent_DownloadCacheStatus>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionInstallReportLogEvent_DownloadCacheStatus ExtensionInstallReportLogEvent::CACHE_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_DownloadCacheStatus ExtensionInstallReportLogEvent::CACHE_DISABLED;
constexpr ExtensionInstallReportLogEvent_DownloadCacheStatus ExtensionInstallReportLogEvent::CACHE_MISS;
constexpr ExtensionInstallReportLogEvent_DownloadCacheStatus ExtensionInstallReportLogEvent::CACHE_OUTDATED;
constexpr ExtensionInstallReportLogEvent_DownloadCacheStatus ExtensionInstallReportLogEvent::CACHE_HIT;
constexpr ExtensionInstallReportLogEvent_DownloadCacheStatus ExtensionInstallReportLogEvent::CACHE_HIT_ON_MANIFEST_FETCH_FAILURE;
constexpr ExtensionInstallReportLogEvent_DownloadCacheStatus ExtensionInstallReportLogEvent::DownloadCacheStatus_MIN;
constexpr ExtensionInstallReportLogEvent_DownloadCacheStatus ExtensionInstallReportLogEvent::DownloadCacheStatus_MAX;
constexpr int ExtensionInstallReportLogEvent::DownloadCacheStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_strings[47] = {};

static const char ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names[] =
  "COULD_NOT_CREATE_METADATA_DIRECTORY"
  "COULD_NOT_CREATE_TEMP_DIRECTORY"
  "COULD_NOT_GET_SANDBOX_FRIENDLY_PATH"
  "COULD_NOT_GET_TEMP_DIRECTORY"
  "COULD_NOT_LOCALIZE_EXTENSION"
  "COULD_NOT_READ_CATALOG_DATA_FROM_DISK_UNUSED"
  "COULD_NOT_READ_IMAGE_DATA_FROM_DISK_UNUSED"
  "COULD_NOT_WRITE_VERIFIED_CONTENTS_INTO_FILE"
  "CRX_EXCESSIVELY_LARGE_KEY_OR_SIGNATURE"
  "CRX_EXPECTED_HASH_INVALID"
  "CRX_FILE_IS_DELTA_UPDATE"
  "CRX_FILE_NOT_READABLE"
  "CRX_HASH_VERIFICATION_FAILED"
  "CRX_HEADER_INVALID"
  "CRX_HEADER_VERIFIED_CONTENTS_UNCOMPRESSING_FAILURE"
  "CRX_MAGIC_NUMBER_INVALID"
  "CRX_PUBLIC_KEY_INVALID"
  "CRX_REQUIRED_PROOF_MISSING"
  "CRX_SIGNATURE_INVALID"
  "CRX_SIGNATURE_VERIFICATION_FAILED"
  "CRX_SIGNATURE_VERIFICATION_INITIALIZATION_FAILED"
  "CRX_VERSION_NUMBER_INVALID"
  "CRX_ZERO_KEY_LENGTH"
  "CRX_ZERO_SIGNATURE_LENGTH"
  "DECODED_IMAGES_DO_NOT_MATCH_THE_MANIFEST_UNUSED"
  "DEPRECATED_ABORTED_DUE_TO_SHUTDOWN"
  "DEPRECATED_ERROR_PARSING_DNR_RULESET"
  "DIRECTORY_MOVE_FAILED"
  "ERROR_INDEXING_DNR_RULESET"
  "ERROR_REMOVING_OLD_IMAGE_FILE"
  "ERROR_RE_ENCODING_THEME_IMAGE"
  "ERROR_SAVING_CATALOG"
  "ERROR_SAVING_MANIFEST_JSON"
  "ERROR_SAVING_THEME_IMAGE"
  "ERROR_SERIALIZING_CATALOG"
  "ERROR_SERIALIZING_MANIFEST_JSON"
  "FAILED_TO_COPY_EXTENSION_FILE_TO_TEMP_DIRECTORY"
  "INVALID_CATALOG_DATA"
  "INVALID_MANIFEST"
  "INVALID_PATH_FOR_BITMAP_IMAGE"
  "INVALID_PATH_FOR_BROWSER_IMAGE"
  "INVALID_PATH_FOR_CATALOG_UNUSED"
  "MALFORMED_VERIFIED_CONTENTS"
  "SANDBOXED_UNPACKER_FAILURE_REASON_UNKNOWN"
  "UNPACKER_CLIENT_FAILED"
  "UNZIP_FAILED"
  "UTILITY_PROCESS_CRASHED_WHILE_TRYING_TO_INSTALL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_entries[] = {
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 0, 35}, 45 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 35, 31}, 2 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 66, 35}, 4 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 101, 28}, 1 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 129, 28}, 5 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 157, 44}, 30 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 201, 42}, 22 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 243, 43}, 46 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 286, 38}, 13 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 324, 25}, 39 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 349, 24}, 38 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 373, 21}, 9 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 394, 28}, 35 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 422, 18}, 10 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 440, 50}, 43 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 490, 24}, 11 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 514, 22}, 16 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 536, 26}, 42 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 562, 21}, 17 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 583, 33}, 19 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 616, 48}, 18 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 664, 26}, 12 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 690, 19}, 14 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 709, 25}, 15 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 734, 47}, 23 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 781, 34}, 29 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 815, 36}, 40 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 851, 21}, 37 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 872, 26}, 41 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 898, 29}, 25 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 927, 29}, 27 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 956, 20}, 34 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 976, 26}, 21 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 1002, 24}, 28 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 1026, 25}, 33 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 1051, 31}, 20 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 1082, 47}, 3 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 1129, 20}, 31 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 1149, 16}, 6 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 1165, 29}, 26 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 1194, 30}, 24 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 1224, 31}, 32 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 1255, 27}, 44 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 1282, 41}, 0 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 1323, 22}, 7 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 1345, 12}, 36 },
  { {ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_names + 1357, 47}, 8 },
};

static const int ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_entries_by_number[] = {
  43, // 0 -> SANDBOXED_UNPACKER_FAILURE_REASON_UNKNOWN
  3, // 1 -> COULD_NOT_GET_TEMP_DIRECTORY
  1, // 2 -> COULD_NOT_CREATE_TEMP_DIRECTORY
  36, // 3 -> FAILED_TO_COPY_EXTENSION_FILE_TO_TEMP_DIRECTORY
  2, // 4 -> COULD_NOT_GET_SANDBOX_FRIENDLY_PATH
  4, // 5 -> COULD_NOT_LOCALIZE_EXTENSION
  38, // 6 -> INVALID_MANIFEST
  44, // 7 -> UNPACKER_CLIENT_FAILED
  46, // 8 -> UTILITY_PROCESS_CRASHED_WHILE_TRYING_TO_INSTALL
  11, // 9 -> CRX_FILE_NOT_READABLE
  13, // 10 -> CRX_HEADER_INVALID
  15, // 11 -> CRX_MAGIC_NUMBER_INVALID
  21, // 12 -> CRX_VERSION_NUMBER_INVALID
  8, // 13 -> CRX_EXCESSIVELY_LARGE_KEY_OR_SIGNATURE
  22, // 14 -> CRX_ZERO_KEY_LENGTH
  23, // 15 -> CRX_ZERO_SIGNATURE_LENGTH
  16, // 16 -> CRX_PUBLIC_KEY_INVALID
  18, // 17 -> CRX_SIGNATURE_INVALID
  20, // 18 -> CRX_SIGNATURE_VERIFICATION_INITIALIZATION_FAILED
  19, // 19 -> CRX_SIGNATURE_VERIFICATION_FAILED
  35, // 20 -> ERROR_SERIALIZING_MANIFEST_JSON
  32, // 21 -> ERROR_SAVING_MANIFEST_JSON
  6, // 22 -> COULD_NOT_READ_IMAGE_DATA_FROM_DISK_UNUSED
  24, // 23 -> DECODED_IMAGES_DO_NOT_MATCH_THE_MANIFEST_UNUSED
  40, // 24 -> INVALID_PATH_FOR_BROWSER_IMAGE
  29, // 25 -> ERROR_REMOVING_OLD_IMAGE_FILE
  39, // 26 -> INVALID_PATH_FOR_BITMAP_IMAGE
  30, // 27 -> ERROR_RE_ENCODING_THEME_IMAGE
  33, // 28 -> ERROR_SAVING_THEME_IMAGE
  25, // 29 -> DEPRECATED_ABORTED_DUE_TO_SHUTDOWN
  5, // 30 -> COULD_NOT_READ_CATALOG_DATA_FROM_DISK_UNUSED
  37, // 31 -> INVALID_CATALOG_DATA
  41, // 32 -> INVALID_PATH_FOR_CATALOG_UNUSED
  34, // 33 -> ERROR_SERIALIZING_CATALOG
  31, // 34 -> ERROR_SAVING_CATALOG
  12, // 35 -> CRX_HASH_VERIFICATION_FAILED
  45, // 36 -> UNZIP_FAILED
  27, // 37 -> DIRECTORY_MOVE_FAILED
  10, // 38 -> CRX_FILE_IS_DELTA_UPDATE
  9, // 39 -> CRX_EXPECTED_HASH_INVALID
  26, // 40 -> DEPRECATED_ERROR_PARSING_DNR_RULESET
  28, // 41 -> ERROR_INDEXING_DNR_RULESET
  17, // 42 -> CRX_REQUIRED_PROOF_MISSING
  14, // 43 -> CRX_HEADER_VERIFIED_CONTENTS_UNCOMPRESSING_FAILURE
  42, // 44 -> MALFORMED_VERIFIED_CONTENTS
  0, // 45 -> COULD_NOT_CREATE_METADATA_DIRECTORY
  7, // 46 -> COULD_NOT_WRITE_VERIFIED_CONTENTS_INTO_FILE
};

const std::string& ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_Name(
    ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_entries,
          ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_entries_by_number,
          47, ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_entries,
      ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_entries_by_number,
      47, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_strings[idx].get();
}
bool ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_entries, 47, name, &int_value);
  if (success) {
    *value = static_cast<ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::SANDBOXED_UNPACKER_FAILURE_REASON_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::COULD_NOT_GET_TEMP_DIRECTORY;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::COULD_NOT_CREATE_TEMP_DIRECTORY;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::FAILED_TO_COPY_EXTENSION_FILE_TO_TEMP_DIRECTORY;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::COULD_NOT_GET_SANDBOX_FRIENDLY_PATH;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::COULD_NOT_LOCALIZE_EXTENSION;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::INVALID_MANIFEST;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::UNPACKER_CLIENT_FAILED;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::UTILITY_PROCESS_CRASHED_WHILE_TRYING_TO_INSTALL;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::CRX_FILE_NOT_READABLE;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::CRX_HEADER_INVALID;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::CRX_MAGIC_NUMBER_INVALID;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::CRX_VERSION_NUMBER_INVALID;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::CRX_EXCESSIVELY_LARGE_KEY_OR_SIGNATURE;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::CRX_ZERO_KEY_LENGTH;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::CRX_ZERO_SIGNATURE_LENGTH;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::CRX_PUBLIC_KEY_INVALID;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::CRX_SIGNATURE_INVALID;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::CRX_SIGNATURE_VERIFICATION_INITIALIZATION_FAILED;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::CRX_SIGNATURE_VERIFICATION_FAILED;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::ERROR_SERIALIZING_MANIFEST_JSON;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::ERROR_SAVING_MANIFEST_JSON;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::COULD_NOT_READ_IMAGE_DATA_FROM_DISK_UNUSED;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::DECODED_IMAGES_DO_NOT_MATCH_THE_MANIFEST_UNUSED;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::INVALID_PATH_FOR_BROWSER_IMAGE;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::ERROR_REMOVING_OLD_IMAGE_FILE;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::INVALID_PATH_FOR_BITMAP_IMAGE;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::ERROR_RE_ENCODING_THEME_IMAGE;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::ERROR_SAVING_THEME_IMAGE;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::DEPRECATED_ABORTED_DUE_TO_SHUTDOWN;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::COULD_NOT_READ_CATALOG_DATA_FROM_DISK_UNUSED;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::INVALID_CATALOG_DATA;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::INVALID_PATH_FOR_CATALOG_UNUSED;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::ERROR_SERIALIZING_CATALOG;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::ERROR_SAVING_CATALOG;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::CRX_HASH_VERIFICATION_FAILED;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::UNZIP_FAILED;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::DIRECTORY_MOVE_FAILED;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::CRX_FILE_IS_DELTA_UPDATE;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::CRX_EXPECTED_HASH_INVALID;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::DEPRECATED_ERROR_PARSING_DNR_RULESET;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::ERROR_INDEXING_DNR_RULESET;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::CRX_REQUIRED_PROOF_MISSING;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::CRX_HEADER_VERIFIED_CONTENTS_UNCOMPRESSING_FAILURE;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::MALFORMED_VERIFIED_CONTENTS;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::COULD_NOT_CREATE_METADATA_DIRECTORY;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::COULD_NOT_WRITE_VERIFIED_CONTENTS_INTO_FILE;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::SandboxedUnpackerFailureReason_MIN;
constexpr ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason ExtensionInstallReportLogEvent::SandboxedUnpackerFailureReason_MAX;
constexpr int ExtensionInstallReportLogEvent::SandboxedUnpackerFailureReason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionInstallReportLogEvent_ManifestInvalidError_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtensionInstallReportLogEvent_ManifestInvalidError_strings[15] = {};

static const char ExtensionInstallReportLogEvent_ManifestInvalidError_names[] =
  "BAD_APP_STATUS"
  "BAD_UPDATE_SPECIFICATION"
  "EMPTY_CODEBASE_URL"
  "INVALID_CODEBASE_URL"
  "INVALID_PRODVERSION_MIN"
  "INVALID_PROTOCOL_ON_GUPDATE_TAG"
  "INVALID_VERSION"
  "INVALID_XLMNS_ON_GUPDATE_TAG"
  "MANIFEST_INVALID_ERROR_UNKNOWN"
  "MISSING_APP_ID"
  "MISSING_GUPDATE_TAG"
  "MISSING_UPDATE_CHECK_TAGS"
  "MISSING_VERSION_FOR_UPDATE_CHECK"
  "MULTIPLE_UPDATE_CHECK_TAGS"
  "XML_PARSING_FAILED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionInstallReportLogEvent_ManifestInvalidError_entries[] = {
  { {ExtensionInstallReportLogEvent_ManifestInvalidError_names + 0, 14}, 14 },
  { {ExtensionInstallReportLogEvent_ManifestInvalidError_names + 14, 24}, 13 },
  { {ExtensionInstallReportLogEvent_ManifestInvalidError_names + 38, 18}, 9 },
  { {ExtensionInstallReportLogEvent_ManifestInvalidError_names + 56, 20}, 10 },
  { {ExtensionInstallReportLogEvent_ManifestInvalidError_names + 76, 23}, 8 },
  { {ExtensionInstallReportLogEvent_ManifestInvalidError_names + 99, 31}, 4 },
  { {ExtensionInstallReportLogEvent_ManifestInvalidError_names + 130, 15}, 12 },
  { {ExtensionInstallReportLogEvent_ManifestInvalidError_names + 145, 28}, 2 },
  { {ExtensionInstallReportLogEvent_ManifestInvalidError_names + 173, 30}, 0 },
  { {ExtensionInstallReportLogEvent_ManifestInvalidError_names + 203, 14}, 5 },
  { {ExtensionInstallReportLogEvent_ManifestInvalidError_names + 217, 19}, 3 },
  { {ExtensionInstallReportLogEvent_ManifestInvalidError_names + 236, 25}, 6 },
  { {ExtensionInstallReportLogEvent_ManifestInvalidError_names + 261, 32}, 11 },
  { {ExtensionInstallReportLogEvent_ManifestInvalidError_names + 293, 26}, 7 },
  { {ExtensionInstallReportLogEvent_ManifestInvalidError_names + 319, 18}, 1 },
};

static const int ExtensionInstallReportLogEvent_ManifestInvalidError_entries_by_number[] = {
  8, // 0 -> MANIFEST_INVALID_ERROR_UNKNOWN
  14, // 1 -> XML_PARSING_FAILED
  7, // 2 -> INVALID_XLMNS_ON_GUPDATE_TAG
  10, // 3 -> MISSING_GUPDATE_TAG
  5, // 4 -> INVALID_PROTOCOL_ON_GUPDATE_TAG
  9, // 5 -> MISSING_APP_ID
  11, // 6 -> MISSING_UPDATE_CHECK_TAGS
  13, // 7 -> MULTIPLE_UPDATE_CHECK_TAGS
  4, // 8 -> INVALID_PRODVERSION_MIN
  2, // 9 -> EMPTY_CODEBASE_URL
  3, // 10 -> INVALID_CODEBASE_URL
  12, // 11 -> MISSING_VERSION_FOR_UPDATE_CHECK
  6, // 12 -> INVALID_VERSION
  1, // 13 -> BAD_UPDATE_SPECIFICATION
  0, // 14 -> BAD_APP_STATUS
};

const std::string& ExtensionInstallReportLogEvent_ManifestInvalidError_Name(
    ExtensionInstallReportLogEvent_ManifestInvalidError value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ExtensionInstallReportLogEvent_ManifestInvalidError_entries,
          ExtensionInstallReportLogEvent_ManifestInvalidError_entries_by_number,
          15, ExtensionInstallReportLogEvent_ManifestInvalidError_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ExtensionInstallReportLogEvent_ManifestInvalidError_entries,
      ExtensionInstallReportLogEvent_ManifestInvalidError_entries_by_number,
      15, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ExtensionInstallReportLogEvent_ManifestInvalidError_strings[idx].get();
}
bool ExtensionInstallReportLogEvent_ManifestInvalidError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_ManifestInvalidError* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ExtensionInstallReportLogEvent_ManifestInvalidError_entries, 15, name, &int_value);
  if (success) {
    *value = static_cast<ExtensionInstallReportLogEvent_ManifestInvalidError>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::MANIFEST_INVALID_ERROR_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::XML_PARSING_FAILED;
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::INVALID_XLMNS_ON_GUPDATE_TAG;
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::MISSING_GUPDATE_TAG;
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::INVALID_PROTOCOL_ON_GUPDATE_TAG;
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::MISSING_APP_ID;
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::MISSING_UPDATE_CHECK_TAGS;
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::MULTIPLE_UPDATE_CHECK_TAGS;
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::INVALID_PRODVERSION_MIN;
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::EMPTY_CODEBASE_URL;
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::INVALID_CODEBASE_URL;
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::MISSING_VERSION_FOR_UPDATE_CHECK;
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::INVALID_VERSION;
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::BAD_UPDATE_SPECIFICATION;
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::BAD_APP_STATUS;
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::ManifestInvalidError_MIN;
constexpr ExtensionInstallReportLogEvent_ManifestInvalidError ExtensionInstallReportLogEvent::ManifestInvalidError_MAX;
constexpr int ExtensionInstallReportLogEvent::ManifestInvalidError_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionInstallReportLogEvent_CrxInstallErrorDetail_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtensionInstallReportLogEvent_CrxInstallErrorDetail_strings[25] = {};

static const char ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names[] =
  "CANT_DOWNGRADE_VERSION"
  "CANT_LOAD_EXTENSION"
  "CONVERT_USER_SCRIPT_TO_EXTENSION_FAILED"
  "CRX_ERROR_MANIFEST_INVALID"
  "CRX_INSTALL_ERROR_DETAIL_UNKNOWN"
  "DEPENDENCY_NOT_ALLOWLISTED"
  "DEPENDENCY_NOT_SHARED_MODULE"
  "DEPENDENCY_OLD_VERSION"
  "DISALLOWED_BY_POLICY"
  "EXTENSION_IS_BLOCKLISTED"
  "INCORRECT_APP_CONTENT_TYPE"
  "INCORRECT_INSTALL_HOST"
  "INSTALL_NOT_ENABLED"
  "KIOSK_MODE_ONLY"
  "MISMATCHED_VERSION"
  "MOVE_DIRECTORY_TO_PROFILE_FAILED"
  "NOT_INSTALLED_FROM_GALLERY"
  "OFFSTORE_INSTALL_DISALLOWED"
  "OVERLAPPING_WEB_EXTENT"
  "UNEXPECTED_ID"
  "UNEXPECTED_VERSION"
  "UNSUPPORTED_REQUIREMENTS"
  "UPDATE_NON_EXISTING_EXTENSION"
  "USER_ABORTED"
  "USER_CANCELED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionInstallReportLogEvent_CrxInstallErrorDetail_entries[] = {
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 0, 22}, 19 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 22, 19}, 21 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 41, 39}, 1 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 80, 26}, 5 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 106, 32}, 0 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 138, 26}, 13 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 164, 28}, 11 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 192, 22}, 12 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 214, 20}, 16 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 234, 24}, 15 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 258, 26}, 8 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 284, 22}, 10 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 306, 19}, 6 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 325, 15}, 17 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 340, 18}, 4 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 358, 32}, 20 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 390, 26}, 9 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 416, 27}, 7 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 443, 22}, 18 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 465, 13}, 2 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 478, 18}, 3 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 496, 24}, 14 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 520, 29}, 24 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 549, 12}, 23 },
  { {ExtensionInstallReportLogEvent_CrxInstallErrorDetail_names + 561, 13}, 22 },
};

static const int ExtensionInstallReportLogEvent_CrxInstallErrorDetail_entries_by_number[] = {
  4, // 0 -> CRX_INSTALL_ERROR_DETAIL_UNKNOWN
  2, // 1 -> CONVERT_USER_SCRIPT_TO_EXTENSION_FAILED
  19, // 2 -> UNEXPECTED_ID
  20, // 3 -> UNEXPECTED_VERSION
  14, // 4 -> MISMATCHED_VERSION
  3, // 5 -> CRX_ERROR_MANIFEST_INVALID
  12, // 6 -> INSTALL_NOT_ENABLED
  17, // 7 -> OFFSTORE_INSTALL_DISALLOWED
  10, // 8 -> INCORRECT_APP_CONTENT_TYPE
  16, // 9 -> NOT_INSTALLED_FROM_GALLERY
  11, // 10 -> INCORRECT_INSTALL_HOST
  6, // 11 -> DEPENDENCY_NOT_SHARED_MODULE
  7, // 12 -> DEPENDENCY_OLD_VERSION
  5, // 13 -> DEPENDENCY_NOT_ALLOWLISTED
  21, // 14 -> UNSUPPORTED_REQUIREMENTS
  9, // 15 -> EXTENSION_IS_BLOCKLISTED
  8, // 16 -> DISALLOWED_BY_POLICY
  13, // 17 -> KIOSK_MODE_ONLY
  18, // 18 -> OVERLAPPING_WEB_EXTENT
  0, // 19 -> CANT_DOWNGRADE_VERSION
  15, // 20 -> MOVE_DIRECTORY_TO_PROFILE_FAILED
  1, // 21 -> CANT_LOAD_EXTENSION
  24, // 22 -> USER_CANCELED
  23, // 23 -> USER_ABORTED
  22, // 24 -> UPDATE_NON_EXISTING_EXTENSION
};

const std::string& ExtensionInstallReportLogEvent_CrxInstallErrorDetail_Name(
    ExtensionInstallReportLogEvent_CrxInstallErrorDetail value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ExtensionInstallReportLogEvent_CrxInstallErrorDetail_entries,
          ExtensionInstallReportLogEvent_CrxInstallErrorDetail_entries_by_number,
          25, ExtensionInstallReportLogEvent_CrxInstallErrorDetail_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ExtensionInstallReportLogEvent_CrxInstallErrorDetail_entries,
      ExtensionInstallReportLogEvent_CrxInstallErrorDetail_entries_by_number,
      25, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ExtensionInstallReportLogEvent_CrxInstallErrorDetail_strings[idx].get();
}
bool ExtensionInstallReportLogEvent_CrxInstallErrorDetail_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionInstallReportLogEvent_CrxInstallErrorDetail* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ExtensionInstallReportLogEvent_CrxInstallErrorDetail_entries, 25, name, &int_value);
  if (success) {
    *value = static_cast<ExtensionInstallReportLogEvent_CrxInstallErrorDetail>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::CRX_INSTALL_ERROR_DETAIL_UNKNOWN;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::CONVERT_USER_SCRIPT_TO_EXTENSION_FAILED;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::UNEXPECTED_ID;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::UNEXPECTED_VERSION;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::MISMATCHED_VERSION;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::CRX_ERROR_MANIFEST_INVALID;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::INSTALL_NOT_ENABLED;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::OFFSTORE_INSTALL_DISALLOWED;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::INCORRECT_APP_CONTENT_TYPE;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::NOT_INSTALLED_FROM_GALLERY;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::INCORRECT_INSTALL_HOST;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::DEPENDENCY_NOT_SHARED_MODULE;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::DEPENDENCY_OLD_VERSION;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::DEPENDENCY_NOT_ALLOWLISTED;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::UNSUPPORTED_REQUIREMENTS;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::EXTENSION_IS_BLOCKLISTED;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::DISALLOWED_BY_POLICY;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::KIOSK_MODE_ONLY;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::OVERLAPPING_WEB_EXTENT;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::CANT_DOWNGRADE_VERSION;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::MOVE_DIRECTORY_TO_PROFILE_FAILED;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::CANT_LOAD_EXTENSION;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::USER_CANCELED;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::USER_ABORTED;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::UPDATE_NON_EXISTING_EXTENSION;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::CrxInstallErrorDetail_MIN;
constexpr ExtensionInstallReportLogEvent_CrxInstallErrorDetail ExtensionInstallReportLogEvent::CrxInstallErrorDetail_MAX;
constexpr int ExtensionInstallReportLogEvent::CrxInstallErrorDetail_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AppInstallReportLogEvent_EventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AppInstallReportLogEvent_EventType_strings[16] = {};

static const char AppInstallReportLogEvent_EventType_names[] =
  "CANCELED"
  "CLOUDDPC_MAIN_LOOP_FAILED"
  "CLOUDDPC_REQUEST"
  "CLOUDDPS_REQUEST"
  "CLOUDDPS_RESPONSE"
  "CONNECTIVITY_CHANGE"
  "DIRECT_INSTALL"
  "INSTALLATION_FAILED"
  "INSTALLATION_FINISHED"
  "INSTALLATION_STARTED"
  "LOG_EVENT_TYPE_UNKNOWN"
  "PHONESKY_LOG"
  "PLAYSTORE_LOCAL_POLICY_SET"
  "SERVER_REQUEST"
  "SESSION_STATE_CHANGE"
  "SUCCESS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AppInstallReportLogEvent_EventType_entries[] = {
  { {AppInstallReportLogEvent_EventType_names + 0, 8}, 7 },
  { {AppInstallReportLogEvent_EventType_names + 8, 25}, 14 },
  { {AppInstallReportLogEvent_EventType_names + 33, 16}, 2 },
  { {AppInstallReportLogEvent_EventType_names + 49, 16}, 3 },
  { {AppInstallReportLogEvent_EventType_names + 65, 17}, 4 },
  { {AppInstallReportLogEvent_EventType_names + 82, 19}, 8 },
  { {AppInstallReportLogEvent_EventType_names + 101, 14}, 13 },
  { {AppInstallReportLogEvent_EventType_names + 115, 19}, 12 },
  { {AppInstallReportLogEvent_EventType_names + 134, 21}, 11 },
  { {AppInstallReportLogEvent_EventType_names + 155, 20}, 10 },
  { {AppInstallReportLogEvent_EventType_names + 175, 22}, 0 },
  { {AppInstallReportLogEvent_EventType_names + 197, 12}, 5 },
  { {AppInstallReportLogEvent_EventType_names + 209, 26}, 15 },
  { {AppInstallReportLogEvent_EventType_names + 235, 14}, 1 },
  { {AppInstallReportLogEvent_EventType_names + 249, 20}, 9 },
  { {AppInstallReportLogEvent_EventType_names + 269, 7}, 6 },
};

static const int AppInstallReportLogEvent_EventType_entries_by_number[] = {
  10, // 0 -> LOG_EVENT_TYPE_UNKNOWN
  13, // 1 -> SERVER_REQUEST
  2, // 2 -> CLOUDDPC_REQUEST
  3, // 3 -> CLOUDDPS_REQUEST
  4, // 4 -> CLOUDDPS_RESPONSE
  11, // 5 -> PHONESKY_LOG
  15, // 6 -> SUCCESS
  0, // 7 -> CANCELED
  5, // 8 -> CONNECTIVITY_CHANGE
  14, // 9 -> SESSION_STATE_CHANGE
  9, // 10 -> INSTALLATION_STARTED
  8, // 11 -> INSTALLATION_FINISHED
  7, // 12 -> INSTALLATION_FAILED
  6, // 13 -> DIRECT_INSTALL
  1, // 14 -> CLOUDDPC_MAIN_LOOP_FAILED
  12, // 15 -> PLAYSTORE_LOCAL_POLICY_SET
};

const std::string& AppInstallReportLogEvent_EventType_Name(
    AppInstallReportLogEvent_EventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AppInstallReportLogEvent_EventType_entries,
          AppInstallReportLogEvent_EventType_entries_by_number,
          16, AppInstallReportLogEvent_EventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AppInstallReportLogEvent_EventType_entries,
      AppInstallReportLogEvent_EventType_entries_by_number,
      16, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AppInstallReportLogEvent_EventType_strings[idx].get();
}
bool AppInstallReportLogEvent_EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppInstallReportLogEvent_EventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AppInstallReportLogEvent_EventType_entries, 16, name, &int_value);
  if (success) {
    *value = static_cast<AppInstallReportLogEvent_EventType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent::LOG_EVENT_TYPE_UNKNOWN;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent::SERVER_REQUEST;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent::CLOUDDPC_REQUEST;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent::CLOUDDPS_REQUEST;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent::CLOUDDPS_RESPONSE;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent::PHONESKY_LOG;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent::SUCCESS;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent::CANCELED;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent::CONNECTIVITY_CHANGE;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent::SESSION_STATE_CHANGE;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent::INSTALLATION_STARTED;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent::INSTALLATION_FINISHED;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent::INSTALLATION_FAILED;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent::DIRECT_INSTALL;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent::CLOUDDPC_MAIN_LOOP_FAILED;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent::PLAYSTORE_LOCAL_POLICY_SET;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent::EventType_MIN;
constexpr AppInstallReportLogEvent_EventType AppInstallReportLogEvent::EventType_MAX;
constexpr int AppInstallReportLogEvent::EventType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AppInstallReportLogEvent_SessionStateChangeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AppInstallReportLogEvent_SessionStateChangeType_strings[5] = {};

static const char AppInstallReportLogEvent_SessionStateChangeType_names[] =
  "LOGIN"
  "LOGOUT"
  "RESUME"
  "SESSION_STATE_CHANGE_TYPE_UNKNOWN"
  "SUSPEND";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AppInstallReportLogEvent_SessionStateChangeType_entries[] = {
  { {AppInstallReportLogEvent_SessionStateChangeType_names + 0, 5}, 1 },
  { {AppInstallReportLogEvent_SessionStateChangeType_names + 5, 6}, 2 },
  { {AppInstallReportLogEvent_SessionStateChangeType_names + 11, 6}, 4 },
  { {AppInstallReportLogEvent_SessionStateChangeType_names + 17, 33}, 0 },
  { {AppInstallReportLogEvent_SessionStateChangeType_names + 50, 7}, 3 },
};

static const int AppInstallReportLogEvent_SessionStateChangeType_entries_by_number[] = {
  3, // 0 -> SESSION_STATE_CHANGE_TYPE_UNKNOWN
  0, // 1 -> LOGIN
  1, // 2 -> LOGOUT
  4, // 3 -> SUSPEND
  2, // 4 -> RESUME
};

const std::string& AppInstallReportLogEvent_SessionStateChangeType_Name(
    AppInstallReportLogEvent_SessionStateChangeType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AppInstallReportLogEvent_SessionStateChangeType_entries,
          AppInstallReportLogEvent_SessionStateChangeType_entries_by_number,
          5, AppInstallReportLogEvent_SessionStateChangeType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AppInstallReportLogEvent_SessionStateChangeType_entries,
      AppInstallReportLogEvent_SessionStateChangeType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AppInstallReportLogEvent_SessionStateChangeType_strings[idx].get();
}
bool AppInstallReportLogEvent_SessionStateChangeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppInstallReportLogEvent_SessionStateChangeType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AppInstallReportLogEvent_SessionStateChangeType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<AppInstallReportLogEvent_SessionStateChangeType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AppInstallReportLogEvent_SessionStateChangeType AppInstallReportLogEvent::SESSION_STATE_CHANGE_TYPE_UNKNOWN;
constexpr AppInstallReportLogEvent_SessionStateChangeType AppInstallReportLogEvent::LOGIN;
constexpr AppInstallReportLogEvent_SessionStateChangeType AppInstallReportLogEvent::LOGOUT;
constexpr AppInstallReportLogEvent_SessionStateChangeType AppInstallReportLogEvent::SUSPEND;
constexpr AppInstallReportLogEvent_SessionStateChangeType AppInstallReportLogEvent::RESUME;
constexpr AppInstallReportLogEvent_SessionStateChangeType AppInstallReportLogEvent::SessionStateChangeType_MIN;
constexpr AppInstallReportLogEvent_SessionStateChangeType AppInstallReportLogEvent::SessionStateChangeType_MAX;
constexpr int AppInstallReportLogEvent::SessionStateChangeType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool RefreshAccountRequest_AccountType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RefreshAccountRequest_AccountType_strings[2] = {};

static const char RefreshAccountRequest_AccountType_names[] =
  "ACCOUNT_TYPE_UNSPECIFIED"
  "CHROME_OS_DEMO_MODE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RefreshAccountRequest_AccountType_entries[] = {
  { {RefreshAccountRequest_AccountType_names + 0, 24}, 0 },
  { {RefreshAccountRequest_AccountType_names + 24, 19}, 1 },
};

static const int RefreshAccountRequest_AccountType_entries_by_number[] = {
  0, // 0 -> ACCOUNT_TYPE_UNSPECIFIED
  1, // 1 -> CHROME_OS_DEMO_MODE
};

const std::string& RefreshAccountRequest_AccountType_Name(
    RefreshAccountRequest_AccountType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RefreshAccountRequest_AccountType_entries,
          RefreshAccountRequest_AccountType_entries_by_number,
          2, RefreshAccountRequest_AccountType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RefreshAccountRequest_AccountType_entries,
      RefreshAccountRequest_AccountType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RefreshAccountRequest_AccountType_strings[idx].get();
}
bool RefreshAccountRequest_AccountType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RefreshAccountRequest_AccountType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RefreshAccountRequest_AccountType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<RefreshAccountRequest_AccountType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RefreshAccountRequest_AccountType RefreshAccountRequest::ACCOUNT_TYPE_UNSPECIFIED;
constexpr RefreshAccountRequest_AccountType RefreshAccountRequest::CHROME_OS_DEMO_MODE;
constexpr RefreshAccountRequest_AccountType RefreshAccountRequest::AccountType_MIN;
constexpr RefreshAccountRequest_AccountType RefreshAccountRequest::AccountType_MAX;
constexpr int RefreshAccountRequest::AccountType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PrintJobEvent_PrintSettings_ColorMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PrintJobEvent_PrintSettings_ColorMode_strings[3] = {};

static const char PrintJobEvent_PrintSettings_ColorMode_names[] =
  "BLACK_AND_WHITE"
  "COLOR"
  "UNKNOWN_COLOR_MODE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PrintJobEvent_PrintSettings_ColorMode_entries[] = {
  { {PrintJobEvent_PrintSettings_ColorMode_names + 0, 15}, 1 },
  { {PrintJobEvent_PrintSettings_ColorMode_names + 15, 5}, 2 },
  { {PrintJobEvent_PrintSettings_ColorMode_names + 20, 18}, 0 },
};

static const int PrintJobEvent_PrintSettings_ColorMode_entries_by_number[] = {
  2, // 0 -> UNKNOWN_COLOR_MODE
  0, // 1 -> BLACK_AND_WHITE
  1, // 2 -> COLOR
};

const std::string& PrintJobEvent_PrintSettings_ColorMode_Name(
    PrintJobEvent_PrintSettings_ColorMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PrintJobEvent_PrintSettings_ColorMode_entries,
          PrintJobEvent_PrintSettings_ColorMode_entries_by_number,
          3, PrintJobEvent_PrintSettings_ColorMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PrintJobEvent_PrintSettings_ColorMode_entries,
      PrintJobEvent_PrintSettings_ColorMode_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PrintJobEvent_PrintSettings_ColorMode_strings[idx].get();
}
bool PrintJobEvent_PrintSettings_ColorMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrintJobEvent_PrintSettings_ColorMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PrintJobEvent_PrintSettings_ColorMode_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PrintJobEvent_PrintSettings_ColorMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PrintJobEvent_PrintSettings_ColorMode PrintJobEvent_PrintSettings::UNKNOWN_COLOR_MODE;
constexpr PrintJobEvent_PrintSettings_ColorMode PrintJobEvent_PrintSettings::BLACK_AND_WHITE;
constexpr PrintJobEvent_PrintSettings_ColorMode PrintJobEvent_PrintSettings::COLOR;
constexpr PrintJobEvent_PrintSettings_ColorMode PrintJobEvent_PrintSettings::ColorMode_MIN;
constexpr PrintJobEvent_PrintSettings_ColorMode PrintJobEvent_PrintSettings::ColorMode_MAX;
constexpr int PrintJobEvent_PrintSettings::ColorMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PrintJobEvent_PrintSettings_DuplexMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PrintJobEvent_PrintSettings_DuplexMode_strings[4] = {};

static const char PrintJobEvent_PrintSettings_DuplexMode_names[] =
  "ONE_SIDED"
  "TWO_SIDED_LONG_EDGE"
  "TWO_SIDED_SHORT_EDGE"
  "UNKNOWN_DUPLEX_MODE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PrintJobEvent_PrintSettings_DuplexMode_entries[] = {
  { {PrintJobEvent_PrintSettings_DuplexMode_names + 0, 9}, 1 },
  { {PrintJobEvent_PrintSettings_DuplexMode_names + 9, 19}, 2 },
  { {PrintJobEvent_PrintSettings_DuplexMode_names + 28, 20}, 3 },
  { {PrintJobEvent_PrintSettings_DuplexMode_names + 48, 19}, 0 },
};

static const int PrintJobEvent_PrintSettings_DuplexMode_entries_by_number[] = {
  3, // 0 -> UNKNOWN_DUPLEX_MODE
  0, // 1 -> ONE_SIDED
  1, // 2 -> TWO_SIDED_LONG_EDGE
  2, // 3 -> TWO_SIDED_SHORT_EDGE
};

const std::string& PrintJobEvent_PrintSettings_DuplexMode_Name(
    PrintJobEvent_PrintSettings_DuplexMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PrintJobEvent_PrintSettings_DuplexMode_entries,
          PrintJobEvent_PrintSettings_DuplexMode_entries_by_number,
          4, PrintJobEvent_PrintSettings_DuplexMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PrintJobEvent_PrintSettings_DuplexMode_entries,
      PrintJobEvent_PrintSettings_DuplexMode_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PrintJobEvent_PrintSettings_DuplexMode_strings[idx].get();
}
bool PrintJobEvent_PrintSettings_DuplexMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrintJobEvent_PrintSettings_DuplexMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PrintJobEvent_PrintSettings_DuplexMode_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PrintJobEvent_PrintSettings_DuplexMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PrintJobEvent_PrintSettings_DuplexMode PrintJobEvent_PrintSettings::UNKNOWN_DUPLEX_MODE;
constexpr PrintJobEvent_PrintSettings_DuplexMode PrintJobEvent_PrintSettings::ONE_SIDED;
constexpr PrintJobEvent_PrintSettings_DuplexMode PrintJobEvent_PrintSettings::TWO_SIDED_LONG_EDGE;
constexpr PrintJobEvent_PrintSettings_DuplexMode PrintJobEvent_PrintSettings::TWO_SIDED_SHORT_EDGE;
constexpr PrintJobEvent_PrintSettings_DuplexMode PrintJobEvent_PrintSettings::DuplexMode_MIN;
constexpr PrintJobEvent_PrintSettings_DuplexMode PrintJobEvent_PrintSettings::DuplexMode_MAX;
constexpr int PrintJobEvent_PrintSettings::DuplexMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PrintJobEvent_UserType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PrintJobEvent_UserType_strings[4] = {};

static const char PrintJobEvent_UserType_names[] =
  "GUEST"
  "KIOSK"
  "REGULAR"
  "UNKNOWN_USER_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PrintJobEvent_UserType_entries[] = {
  { {PrintJobEvent_UserType_names + 0, 5}, 2 },
  { {PrintJobEvent_UserType_names + 5, 5}, 3 },
  { {PrintJobEvent_UserType_names + 10, 7}, 1 },
  { {PrintJobEvent_UserType_names + 17, 17}, 0 },
};

static const int PrintJobEvent_UserType_entries_by_number[] = {
  3, // 0 -> UNKNOWN_USER_TYPE
  2, // 1 -> REGULAR
  0, // 2 -> GUEST
  1, // 3 -> KIOSK
};

const std::string& PrintJobEvent_UserType_Name(
    PrintJobEvent_UserType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PrintJobEvent_UserType_entries,
          PrintJobEvent_UserType_entries_by_number,
          4, PrintJobEvent_UserType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PrintJobEvent_UserType_entries,
      PrintJobEvent_UserType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PrintJobEvent_UserType_strings[idx].get();
}
bool PrintJobEvent_UserType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrintJobEvent_UserType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PrintJobEvent_UserType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PrintJobEvent_UserType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PrintJobEvent_UserType PrintJobEvent::UNKNOWN_USER_TYPE;
constexpr PrintJobEvent_UserType PrintJobEvent::REGULAR;
constexpr PrintJobEvent_UserType PrintJobEvent::GUEST;
constexpr PrintJobEvent_UserType PrintJobEvent::KIOSK;
constexpr PrintJobEvent_UserType PrintJobEvent::UserType_MIN;
constexpr PrintJobEvent_UserType PrintJobEvent::UserType_MAX;
constexpr int PrintJobEvent::UserType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool App_AppType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> App_AppType_strings[9] = {};

static const char App_AppType_names[] =
  "ARC"
  "BOREALIS"
  "BRUSCHETTA"
  "BUILT_IN"
  "CROSTINI"
  "EXTENSION"
  "PLUGIN_VM"
  "UNKNOWN"
  "WEB";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry App_AppType_entries[] = {
  { {App_AppType_names + 0, 3}, 1 },
  { {App_AppType_names + 3, 8}, 7 },
  { {App_AppType_names + 11, 10}, 8 },
  { {App_AppType_names + 21, 8}, 2 },
  { {App_AppType_names + 29, 8}, 3 },
  { {App_AppType_names + 37, 9}, 4 },
  { {App_AppType_names + 46, 9}, 6 },
  { {App_AppType_names + 55, 7}, 0 },
  { {App_AppType_names + 62, 3}, 5 },
};

static const int App_AppType_entries_by_number[] = {
  7, // 0 -> UNKNOWN
  0, // 1 -> ARC
  3, // 2 -> BUILT_IN
  4, // 3 -> CROSTINI
  5, // 4 -> EXTENSION
  8, // 5 -> WEB
  6, // 6 -> PLUGIN_VM
  1, // 7 -> BOREALIS
  2, // 8 -> BRUSCHETTA
};

const std::string& App_AppType_Name(
    App_AppType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          App_AppType_entries,
          App_AppType_entries_by_number,
          9, App_AppType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      App_AppType_entries,
      App_AppType_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     App_AppType_strings[idx].get();
}
bool App_AppType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, App_AppType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      App_AppType_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<App_AppType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr App_AppType App::UNKNOWN;
constexpr App_AppType App::ARC;
constexpr App_AppType App::BUILT_IN;
constexpr App_AppType App::CROSTINI;
constexpr App_AppType App::EXTENSION;
constexpr App_AppType App::WEB;
constexpr App_AppType App::PLUGIN_VM;
constexpr App_AppType App::BOREALIS;
constexpr App_AppType App::BRUSCHETTA;
constexpr App_AppType App::AppType_MIN;
constexpr App_AppType App::AppType_MAX;
constexpr int App::AppType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AppActivity_AppState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AppActivity_AppState_strings[6] = {};

static const char AppActivity_AppState_names[] =
  "ALWAYS_AVAILABLE"
  "BLOCKED"
  "DEFAULT"
  "LIMIT_REACHED"
  "UNINSTALLED"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AppActivity_AppState_entries[] = {
  { {AppActivity_AppState_names + 0, 16}, 2 },
  { {AppActivity_AppState_names + 16, 7}, 3 },
  { {AppActivity_AppState_names + 23, 7}, 1 },
  { {AppActivity_AppState_names + 30, 13}, 4 },
  { {AppActivity_AppState_names + 43, 11}, 5 },
  { {AppActivity_AppState_names + 54, 7}, 0 },
};

static const int AppActivity_AppState_entries_by_number[] = {
  5, // 0 -> UNKNOWN
  2, // 1 -> DEFAULT
  0, // 2 -> ALWAYS_AVAILABLE
  1, // 3 -> BLOCKED
  3, // 4 -> LIMIT_REACHED
  4, // 5 -> UNINSTALLED
};

const std::string& AppActivity_AppState_Name(
    AppActivity_AppState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AppActivity_AppState_entries,
          AppActivity_AppState_entries_by_number,
          6, AppActivity_AppState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AppActivity_AppState_entries,
      AppActivity_AppState_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AppActivity_AppState_strings[idx].get();
}
bool AppActivity_AppState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppActivity_AppState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AppActivity_AppState_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<AppActivity_AppState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AppActivity_AppState AppActivity::UNKNOWN;
constexpr AppActivity_AppState AppActivity::DEFAULT;
constexpr AppActivity_AppState AppActivity::ALWAYS_AVAILABLE;
constexpr AppActivity_AppState AppActivity::BLOCKED;
constexpr AppActivity_AppState AppActivity::LIMIT_REACHED;
constexpr AppActivity_AppState AppActivity::UNINSTALLED;
constexpr AppActivity_AppState AppActivity::AppState_MIN;
constexpr AppActivity_AppState AppActivity::AppState_MAX;
constexpr int AppActivity::AppState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientCertificateProvisioningResponse_Error_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientCertificateProvisioningResponse_Error_strings[10] = {};

static const char ClientCertificateProvisioningResponse_Error_names[] =
  "BAD_CA_CERTIFICATE_SPECIFIED"
  "BAD_CLIENT_CERTIFICATE_RECEIVED"
  "BAD_PUBLIC_KEY"
  "CA_ERROR"
  "CSR_ALREADY_SENT"
  "IDENTITY_VERIFICATION_ERROR"
  "INCONSISTENT_DATA"
  "INVALID_CSR_SIGNATURE"
  "TIMED_OUT"
  "UNDEFINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientCertificateProvisioningResponse_Error_entries[] = {
  { {ClientCertificateProvisioningResponse_Error_names + 0, 28}, 6 },
  { {ClientCertificateProvisioningResponse_Error_names + 28, 31}, 7 },
  { {ClientCertificateProvisioningResponse_Error_names + 59, 14}, 5 },
  { {ClientCertificateProvisioningResponse_Error_names + 73, 8}, 3 },
  { {ClientCertificateProvisioningResponse_Error_names + 81, 16}, 9 },
  { {ClientCertificateProvisioningResponse_Error_names + 97, 27}, 2 },
  { {ClientCertificateProvisioningResponse_Error_names + 124, 17}, 4 },
  { {ClientCertificateProvisioningResponse_Error_names + 141, 21}, 8 },
  { {ClientCertificateProvisioningResponse_Error_names + 162, 9}, 1 },
  { {ClientCertificateProvisioningResponse_Error_names + 171, 9}, 0 },
};

static const int ClientCertificateProvisioningResponse_Error_entries_by_number[] = {
  9, // 0 -> UNDEFINED
  8, // 1 -> TIMED_OUT
  5, // 2 -> IDENTITY_VERIFICATION_ERROR
  3, // 3 -> CA_ERROR
  6, // 4 -> INCONSISTENT_DATA
  2, // 5 -> BAD_PUBLIC_KEY
  0, // 6 -> BAD_CA_CERTIFICATE_SPECIFIED
  1, // 7 -> BAD_CLIENT_CERTIFICATE_RECEIVED
  7, // 8 -> INVALID_CSR_SIGNATURE
  4, // 9 -> CSR_ALREADY_SENT
};

const std::string& ClientCertificateProvisioningResponse_Error_Name(
    ClientCertificateProvisioningResponse_Error value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientCertificateProvisioningResponse_Error_entries,
          ClientCertificateProvisioningResponse_Error_entries_by_number,
          10, ClientCertificateProvisioningResponse_Error_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientCertificateProvisioningResponse_Error_entries,
      ClientCertificateProvisioningResponse_Error_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientCertificateProvisioningResponse_Error_strings[idx].get();
}
bool ClientCertificateProvisioningResponse_Error_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientCertificateProvisioningResponse_Error* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientCertificateProvisioningResponse_Error_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<ClientCertificateProvisioningResponse_Error>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse::UNDEFINED;
constexpr ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse::TIMED_OUT;
constexpr ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse::IDENTITY_VERIFICATION_ERROR;
constexpr ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse::CA_ERROR;
constexpr ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse::INCONSISTENT_DATA;
constexpr ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse::BAD_PUBLIC_KEY;
constexpr ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse::BAD_CA_CERTIFICATE_SPECIFIED;
constexpr ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse::BAD_CLIENT_CERTIFICATE_RECEIVED;
constexpr ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse::INVALID_CSR_SIGNATURE;
constexpr ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse::CSR_ALREADY_SENT;
constexpr ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse::Error_MIN;
constexpr ClientCertificateProvisioningResponse_Error ClientCertificateProvisioningResponse::Error_MAX;
constexpr int ClientCertificateProvisioningResponse::Error_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool BrowserPublicKeyUploadRequest_KeyTrustLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BrowserPublicKeyUploadRequest_KeyTrustLevel_strings[3] = {};

static const char BrowserPublicKeyUploadRequest_KeyTrustLevel_names[] =
  "CHROME_BROWSER_HW_KEY"
  "CHROME_BROWSER_OS_KEY"
  "KEY_TRUST_LEVEL_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BrowserPublicKeyUploadRequest_KeyTrustLevel_entries[] = {
  { {BrowserPublicKeyUploadRequest_KeyTrustLevel_names + 0, 21}, 1 },
  { {BrowserPublicKeyUploadRequest_KeyTrustLevel_names + 21, 21}, 2 },
  { {BrowserPublicKeyUploadRequest_KeyTrustLevel_names + 42, 27}, 0 },
};

static const int BrowserPublicKeyUploadRequest_KeyTrustLevel_entries_by_number[] = {
  2, // 0 -> KEY_TRUST_LEVEL_UNSPECIFIED
  0, // 1 -> CHROME_BROWSER_HW_KEY
  1, // 2 -> CHROME_BROWSER_OS_KEY
};

const std::string& BrowserPublicKeyUploadRequest_KeyTrustLevel_Name(
    BrowserPublicKeyUploadRequest_KeyTrustLevel value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BrowserPublicKeyUploadRequest_KeyTrustLevel_entries,
          BrowserPublicKeyUploadRequest_KeyTrustLevel_entries_by_number,
          3, BrowserPublicKeyUploadRequest_KeyTrustLevel_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BrowserPublicKeyUploadRequest_KeyTrustLevel_entries,
      BrowserPublicKeyUploadRequest_KeyTrustLevel_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BrowserPublicKeyUploadRequest_KeyTrustLevel_strings[idx].get();
}
bool BrowserPublicKeyUploadRequest_KeyTrustLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BrowserPublicKeyUploadRequest_KeyTrustLevel* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BrowserPublicKeyUploadRequest_KeyTrustLevel_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<BrowserPublicKeyUploadRequest_KeyTrustLevel>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BrowserPublicKeyUploadRequest_KeyTrustLevel BrowserPublicKeyUploadRequest::KEY_TRUST_LEVEL_UNSPECIFIED;
constexpr BrowserPublicKeyUploadRequest_KeyTrustLevel BrowserPublicKeyUploadRequest::CHROME_BROWSER_HW_KEY;
constexpr BrowserPublicKeyUploadRequest_KeyTrustLevel BrowserPublicKeyUploadRequest::CHROME_BROWSER_OS_KEY;
constexpr BrowserPublicKeyUploadRequest_KeyTrustLevel BrowserPublicKeyUploadRequest::KeyTrustLevel_MIN;
constexpr BrowserPublicKeyUploadRequest_KeyTrustLevel BrowserPublicKeyUploadRequest::KeyTrustLevel_MAX;
constexpr int BrowserPublicKeyUploadRequest::KeyTrustLevel_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool BrowserPublicKeyUploadRequest_KeyType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BrowserPublicKeyUploadRequest_KeyType_strings[3] = {};

static const char BrowserPublicKeyUploadRequest_KeyType_names[] =
  "EC_KEY"
  "KEY_TYPE_UNSPECIFIED"
  "RSA_KEY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BrowserPublicKeyUploadRequest_KeyType_entries[] = {
  { {BrowserPublicKeyUploadRequest_KeyType_names + 0, 6}, 2 },
  { {BrowserPublicKeyUploadRequest_KeyType_names + 6, 20}, 0 },
  { {BrowserPublicKeyUploadRequest_KeyType_names + 26, 7}, 1 },
};

static const int BrowserPublicKeyUploadRequest_KeyType_entries_by_number[] = {
  1, // 0 -> KEY_TYPE_UNSPECIFIED
  2, // 1 -> RSA_KEY
  0, // 2 -> EC_KEY
};

const std::string& BrowserPublicKeyUploadRequest_KeyType_Name(
    BrowserPublicKeyUploadRequest_KeyType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BrowserPublicKeyUploadRequest_KeyType_entries,
          BrowserPublicKeyUploadRequest_KeyType_entries_by_number,
          3, BrowserPublicKeyUploadRequest_KeyType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BrowserPublicKeyUploadRequest_KeyType_entries,
      BrowserPublicKeyUploadRequest_KeyType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BrowserPublicKeyUploadRequest_KeyType_strings[idx].get();
}
bool BrowserPublicKeyUploadRequest_KeyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BrowserPublicKeyUploadRequest_KeyType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BrowserPublicKeyUploadRequest_KeyType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<BrowserPublicKeyUploadRequest_KeyType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BrowserPublicKeyUploadRequest_KeyType BrowserPublicKeyUploadRequest::KEY_TYPE_UNSPECIFIED;
constexpr BrowserPublicKeyUploadRequest_KeyType BrowserPublicKeyUploadRequest::RSA_KEY;
constexpr BrowserPublicKeyUploadRequest_KeyType BrowserPublicKeyUploadRequest::EC_KEY;
constexpr BrowserPublicKeyUploadRequest_KeyType BrowserPublicKeyUploadRequest::KeyType_MIN;
constexpr BrowserPublicKeyUploadRequest_KeyType BrowserPublicKeyUploadRequest::KeyType_MAX;
constexpr int BrowserPublicKeyUploadRequest::KeyType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool BrowserPublicKeyUploadResponse_ResponseCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BrowserPublicKeyUploadResponse_ResponseCode_strings[3] = {};

static const char BrowserPublicKeyUploadResponse_ResponseCode_names[] =
  "INVALID_SIGNATURE"
  "SUCCESS"
  "UNDEFINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BrowserPublicKeyUploadResponse_ResponseCode_entries[] = {
  { {BrowserPublicKeyUploadResponse_ResponseCode_names + 0, 17}, 2 },
  { {BrowserPublicKeyUploadResponse_ResponseCode_names + 17, 7}, 1 },
  { {BrowserPublicKeyUploadResponse_ResponseCode_names + 24, 9}, 0 },
};

static const int BrowserPublicKeyUploadResponse_ResponseCode_entries_by_number[] = {
  2, // 0 -> UNDEFINED
  1, // 1 -> SUCCESS
  0, // 2 -> INVALID_SIGNATURE
};

const std::string& BrowserPublicKeyUploadResponse_ResponseCode_Name(
    BrowserPublicKeyUploadResponse_ResponseCode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BrowserPublicKeyUploadResponse_ResponseCode_entries,
          BrowserPublicKeyUploadResponse_ResponseCode_entries_by_number,
          3, BrowserPublicKeyUploadResponse_ResponseCode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BrowserPublicKeyUploadResponse_ResponseCode_entries,
      BrowserPublicKeyUploadResponse_ResponseCode_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BrowserPublicKeyUploadResponse_ResponseCode_strings[idx].get();
}
bool BrowserPublicKeyUploadResponse_ResponseCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BrowserPublicKeyUploadResponse_ResponseCode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BrowserPublicKeyUploadResponse_ResponseCode_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<BrowserPublicKeyUploadResponse_ResponseCode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BrowserPublicKeyUploadResponse_ResponseCode BrowserPublicKeyUploadResponse::UNDEFINED;
constexpr BrowserPublicKeyUploadResponse_ResponseCode BrowserPublicKeyUploadResponse::SUCCESS;
constexpr BrowserPublicKeyUploadResponse_ResponseCode BrowserPublicKeyUploadResponse::INVALID_SIGNATURE;
constexpr BrowserPublicKeyUploadResponse_ResponseCode BrowserPublicKeyUploadResponse::ResponseCode_MIN;
constexpr BrowserPublicKeyUploadResponse_ResponseCode BrowserPublicKeyUploadResponse::ResponseCode_MAX;
constexpr int BrowserPublicKeyUploadResponse::ResponseCode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool UserSessionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UserSessionType_strings[8] = {};

static const char UserSessionType_names[] =
  "AFFILIATED_USER_SESSION"
  "AUTO_LAUNCHED_KIOSK_SESSION"
  "GUEST_SESSION"
  "MANAGED_GUEST_SESSION"
  "MANUALLY_LAUNCHED_KIOSK_SESSION"
  "NO_SESSION"
  "UNAFFILIATED_USER_SESSION"
  "USER_SESSION_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UserSessionType_entries[] = {
  { {UserSessionType_names + 0, 23}, 3 },
  { {UserSessionType_names + 23, 27}, 1 },
  { {UserSessionType_names + 50, 13}, 6 },
  { {UserSessionType_names + 63, 21}, 5 },
  { {UserSessionType_names + 84, 31}, 2 },
  { {UserSessionType_names + 115, 10}, 7 },
  { {UserSessionType_names + 125, 25}, 4 },
  { {UserSessionType_names + 150, 25}, 0 },
};

static const int UserSessionType_entries_by_number[] = {
  7, // 0 -> USER_SESSION_TYPE_UNKNOWN
  1, // 1 -> AUTO_LAUNCHED_KIOSK_SESSION
  4, // 2 -> MANUALLY_LAUNCHED_KIOSK_SESSION
  0, // 3 -> AFFILIATED_USER_SESSION
  6, // 4 -> UNAFFILIATED_USER_SESSION
  3, // 5 -> MANAGED_GUEST_SESSION
  2, // 6 -> GUEST_SESSION
  5, // 7 -> NO_SESSION
};

const std::string& UserSessionType_Name(
    UserSessionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UserSessionType_entries,
          UserSessionType_entries_by_number,
          8, UserSessionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UserSessionType_entries,
      UserSessionType_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UserSessionType_strings[idx].get();
}
bool UserSessionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserSessionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UserSessionType_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<UserSessionType>(int_value);
  }
  return success;
}
bool CrdSessionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CrdSessionType_strings[3] = {};

static const char CrdSessionType_names[] =
  "CRD_SESSION_TYPE_UNKNOWN"
  "REMOTE_ACCESS_SESSION"
  "REMOTE_SUPPORT_SESSION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CrdSessionType_entries[] = {
  { {CrdSessionType_names + 0, 24}, 0 },
  { {CrdSessionType_names + 24, 21}, 1 },
  { {CrdSessionType_names + 45, 22}, 2 },
};

static const int CrdSessionType_entries_by_number[] = {
  0, // 0 -> CRD_SESSION_TYPE_UNKNOWN
  1, // 1 -> REMOTE_ACCESS_SESSION
  2, // 2 -> REMOTE_SUPPORT_SESSION
};

const std::string& CrdSessionType_Name(
    CrdSessionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CrdSessionType_entries,
          CrdSessionType_entries_by_number,
          3, CrdSessionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CrdSessionType_entries,
      CrdSessionType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CrdSessionType_strings[idx].get();
}
bool CrdSessionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CrdSessionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CrdSessionType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CrdSessionType>(int_value);
  }
  return success;
}
bool CrdSessionAvailability_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CrdSessionAvailability_strings[4] = {};

static const char CrdSessionAvailability_names[] =
  "AVAILABLE"
  "CRD_SESSION_AVAILABILITY_UNKNOWN"
  "UNAVAILABLE_UNMANAGED_ENVIRONMENT"
  "UNAVAILABLE_UNSUPPORTED_USER_SESSION_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CrdSessionAvailability_entries[] = {
  { {CrdSessionAvailability_names + 0, 9}, 1 },
  { {CrdSessionAvailability_names + 9, 32}, 0 },
  { {CrdSessionAvailability_names + 41, 33}, 3 },
  { {CrdSessionAvailability_names + 74, 41}, 2 },
};

static const int CrdSessionAvailability_entries_by_number[] = {
  1, // 0 -> CRD_SESSION_AVAILABILITY_UNKNOWN
  0, // 1 -> AVAILABLE
  3, // 2 -> UNAVAILABLE_UNSUPPORTED_USER_SESSION_TYPE
  2, // 3 -> UNAVAILABLE_UNMANAGED_ENVIRONMENT
};

const std::string& CrdSessionAvailability_Name(
    CrdSessionAvailability value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CrdSessionAvailability_entries,
          CrdSessionAvailability_entries_by_number,
          4, CrdSessionAvailability_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CrdSessionAvailability_entries,
      CrdSessionAvailability_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CrdSessionAvailability_strings[idx].get();
}
bool CrdSessionAvailability_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CrdSessionAvailability* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CrdSessionAvailability_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CrdSessionAvailability>(int_value);
  }
  return success;
}
bool Channel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Channel_strings[5] = {};

static const char Channel_names[] =
  "CHANNEL_BETA"
  "CHANNEL_CANARY"
  "CHANNEL_DEV"
  "CHANNEL_STABLE"
  "CHANNEL_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Channel_entries[] = {
  { {Channel_names + 0, 12}, 3 },
  { {Channel_names + 12, 14}, 1 },
  { {Channel_names + 26, 11}, 2 },
  { {Channel_names + 37, 14}, 4 },
  { {Channel_names + 51, 15}, 0 },
};

static const int Channel_entries_by_number[] = {
  4, // 0 -> CHANNEL_UNKNOWN
  1, // 1 -> CHANNEL_CANARY
  2, // 2 -> CHANNEL_DEV
  0, // 3 -> CHANNEL_BETA
  3, // 4 -> CHANNEL_STABLE
};

const std::string& Channel_Name(
    Channel value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Channel_entries,
          Channel_entries_by_number,
          5, Channel_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Channel_entries,
      Channel_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Channel_strings[idx].get();
}
bool Channel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Channel* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Channel_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<Channel>(int_value);
  }
  return success;
}
bool BusDeviceClass_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BusDeviceClass_strings[6] = {};

static const char BusDeviceClass_names[] =
  "BLUETOOTH_ADAPTER"
  "DEVICE_CLASS_UNSPECIFIED"
  "DISPLAY_CONTROLLER"
  "ETHERNET_CONTROLLER"
  "THUNDERBOLT_CONTROLLER"
  "WIRELESS_CONTROLLER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BusDeviceClass_entries[] = {
  { {BusDeviceClass_names + 0, 17}, 4 },
  { {BusDeviceClass_names + 17, 24}, 0 },
  { {BusDeviceClass_names + 41, 18}, 1 },
  { {BusDeviceClass_names + 59, 19}, 2 },
  { {BusDeviceClass_names + 78, 22}, 5 },
  { {BusDeviceClass_names + 100, 19}, 3 },
};

static const int BusDeviceClass_entries_by_number[] = {
  1, // 0 -> DEVICE_CLASS_UNSPECIFIED
  2, // 1 -> DISPLAY_CONTROLLER
  3, // 2 -> ETHERNET_CONTROLLER
  5, // 3 -> WIRELESS_CONTROLLER
  0, // 4 -> BLUETOOTH_ADAPTER
  4, // 5 -> THUNDERBOLT_CONTROLLER
};

const std::string& BusDeviceClass_Name(
    BusDeviceClass value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BusDeviceClass_entries,
          BusDeviceClass_entries_by_number,
          6, BusDeviceClass_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BusDeviceClass_entries,
      BusDeviceClass_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BusDeviceClass_strings[idx].get();
}
bool BusDeviceClass_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BusDeviceClass* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BusDeviceClass_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<BusDeviceClass>(int_value);
  }
  return success;
}
bool BusType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BusType_strings[4] = {};

static const char BusType_names[] =
  "BUS_TYPE_UNSPECIFIED"
  "PCI_BUS"
  "THUNDERBOLT_BUS"
  "USB_BUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BusType_entries[] = {
  { {BusType_names + 0, 20}, 0 },
  { {BusType_names + 20, 7}, 1 },
  { {BusType_names + 27, 15}, 3 },
  { {BusType_names + 42, 7}, 2 },
};

static const int BusType_entries_by_number[] = {
  0, // 0 -> BUS_TYPE_UNSPECIFIED
  1, // 1 -> PCI_BUS
  3, // 2 -> USB_BUS
  2, // 3 -> THUNDERBOLT_BUS
};

const std::string& BusType_Name(
    BusType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BusType_entries,
          BusType_entries_by_number,
          4, BusType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BusType_entries,
      BusType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BusType_strings[idx].get();
}
bool BusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BusType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BusType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<BusType>(int_value);
  }
  return success;
}
bool PartialReportType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PartialReportType_strings[2] = {};

static const char PartialReportType_names[] =
  "EXTENSION_REQUEST"
  "UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PartialReportType_entries[] = {
  { {PartialReportType_names + 0, 17}, 1 },
  { {PartialReportType_names + 17, 11}, 0 },
};

static const int PartialReportType_entries_by_number[] = {
  1, // 0 -> UNSPECIFIED
  0, // 1 -> EXTENSION_REQUEST
};

const std::string& PartialReportType_Name(
    PartialReportType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PartialReportType_entries,
          PartialReportType_entries_by_number,
          2, PartialReportType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PartialReportType_entries,
      PartialReportType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PartialReportType_strings[idx].get();
}
bool PartialReportType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PartialReportType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PartialReportType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<PartialReportType>(int_value);
  }
  return success;
}
bool CrostiniAppType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CrostiniAppType_strings[3] = {};

static const char CrostiniAppType_names[] =
  "CROSTINI_APP_TYPE_INTERACTIVE"
  "CROSTINI_APP_TYPE_OTHER"
  "CROSTINI_APP_TYPE_TERMINAL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CrostiniAppType_entries[] = {
  { {CrostiniAppType_names + 0, 29}, 1 },
  { {CrostiniAppType_names + 29, 23}, 2 },
  { {CrostiniAppType_names + 52, 26}, 0 },
};

static const int CrostiniAppType_entries_by_number[] = {
  2, // 0 -> CROSTINI_APP_TYPE_TERMINAL
  0, // 1 -> CROSTINI_APP_TYPE_INTERACTIVE
  1, // 2 -> CROSTINI_APP_TYPE_OTHER
};

const std::string& CrostiniAppType_Name(
    CrostiniAppType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CrostiniAppType_entries,
          CrostiniAppType_entries_by_number,
          3, CrostiniAppType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CrostiniAppType_entries,
      CrostiniAppType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CrostiniAppType_strings[idx].get();
}
bool CrostiniAppType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CrostiniAppType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CrostiniAppType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CrostiniAppType>(int_value);
  }
  return success;
}
bool HashingAlgorithm_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> HashingAlgorithm_strings[4] = {};

static const char HashingAlgorithm_names[] =
  "HASHING_ALGORITHM_UNSPECIFIED"
  "NO_HASH"
  "SHA1"
  "SHA256";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry HashingAlgorithm_entries[] = {
  { {HashingAlgorithm_names + 0, 29}, 0 },
  { {HashingAlgorithm_names + 29, 7}, 3 },
  { {HashingAlgorithm_names + 36, 4}, 1 },
  { {HashingAlgorithm_names + 40, 6}, 2 },
};

static const int HashingAlgorithm_entries_by_number[] = {
  0, // 0 -> HASHING_ALGORITHM_UNSPECIFIED
  2, // 1 -> SHA1
  3, // 2 -> SHA256
  1, // 3 -> NO_HASH
};

const std::string& HashingAlgorithm_Name(
    HashingAlgorithm value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          HashingAlgorithm_entries,
          HashingAlgorithm_entries_by_number,
          4, HashingAlgorithm_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      HashingAlgorithm_entries,
      HashingAlgorithm_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     HashingAlgorithm_strings[idx].get();
}
bool HashingAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HashingAlgorithm* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      HashingAlgorithm_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<HashingAlgorithm>(int_value);
  }
  return success;
}
bool SigningAlgorithm_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SigningAlgorithm_strings[2] = {};

static const char SigningAlgorithm_names[] =
  "RSA_PKCS1_V1_5"
  "SIGNING_ALGORITHM_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SigningAlgorithm_entries[] = {
  { {SigningAlgorithm_names + 0, 14}, 1 },
  { {SigningAlgorithm_names + 14, 29}, 0 },
};

static const int SigningAlgorithm_entries_by_number[] = {
  1, // 0 -> SIGNING_ALGORITHM_UNSPECIFIED
  0, // 1 -> RSA_PKCS1_V1_5
};

const std::string& SigningAlgorithm_Name(
    SigningAlgorithm value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SigningAlgorithm_entries,
          SigningAlgorithm_entries_by_number,
          2, SigningAlgorithm_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SigningAlgorithm_entries,
      SigningAlgorithm_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SigningAlgorithm_strings[idx].get();
}
bool SigningAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SigningAlgorithm* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SigningAlgorithm_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<SigningAlgorithm>(int_value);
  }
  return success;
}
bool DeviceManagementErrorDetail_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DeviceManagementErrorDetail_strings[3] = {};

static const char DeviceManagementErrorDetail_names[] =
  "CBCM_DELETION_POLICY_PREFERENCE_DELETE_TOKEN"
  "CBCM_DELETION_POLICY_PREFERENCE_INVALIDATE_TOKEN"
  "NO_ERROR_DETAIL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceManagementErrorDetail_entries[] = {
  { {DeviceManagementErrorDetail_names + 0, 44}, 1 },
  { {DeviceManagementErrorDetail_names + 44, 48}, 2 },
  { {DeviceManagementErrorDetail_names + 92, 15}, 0 },
};

static const int DeviceManagementErrorDetail_entries_by_number[] = {
  2, // 0 -> NO_ERROR_DETAIL
  0, // 1 -> CBCM_DELETION_POLICY_PREFERENCE_DELETE_TOKEN
  1, // 2 -> CBCM_DELETION_POLICY_PREFERENCE_INVALIDATE_TOKEN
};

const std::string& DeviceManagementErrorDetail_Name(
    DeviceManagementErrorDetail value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceManagementErrorDetail_entries,
          DeviceManagementErrorDetail_entries_by_number,
          3, DeviceManagementErrorDetail_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceManagementErrorDetail_entries,
      DeviceManagementErrorDetail_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DeviceManagementErrorDetail_strings[idx].get();
}
bool DeviceManagementErrorDetail_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceManagementErrorDetail* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceManagementErrorDetail_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DeviceManagementErrorDetail>(int_value);
  }
  return success;
}

// ===================================================================

class LicenseType::_Internal {
 public:
  using HasBits = decltype(std::declval<LicenseType>()._impl_._has_bits_);
  static void set_has_license_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LicenseType::LicenseType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.LicenseType)
}
LicenseType::LicenseType(const LicenseType& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LicenseType* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.license_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.license_type_ = from._impl_.license_type_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.LicenseType)
}

inline void LicenseType::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.license_type_){0}
  };
}

LicenseType::~LicenseType() {
  // @@protoc_insertion_point(destructor:enterprise_management.LicenseType)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LicenseType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LicenseType::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LicenseType::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.LicenseType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.license_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LicenseType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.LicenseType.LicenseTypeEnum license_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::LicenseType_LicenseTypeEnum_IsValid(val))) {
            _internal_set_license_type(static_cast<::enterprise_management::LicenseType_LicenseTypeEnum>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LicenseType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.LicenseType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.LicenseType.LicenseTypeEnum license_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_license_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.LicenseType)
  return target;
}

size_t LicenseType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.LicenseType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.LicenseType.LicenseTypeEnum license_type = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_license_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LicenseType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LicenseType*>(
      &from));
}

void LicenseType::MergeFrom(const LicenseType& from) {
  LicenseType* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.LicenseType)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_license_type()) {
    _this->_internal_set_license_type(from._internal_license_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LicenseType::CopyFrom(const LicenseType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.LicenseType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LicenseType::IsInitialized() const {
  return true;
}

void LicenseType::InternalSwap(LicenseType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.license_type_, other->_impl_.license_type_);
}

std::string LicenseType::GetTypeName() const {
  return "enterprise_management.LicenseType";
}


// ===================================================================

class SignedData::_Internal {
 public:
  using HasBits = decltype(std::declval<SignedData>()._impl_._has_bits_);
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_extra_data_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SignedData::SignedData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.SignedData)
}
SignedData::SignedData(const SignedData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SignedData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.extra_data_bytes_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.extra_data_bytes_ = from._impl_.extra_data_bytes_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.SignedData)
}

inline void SignedData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.extra_data_bytes_){0}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SignedData::~SignedData() {
  // @@protoc_insertion_point(destructor:enterprise_management.SignedData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SignedData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
  _impl_.signature_.Destroy();
}

void SignedData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SignedData::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.SignedData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.signature_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.extra_data_bytes_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SignedData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes signature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 extra_data_bytes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_extra_data_bytes(&has_bits);
          _impl_.extra_data_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SignedData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.SignedData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_data(), target);
  }

  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_signature(), target);
  }

  // optional int32 extra_data_bytes = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_extra_data_bytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.SignedData)
  return target;
}

size_t SignedData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.SignedData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes data = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional bytes signature = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_signature());
    }

    // optional int32 extra_data_bytes = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_extra_data_bytes());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SignedData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SignedData*>(
      &from));
}

void SignedData::MergeFrom(const SignedData& from) {
  SignedData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.SignedData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.extra_data_bytes_ = from._impl_.extra_data_bytes_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SignedData::CopyFrom(const SignedData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.SignedData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignedData::IsInitialized() const {
  return true;
}

void SignedData::InternalSwap(SignedData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
  swap(_impl_.extra_data_bytes_, other->_impl_.extra_data_bytes_);
}

std::string SignedData::GetTypeName() const {
  return "enterprise_management.SignedData";
}


// ===================================================================

class CheckUserAccountRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CheckUserAccountRequest>()._impl_._has_bits_);
  static void set_has_user_email(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CheckUserAccountRequest::CheckUserAccountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CheckUserAccountRequest)
}
CheckUserAccountRequest::CheckUserAccountRequest(const CheckUserAccountRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CheckUserAccountRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_email_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.user_email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_email()) {
    _this->_impl_.user_email_.Set(from._internal_user_email(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CheckUserAccountRequest)
}

inline void CheckUserAccountRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_email_){}
  };
  _impl_.user_email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CheckUserAccountRequest::~CheckUserAccountRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.CheckUserAccountRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckUserAccountRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_email_.Destroy();
}

void CheckUserAccountRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckUserAccountRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CheckUserAccountRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.user_email_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CheckUserAccountRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_email = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_email();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckUserAccountRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CheckUserAccountRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string user_email = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_email(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CheckUserAccountRequest)
  return target;
}

size_t CheckUserAccountRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CheckUserAccountRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string user_email = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_email());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CheckUserAccountRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CheckUserAccountRequest*>(
      &from));
}

void CheckUserAccountRequest::MergeFrom(const CheckUserAccountRequest& from) {
  CheckUserAccountRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CheckUserAccountRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_user_email()) {
    _this->_internal_set_user_email(from._internal_user_email());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CheckUserAccountRequest::CopyFrom(const CheckUserAccountRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CheckUserAccountRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckUserAccountRequest::IsInitialized() const {
  return true;
}

void CheckUserAccountRequest::InternalSwap(CheckUserAccountRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_email_, lhs_arena,
      &other->_impl_.user_email_, rhs_arena
  );
}

std::string CheckUserAccountRequest::GetTypeName() const {
  return "enterprise_management.CheckUserAccountRequest";
}


// ===================================================================

class DeviceRegisterRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceRegisterRequest>()._impl_._has_bits_);
  static void set_has_reregister(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_machine_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_machine_model(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_requisition(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_server_backed_state_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flavor(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::enterprise_management::LicenseType& license_type(const DeviceRegisterRequest* msg);
  static void set_has_license_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_lifetime(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_brand_code(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_reregistration_dm_token(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ethernet_mac_address(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_dock_mac_address(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_manufacture_date(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_expected_enrollment_domain(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::enterprise_management::DeviceRegisterIdentification& device_register_identification(const DeviceRegisterRequest* msg);
  static void set_has_device_register_identification(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_psm_execution_result(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_psm_determination_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
};

const ::enterprise_management::LicenseType&
DeviceRegisterRequest::_Internal::license_type(const DeviceRegisterRequest* msg) {
  return *msg->_impl_.license_type_;
}
const ::enterprise_management::DeviceRegisterIdentification&
DeviceRegisterRequest::_Internal::device_register_identification(const DeviceRegisterRequest* msg) {
  return *msg->_impl_.device_register_identification_;
}
DeviceRegisterRequest::DeviceRegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceRegisterRequest)
}
DeviceRegisterRequest::DeviceRegisterRequest(const DeviceRegisterRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceRegisterRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.machine_id_){}
    , decltype(_impl_.machine_model_){}
    , decltype(_impl_.requisition_){}
    , decltype(_impl_.server_backed_state_key_){}
    , decltype(_impl_.brand_code_){}
    , decltype(_impl_.reregistration_dm_token_){}
    , decltype(_impl_.ethernet_mac_address_){}
    , decltype(_impl_.dock_mac_address_){}
    , decltype(_impl_.manufacture_date_){}
    , decltype(_impl_.expected_enrollment_domain_){}
    , decltype(_impl_.license_type_){nullptr}
    , decltype(_impl_.device_register_identification_){nullptr}
    , decltype(_impl_.reregister_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.flavor_){}
    , decltype(_impl_.psm_execution_result_){}
    , decltype(_impl_.psm_determination_timestamp_ms_){}
    , decltype(_impl_.lifetime_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.machine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_machine_id()) {
    _this->_impl_.machine_id_.Set(from._internal_machine_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.machine_model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_machine_model()) {
    _this->_impl_.machine_model_.Set(from._internal_machine_model(), 
      _this->GetArenaForAllocation());
  }
  _impl_.requisition_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.requisition_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_requisition()) {
    _this->_impl_.requisition_.Set(from._internal_requisition(), 
      _this->GetArenaForAllocation());
  }
  _impl_.server_backed_state_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_backed_state_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_server_backed_state_key()) {
    _this->_impl_.server_backed_state_key_.Set(from._internal_server_backed_state_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.brand_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.brand_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_brand_code()) {
    _this->_impl_.brand_code_.Set(from._internal_brand_code(), 
      _this->GetArenaForAllocation());
  }
  _impl_.reregistration_dm_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reregistration_dm_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reregistration_dm_token()) {
    _this->_impl_.reregistration_dm_token_.Set(from._internal_reregistration_dm_token(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ethernet_mac_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ethernet_mac_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ethernet_mac_address()) {
    _this->_impl_.ethernet_mac_address_.Set(from._internal_ethernet_mac_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dock_mac_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dock_mac_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dock_mac_address()) {
    _this->_impl_.dock_mac_address_.Set(from._internal_dock_mac_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.manufacture_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacture_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_manufacture_date()) {
    _this->_impl_.manufacture_date_.Set(from._internal_manufacture_date(), 
      _this->GetArenaForAllocation());
  }
  _impl_.expected_enrollment_domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.expected_enrollment_domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_expected_enrollment_domain()) {
    _this->_impl_.expected_enrollment_domain_.Set(from._internal_expected_enrollment_domain(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_license_type()) {
    _this->_impl_.license_type_ = new ::enterprise_management::LicenseType(*from._impl_.license_type_);
  }
  if (from._internal_has_device_register_identification()) {
    _this->_impl_.device_register_identification_ = new ::enterprise_management::DeviceRegisterIdentification(*from._impl_.device_register_identification_);
  }
  ::memcpy(&_impl_.reregister_, &from._impl_.reregister_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.lifetime_) -
    reinterpret_cast<char*>(&_impl_.reregister_)) + sizeof(_impl_.lifetime_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceRegisterRequest)
}

inline void DeviceRegisterRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.machine_id_){}
    , decltype(_impl_.machine_model_){}
    , decltype(_impl_.requisition_){}
    , decltype(_impl_.server_backed_state_key_){}
    , decltype(_impl_.brand_code_){}
    , decltype(_impl_.reregistration_dm_token_){}
    , decltype(_impl_.ethernet_mac_address_){}
    , decltype(_impl_.dock_mac_address_){}
    , decltype(_impl_.manufacture_date_){}
    , decltype(_impl_.expected_enrollment_domain_){}
    , decltype(_impl_.license_type_){nullptr}
    , decltype(_impl_.device_register_identification_){nullptr}
    , decltype(_impl_.reregister_){false}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.flavor_){0}
    , decltype(_impl_.psm_execution_result_){0}
    , decltype(_impl_.psm_determination_timestamp_ms_){int64_t{0}}
    , decltype(_impl_.lifetime_){1}
  };
  _impl_.machine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.machine_model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.requisition_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.requisition_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.server_backed_state_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_backed_state_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.brand_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.brand_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reregistration_dm_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reregistration_dm_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ethernet_mac_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ethernet_mac_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dock_mac_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dock_mac_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.manufacture_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacture_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.expected_enrollment_domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.expected_enrollment_domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceRegisterRequest::~DeviceRegisterRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceRegisterRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceRegisterRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.machine_id_.Destroy();
  _impl_.machine_model_.Destroy();
  _impl_.requisition_.Destroy();
  _impl_.server_backed_state_key_.Destroy();
  _impl_.brand_code_.Destroy();
  _impl_.reregistration_dm_token_.Destroy();
  _impl_.ethernet_mac_address_.Destroy();
  _impl_.dock_mac_address_.Destroy();
  _impl_.manufacture_date_.Destroy();
  _impl_.expected_enrollment_domain_.Destroy();
  if (this != internal_default_instance()) delete _impl_.license_type_;
  if (this != internal_default_instance()) delete _impl_.device_register_identification_;
}

void DeviceRegisterRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceRegisterRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceRegisterRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.machine_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.machine_model_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.requisition_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.server_backed_state_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.brand_code_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.reregistration_dm_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.ethernet_mac_address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.dock_mac_address_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _impl_.manufacture_date_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      _impl_.expected_enrollment_domain_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.license_type_ != nullptr);
      _impl_.license_type_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.device_register_identification_ != nullptr);
      _impl_.device_register_identification_->Clear();
    }
  }
  if (cached_has_bits & 0x0000f000u) {
    ::memset(&_impl_.reregister_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.psm_execution_result_) -
        reinterpret_cast<char*>(&_impl_.reregister_)) + sizeof(_impl_.psm_execution_result_));
  }
  if (cached_has_bits & 0x00030000u) {
    _impl_.psm_determination_timestamp_ms_ = int64_t{0};
    _impl_.lifetime_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceRegisterRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool reregister = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_reregister(&has_bits);
          _impl_.reregister_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceRegisterRequest.Type type = 2 [default = TT];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceRegisterRequest_Type_IsValid(val))) {
            _internal_set_type(static_cast<::enterprise_management::DeviceRegisterRequest_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string machine_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_machine_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string machine_model = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_machine_model();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string requisition = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_requisition();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes server_backed_state_key = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_server_backed_state_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceRegisterRequest.Flavor flavor = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceRegisterRequest_Flavor_IsValid(val))) {
            _internal_set_flavor(static_cast<::enterprise_management::DeviceRegisterRequest_Flavor>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.LicenseType license_type = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_license_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceRegisterRequest.Lifetime lifetime = 11 [default = LIFETIME_INDEFINITE];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceRegisterRequest_Lifetime_IsValid(val))) {
            _internal_set_lifetime(static_cast<::enterprise_management::DeviceRegisterRequest_Lifetime>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(11, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string brand_code = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_brand_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string reregistration_dm_token = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_reregistration_dm_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ethernet_mac_address = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_ethernet_mac_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string dock_mac_address = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_dock_mac_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string manufacture_date = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_manufacture_date();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string expected_enrollment_domain = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_expected_enrollment_domain();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceRegisterIdentification device_register_identification = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_register_identification(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceRegisterRequest.PsmExecutionResult psm_execution_result = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceRegisterRequest_PsmExecutionResult_IsValid(val))) {
            _internal_set_psm_execution_result(static_cast<::enterprise_management::DeviceRegisterRequest_PsmExecutionResult>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(19, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 psm_determination_timestamp_ms = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_psm_determination_timestamp_ms(&has_bits);
          _impl_.psm_determination_timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceRegisterRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceRegisterRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool reregister = 1;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_reregister(), target);
  }

  // optional .enterprise_management.DeviceRegisterRequest.Type type = 2 [default = TT];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // optional string machine_id = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_machine_id(), target);
  }

  // optional string machine_model = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_machine_model(), target);
  }

  // optional string requisition = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_requisition(), target);
  }

  // optional bytes server_backed_state_key = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_server_backed_state_key(), target);
  }

  // optional .enterprise_management.DeviceRegisterRequest.Flavor flavor = 8;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_flavor(), target);
  }

  // optional .enterprise_management.LicenseType license_type = 9;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::license_type(this),
        _Internal::license_type(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceRegisterRequest.Lifetime lifetime = 11 [default = LIFETIME_INDEFINITE];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      11, this->_internal_lifetime(), target);
  }

  // optional string brand_code = 12;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_brand_code(), target);
  }

  // optional string reregistration_dm_token = 13;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_reregistration_dm_token(), target);
  }

  // optional string ethernet_mac_address = 14;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_ethernet_mac_address(), target);
  }

  // optional string dock_mac_address = 15;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_dock_mac_address(), target);
  }

  // optional string manufacture_date = 16;
  if (cached_has_bits & 0x00000100u) {
    target = stream->WriteStringMaybeAliased(
        16, this->_internal_manufacture_date(), target);
  }

  // optional string expected_enrollment_domain = 17;
  if (cached_has_bits & 0x00000200u) {
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_expected_enrollment_domain(), target);
  }

  // optional .enterprise_management.DeviceRegisterIdentification device_register_identification = 18;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::device_register_identification(this),
        _Internal::device_register_identification(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceRegisterRequest.PsmExecutionResult psm_execution_result = 19;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      19, this->_internal_psm_execution_result(), target);
  }

  // optional int64 psm_determination_timestamp_ms = 20;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(20, this->_internal_psm_determination_timestamp_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceRegisterRequest)
  return target;
}

size_t DeviceRegisterRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceRegisterRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string machine_id = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_machine_id());
    }

    // optional string machine_model = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_machine_model());
    }

    // optional string requisition = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_requisition());
    }

    // optional bytes server_backed_state_key = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_server_backed_state_key());
    }

    // optional string brand_code = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_brand_code());
    }

    // optional string reregistration_dm_token = 13;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_reregistration_dm_token());
    }

    // optional string ethernet_mac_address = 14;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ethernet_mac_address());
    }

    // optional string dock_mac_address = 15;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dock_mac_address());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional string manufacture_date = 16;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_manufacture_date());
    }

    // optional string expected_enrollment_domain = 17;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_expected_enrollment_domain());
    }

    // optional .enterprise_management.LicenseType license_type = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.license_type_);
    }

    // optional .enterprise_management.DeviceRegisterIdentification device_register_identification = 18;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_register_identification_);
    }

    // optional bool reregister = 1;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional .enterprise_management.DeviceRegisterRequest.Type type = 2 [default = TT];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional .enterprise_management.DeviceRegisterRequest.Flavor flavor = 8;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_flavor());
    }

    // optional .enterprise_management.DeviceRegisterRequest.PsmExecutionResult psm_execution_result = 19;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_psm_execution_result());
    }

  }
  if (cached_has_bits & 0x00030000u) {
    // optional int64 psm_determination_timestamp_ms = 20;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_psm_determination_timestamp_ms());
    }

    // optional .enterprise_management.DeviceRegisterRequest.Lifetime lifetime = 11 [default = LIFETIME_INDEFINITE];
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_lifetime());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceRegisterRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceRegisterRequest*>(
      &from));
}

void DeviceRegisterRequest::MergeFrom(const DeviceRegisterRequest& from) {
  DeviceRegisterRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceRegisterRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_machine_id(from._internal_machine_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_machine_model(from._internal_machine_model());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_requisition(from._internal_requisition());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_server_backed_state_key(from._internal_server_backed_state_key());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_brand_code(from._internal_brand_code());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_reregistration_dm_token(from._internal_reregistration_dm_token());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_ethernet_mac_address(from._internal_ethernet_mac_address());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_dock_mac_address(from._internal_dock_mac_address());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_set_manufacture_date(from._internal_manufacture_date());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_set_expected_enrollment_domain(from._internal_expected_enrollment_domain());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_license_type()->::enterprise_management::LicenseType::MergeFrom(
          from._internal_license_type());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_device_register_identification()->::enterprise_management::DeviceRegisterIdentification::MergeFrom(
          from._internal_device_register_identification());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.reregister_ = from._impl_.reregister_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.flavor_ = from._impl_.flavor_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.psm_execution_result_ = from._impl_.psm_execution_result_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00030000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.psm_determination_timestamp_ms_ = from._impl_.psm_determination_timestamp_ms_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.lifetime_ = from._impl_.lifetime_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceRegisterRequest::CopyFrom(const DeviceRegisterRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceRegisterRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceRegisterRequest::IsInitialized() const {
  return true;
}

void DeviceRegisterRequest::InternalSwap(DeviceRegisterRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_id_, lhs_arena,
      &other->_impl_.machine_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_model_, lhs_arena,
      &other->_impl_.machine_model_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.requisition_, lhs_arena,
      &other->_impl_.requisition_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.server_backed_state_key_, lhs_arena,
      &other->_impl_.server_backed_state_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.brand_code_, lhs_arena,
      &other->_impl_.brand_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reregistration_dm_token_, lhs_arena,
      &other->_impl_.reregistration_dm_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ethernet_mac_address_, lhs_arena,
      &other->_impl_.ethernet_mac_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dock_mac_address_, lhs_arena,
      &other->_impl_.dock_mac_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.manufacture_date_, lhs_arena,
      &other->_impl_.manufacture_date_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.expected_enrollment_domain_, lhs_arena,
      &other->_impl_.expected_enrollment_domain_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceRegisterRequest, _impl_.psm_determination_timestamp_ms_)
      + sizeof(DeviceRegisterRequest::_impl_.psm_determination_timestamp_ms_)
      - PROTOBUF_FIELD_OFFSET(DeviceRegisterRequest, _impl_.license_type_)>(
          reinterpret_cast<char*>(&_impl_.license_type_),
          reinterpret_cast<char*>(&other->_impl_.license_type_));
  swap(_impl_.lifetime_, other->_impl_.lifetime_);
}

std::string DeviceRegisterRequest::GetTypeName() const {
  return "enterprise_management.DeviceRegisterRequest";
}


// ===================================================================

class DeviceRegisterIdentification::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceRegisterIdentification>()._impl_._has_bits_);
  static void set_has_attested_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceRegisterIdentification::DeviceRegisterIdentification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceRegisterIdentification)
}
DeviceRegisterIdentification::DeviceRegisterIdentification(const DeviceRegisterIdentification& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceRegisterIdentification* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attested_device_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attested_device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attested_device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attested_device_id()) {
    _this->_impl_.attested_device_id_.Set(from._internal_attested_device_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceRegisterIdentification)
}

inline void DeviceRegisterIdentification::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attested_device_id_){}
  };
  _impl_.attested_device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attested_device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceRegisterIdentification::~DeviceRegisterIdentification() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceRegisterIdentification)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceRegisterIdentification::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attested_device_id_.Destroy();
}

void DeviceRegisterIdentification::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceRegisterIdentification::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceRegisterIdentification)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attested_device_id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceRegisterIdentification::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string attested_device_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_attested_device_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceRegisterIdentification::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceRegisterIdentification)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string attested_device_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_attested_device_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceRegisterIdentification)
  return target;
}

size_t DeviceRegisterIdentification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceRegisterIdentification)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string attested_device_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_attested_device_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceRegisterIdentification::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceRegisterIdentification*>(
      &from));
}

void DeviceRegisterIdentification::MergeFrom(const DeviceRegisterIdentification& from) {
  DeviceRegisterIdentification* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceRegisterIdentification)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_attested_device_id()) {
    _this->_internal_set_attested_device_id(from._internal_attested_device_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceRegisterIdentification::CopyFrom(const DeviceRegisterIdentification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceRegisterIdentification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceRegisterIdentification::IsInitialized() const {
  return true;
}

void DeviceRegisterIdentification::InternalSwap(DeviceRegisterIdentification* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attested_device_id_, lhs_arena,
      &other->_impl_.attested_device_id_, rhs_arena
  );
}

std::string DeviceRegisterIdentification::GetTypeName() const {
  return "enterprise_management.DeviceRegisterIdentification";
}


// ===================================================================

class CheckUserAccountResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CheckUserAccountResponse>()._impl_._has_bits_);
  static void set_has_domain_verified(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_account_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CheckUserAccountResponse::CheckUserAccountResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CheckUserAccountResponse)
}
CheckUserAccountResponse::CheckUserAccountResponse(const CheckUserAccountResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CheckUserAccountResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.domain_verified_){}
    , decltype(_impl_.user_account_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.domain_verified_, &from._impl_.domain_verified_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.user_account_type_) -
    reinterpret_cast<char*>(&_impl_.domain_verified_)) + sizeof(_impl_.user_account_type_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CheckUserAccountResponse)
}

inline void CheckUserAccountResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.domain_verified_){false}
    , decltype(_impl_.user_account_type_){0}
  };
}

CheckUserAccountResponse::~CheckUserAccountResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.CheckUserAccountResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckUserAccountResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CheckUserAccountResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckUserAccountResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CheckUserAccountResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.domain_verified_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.user_account_type_) -
        reinterpret_cast<char*>(&_impl_.domain_verified_)) + sizeof(_impl_.user_account_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CheckUserAccountResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool domain_verified = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_domain_verified(&has_bits);
          _impl_.domain_verified_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.CheckUserAccountResponse.UserAccountType user_account_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::CheckUserAccountResponse_UserAccountType_IsValid(val))) {
            _internal_set_user_account_type(static_cast<::enterprise_management::CheckUserAccountResponse_UserAccountType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckUserAccountResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CheckUserAccountResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool domain_verified = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_domain_verified(), target);
  }

  // optional .enterprise_management.CheckUserAccountResponse.UserAccountType user_account_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_user_account_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CheckUserAccountResponse)
  return target;
}

size_t CheckUserAccountResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CheckUserAccountResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool domain_verified = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional .enterprise_management.CheckUserAccountResponse.UserAccountType user_account_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_user_account_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CheckUserAccountResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CheckUserAccountResponse*>(
      &from));
}

void CheckUserAccountResponse::MergeFrom(const CheckUserAccountResponse& from) {
  CheckUserAccountResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CheckUserAccountResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.domain_verified_ = from._impl_.domain_verified_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.user_account_type_ = from._impl_.user_account_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CheckUserAccountResponse::CopyFrom(const CheckUserAccountResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CheckUserAccountResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckUserAccountResponse::IsInitialized() const {
  return true;
}

void CheckUserAccountResponse::InternalSwap(CheckUserAccountResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CheckUserAccountResponse, _impl_.user_account_type_)
      + sizeof(CheckUserAccountResponse::_impl_.user_account_type_)
      - PROTOBUF_FIELD_OFFSET(CheckUserAccountResponse, _impl_.domain_verified_)>(
          reinterpret_cast<char*>(&_impl_.domain_verified_),
          reinterpret_cast<char*>(&other->_impl_.domain_verified_));
}

std::string CheckUserAccountResponse::GetTypeName() const {
  return "enterprise_management.CheckUserAccountResponse";
}


// ===================================================================

class DeviceRegisterResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceRegisterResponse>()._impl_._has_bits_);
  static void set_has_device_management_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_machine_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_enrollment_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_configuration_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_directory_api_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

DeviceRegisterResponse::DeviceRegisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceRegisterResponse)
}
DeviceRegisterResponse::DeviceRegisterResponse(const DeviceRegisterResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceRegisterResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_affiliation_ids_){from._impl_.user_affiliation_ids_}
    , decltype(_impl_.device_management_token_){}
    , decltype(_impl_.machine_name_){}
    , decltype(_impl_.configuration_seed_){}
    , decltype(_impl_.directory_api_id_){}
    , decltype(_impl_.enrollment_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.device_management_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_management_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_management_token()) {
    _this->_impl_.device_management_token_.Set(from._internal_device_management_token(), 
      _this->GetArenaForAllocation());
  }
  _impl_.machine_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_machine_name()) {
    _this->_impl_.machine_name_.Set(from._internal_machine_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.configuration_seed_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.configuration_seed_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_configuration_seed()) {
    _this->_impl_.configuration_seed_.Set(from._internal_configuration_seed(), 
      _this->GetArenaForAllocation());
  }
  _impl_.directory_api_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.directory_api_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_directory_api_id()) {
    _this->_impl_.directory_api_id_.Set(from._internal_directory_api_id(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.enrollment_type_ = from._impl_.enrollment_type_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceRegisterResponse)
}

inline void DeviceRegisterResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_affiliation_ids_){arena}
    , decltype(_impl_.device_management_token_){}
    , decltype(_impl_.machine_name_){}
    , decltype(_impl_.configuration_seed_){}
    , decltype(_impl_.directory_api_id_){}
    , decltype(_impl_.enrollment_type_){0}
  };
  _impl_.device_management_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_management_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.machine_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.configuration_seed_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.configuration_seed_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.directory_api_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.directory_api_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceRegisterResponse::~DeviceRegisterResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceRegisterResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceRegisterResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_affiliation_ids_.~RepeatedPtrField();
  _impl_.device_management_token_.Destroy();
  _impl_.machine_name_.Destroy();
  _impl_.configuration_seed_.Destroy();
  _impl_.directory_api_id_.Destroy();
}

void DeviceRegisterResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceRegisterResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceRegisterResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_affiliation_ids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.device_management_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.machine_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.configuration_seed_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.directory_api_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.enrollment_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceRegisterResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string device_management_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_management_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string machine_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_machine_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceRegisterResponse.DeviceMode enrollment_type = 3 [default = ENTERPRISE];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceRegisterResponse_DeviceMode_IsValid(val))) {
            _internal_set_enrollment_type(static_cast<::enterprise_management::DeviceRegisterResponse_DeviceMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string configuration_seed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_configuration_seed();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string user_affiliation_ids = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_user_affiliation_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string directory_api_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_directory_api_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceRegisterResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceRegisterResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string device_management_token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_management_token(), target);
  }

  // optional string machine_name = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_machine_name(), target);
  }

  // optional .enterprise_management.DeviceRegisterResponse.DeviceMode enrollment_type = 3 [default = ENTERPRISE];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_enrollment_type(), target);
  }

  // optional string configuration_seed = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_configuration_seed(), target);
  }

  // repeated string user_affiliation_ids = 5;
  for (int i = 0, n = this->_internal_user_affiliation_ids_size(); i < n; i++) {
    const auto& s = this->_internal_user_affiliation_ids(i);
    target = stream->WriteString(5, s, target);
  }

  // optional string directory_api_id = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_directory_api_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceRegisterResponse)
  return target;
}

size_t DeviceRegisterResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceRegisterResponse)
  size_t total_size = 0;

  // required string device_management_token = 1;
  if (_internal_has_device_management_token()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_device_management_token());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string user_affiliation_ids = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.user_affiliation_ids_.size());
  for (int i = 0, n = _impl_.user_affiliation_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.user_affiliation_ids_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional string machine_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_machine_name());
    }

    // optional string configuration_seed = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_configuration_seed());
    }

    // optional string directory_api_id = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_directory_api_id());
    }

    // optional .enterprise_management.DeviceRegisterResponse.DeviceMode enrollment_type = 3 [default = ENTERPRISE];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_enrollment_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceRegisterResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceRegisterResponse*>(
      &from));
}

void DeviceRegisterResponse::MergeFrom(const DeviceRegisterResponse& from) {
  DeviceRegisterResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceRegisterResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.user_affiliation_ids_.MergeFrom(from._impl_.user_affiliation_ids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_device_management_token(from._internal_device_management_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_machine_name(from._internal_machine_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_configuration_seed(from._internal_configuration_seed());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_directory_api_id(from._internal_directory_api_id());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.enrollment_type_ = from._impl_.enrollment_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceRegisterResponse::CopyFrom(const DeviceRegisterResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceRegisterResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceRegisterResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void DeviceRegisterResponse::InternalSwap(DeviceRegisterResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.user_affiliation_ids_.InternalSwap(&other->_impl_.user_affiliation_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_management_token_, lhs_arena,
      &other->_impl_.device_management_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_name_, lhs_arena,
      &other->_impl_.machine_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.configuration_seed_, lhs_arena,
      &other->_impl_.configuration_seed_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.directory_api_id_, lhs_arena,
      &other->_impl_.directory_api_id_, rhs_arena
  );
  swap(_impl_.enrollment_type_, other->_impl_.enrollment_type_);
}

std::string DeviceRegisterResponse::GetTypeName() const {
  return "enterprise_management.DeviceRegisterResponse";
}


// ===================================================================

class DeviceUnregisterRequest::_Internal {
 public:
};

DeviceUnregisterRequest::DeviceUnregisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceUnregisterRequest)
}
DeviceUnregisterRequest::DeviceUnregisterRequest(const DeviceUnregisterRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceUnregisterRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceUnregisterRequest)
}

inline void DeviceUnregisterRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

DeviceUnregisterRequest::~DeviceUnregisterRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceUnregisterRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceUnregisterRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceUnregisterRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceUnregisterRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceUnregisterRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* DeviceUnregisterRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceUnregisterRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceUnregisterRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceUnregisterRequest)
  return target;
}

size_t DeviceUnregisterRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceUnregisterRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceUnregisterRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceUnregisterRequest*>(
      &from));
}

void DeviceUnregisterRequest::MergeFrom(const DeviceUnregisterRequest& from) {
  DeviceUnregisterRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceUnregisterRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceUnregisterRequest::CopyFrom(const DeviceUnregisterRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceUnregisterRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceUnregisterRequest::IsInitialized() const {
  return true;
}

void DeviceUnregisterRequest::InternalSwap(DeviceUnregisterRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string DeviceUnregisterRequest::GetTypeName() const {
  return "enterprise_management.DeviceUnregisterRequest";
}


// ===================================================================

class DeviceUnregisterResponse::_Internal {
 public:
};

DeviceUnregisterResponse::DeviceUnregisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceUnregisterResponse)
}
DeviceUnregisterResponse::DeviceUnregisterResponse(const DeviceUnregisterResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceUnregisterResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceUnregisterResponse)
}

inline void DeviceUnregisterResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

DeviceUnregisterResponse::~DeviceUnregisterResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceUnregisterResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceUnregisterResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceUnregisterResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceUnregisterResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceUnregisterResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* DeviceUnregisterResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceUnregisterResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceUnregisterResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceUnregisterResponse)
  return target;
}

size_t DeviceUnregisterResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceUnregisterResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceUnregisterResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceUnregisterResponse*>(
      &from));
}

void DeviceUnregisterResponse::MergeFrom(const DeviceUnregisterResponse& from) {
  DeviceUnregisterResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceUnregisterResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceUnregisterResponse::CopyFrom(const DeviceUnregisterResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceUnregisterResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceUnregisterResponse::IsInitialized() const {
  return true;
}

void DeviceUnregisterResponse::InternalSwap(DeviceUnregisterResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string DeviceUnregisterResponse::GetTypeName() const {
  return "enterprise_management.DeviceUnregisterResponse";
}


// ===================================================================

class DeviceCertUploadRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceCertUploadRequest>()._impl_._has_bits_);
  static void set_has_device_certificate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_certificate_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_enrollment_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DeviceCertUploadRequest::DeviceCertUploadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceCertUploadRequest)
}
DeviceCertUploadRequest::DeviceCertUploadRequest(const DeviceCertUploadRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceCertUploadRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_certificate_){}
    , decltype(_impl_.enrollment_id_){}
    , decltype(_impl_.certificate_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.device_certificate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_certificate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_certificate()) {
    _this->_impl_.device_certificate_.Set(from._internal_device_certificate(), 
      _this->GetArenaForAllocation());
  }
  _impl_.enrollment_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.enrollment_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_enrollment_id()) {
    _this->_impl_.enrollment_id_.Set(from._internal_enrollment_id(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.certificate_type_ = from._impl_.certificate_type_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceCertUploadRequest)
}

inline void DeviceCertUploadRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_certificate_){}
    , decltype(_impl_.enrollment_id_){}
    , decltype(_impl_.certificate_type_){0}
  };
  _impl_.device_certificate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_certificate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.enrollment_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.enrollment_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceCertUploadRequest::~DeviceCertUploadRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceCertUploadRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceCertUploadRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.device_certificate_.Destroy();
  _impl_.enrollment_id_.Destroy();
}

void DeviceCertUploadRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceCertUploadRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceCertUploadRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.device_certificate_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.enrollment_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.certificate_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceCertUploadRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes device_certificate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_certificate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceCertUploadRequest.CertificateType certificate_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceCertUploadRequest_CertificateType_IsValid(val))) {
            _internal_set_certificate_type(static_cast<::enterprise_management::DeviceCertUploadRequest_CertificateType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes enrollment_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_enrollment_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceCertUploadRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceCertUploadRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes device_certificate = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_device_certificate(), target);
  }

  // optional .enterprise_management.DeviceCertUploadRequest.CertificateType certificate_type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_certificate_type(), target);
  }

  // optional bytes enrollment_id = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_enrollment_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceCertUploadRequest)
  return target;
}

size_t DeviceCertUploadRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceCertUploadRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes device_certificate = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_device_certificate());
    }

    // optional bytes enrollment_id = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_enrollment_id());
    }

    // optional .enterprise_management.DeviceCertUploadRequest.CertificateType certificate_type = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_certificate_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceCertUploadRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceCertUploadRequest*>(
      &from));
}

void DeviceCertUploadRequest::MergeFrom(const DeviceCertUploadRequest& from) {
  DeviceCertUploadRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceCertUploadRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_device_certificate(from._internal_device_certificate());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_enrollment_id(from._internal_enrollment_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.certificate_type_ = from._impl_.certificate_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceCertUploadRequest::CopyFrom(const DeviceCertUploadRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceCertUploadRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceCertUploadRequest::IsInitialized() const {
  return true;
}

void DeviceCertUploadRequest::InternalSwap(DeviceCertUploadRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_certificate_, lhs_arena,
      &other->_impl_.device_certificate_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.enrollment_id_, lhs_arena,
      &other->_impl_.enrollment_id_, rhs_arena
  );
  swap(_impl_.certificate_type_, other->_impl_.certificate_type_);
}

std::string DeviceCertUploadRequest::GetTypeName() const {
  return "enterprise_management.DeviceCertUploadRequest";
}


// ===================================================================

class DeviceCertUploadResponse::_Internal {
 public:
};

DeviceCertUploadResponse::DeviceCertUploadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceCertUploadResponse)
}
DeviceCertUploadResponse::DeviceCertUploadResponse(const DeviceCertUploadResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceCertUploadResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceCertUploadResponse)
}

inline void DeviceCertUploadResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

DeviceCertUploadResponse::~DeviceCertUploadResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceCertUploadResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceCertUploadResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceCertUploadResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceCertUploadResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceCertUploadResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* DeviceCertUploadResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceCertUploadResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceCertUploadResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceCertUploadResponse)
  return target;
}

size_t DeviceCertUploadResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceCertUploadResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceCertUploadResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceCertUploadResponse*>(
      &from));
}

void DeviceCertUploadResponse::MergeFrom(const DeviceCertUploadResponse& from) {
  DeviceCertUploadResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceCertUploadResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceCertUploadResponse::CopyFrom(const DeviceCertUploadResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceCertUploadResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceCertUploadResponse::IsInitialized() const {
  return true;
}

void DeviceCertUploadResponse::InternalSwap(DeviceCertUploadResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string DeviceCertUploadResponse::GetTypeName() const {
  return "enterprise_management.DeviceCertUploadResponse";
}


// ===================================================================

class DeviceServiceApiAccessRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceServiceApiAccessRequest>()._impl_._has_bits_);
  static void set_has_oauth2_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_device_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DeviceServiceApiAccessRequest::DeviceServiceApiAccessRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceServiceApiAccessRequest)
}
DeviceServiceApiAccessRequest::DeviceServiceApiAccessRequest(const DeviceServiceApiAccessRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceServiceApiAccessRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.auth_scopes_){from._impl_.auth_scopes_}
    , decltype(_impl_.oauth2_client_id_){}
    , decltype(_impl_.device_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.oauth2_client_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.oauth2_client_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_oauth2_client_id()) {
    _this->_impl_.oauth2_client_id_.Set(from._internal_oauth2_client_id(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.device_type_ = from._impl_.device_type_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceServiceApiAccessRequest)
}

inline void DeviceServiceApiAccessRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.auth_scopes_){arena}
    , decltype(_impl_.oauth2_client_id_){}
    , decltype(_impl_.device_type_){0}
  };
  _impl_.oauth2_client_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.oauth2_client_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceServiceApiAccessRequest::~DeviceServiceApiAccessRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceServiceApiAccessRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceServiceApiAccessRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.auth_scopes_.~RepeatedPtrField();
  _impl_.oauth2_client_id_.Destroy();
}

void DeviceServiceApiAccessRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceServiceApiAccessRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceServiceApiAccessRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.auth_scopes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.oauth2_client_id_.ClearNonDefaultToEmpty();
  }
  _impl_.device_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceServiceApiAccessRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string auth_scopes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_auth_scopes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string oauth2_client_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_oauth2_client_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceServiceApiAccessRequest.DeviceType device_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceServiceApiAccessRequest_DeviceType_IsValid(val))) {
            _internal_set_device_type(static_cast<::enterprise_management::DeviceServiceApiAccessRequest_DeviceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceServiceApiAccessRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceServiceApiAccessRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string auth_scopes = 1;
  for (int i = 0, n = this->_internal_auth_scopes_size(); i < n; i++) {
    const auto& s = this->_internal_auth_scopes(i);
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string oauth2_client_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_oauth2_client_id(), target);
  }

  // optional .enterprise_management.DeviceServiceApiAccessRequest.DeviceType device_type = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_device_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceServiceApiAccessRequest)
  return target;
}

size_t DeviceServiceApiAccessRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceServiceApiAccessRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string auth_scopes = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.auth_scopes_.size());
  for (int i = 0, n = _impl_.auth_scopes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.auth_scopes_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string oauth2_client_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_oauth2_client_id());
    }

    // optional .enterprise_management.DeviceServiceApiAccessRequest.DeviceType device_type = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_device_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceServiceApiAccessRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceServiceApiAccessRequest*>(
      &from));
}

void DeviceServiceApiAccessRequest::MergeFrom(const DeviceServiceApiAccessRequest& from) {
  DeviceServiceApiAccessRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceServiceApiAccessRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.auth_scopes_.MergeFrom(from._impl_.auth_scopes_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_oauth2_client_id(from._internal_oauth2_client_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.device_type_ = from._impl_.device_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceServiceApiAccessRequest::CopyFrom(const DeviceServiceApiAccessRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceServiceApiAccessRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceServiceApiAccessRequest::IsInitialized() const {
  return true;
}

void DeviceServiceApiAccessRequest::InternalSwap(DeviceServiceApiAccessRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.auth_scopes_.InternalSwap(&other->_impl_.auth_scopes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.oauth2_client_id_, lhs_arena,
      &other->_impl_.oauth2_client_id_, rhs_arena
  );
  swap(_impl_.device_type_, other->_impl_.device_type_);
}

std::string DeviceServiceApiAccessRequest::GetTypeName() const {
  return "enterprise_management.DeviceServiceApiAccessRequest";
}


// ===================================================================

class DeviceServiceApiAccessResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceServiceApiAccessResponse>()._impl_._has_bits_);
  static void set_has_auth_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceServiceApiAccessResponse::DeviceServiceApiAccessResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceServiceApiAccessResponse)
}
DeviceServiceApiAccessResponse::DeviceServiceApiAccessResponse(const DeviceServiceApiAccessResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceServiceApiAccessResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.auth_code_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.auth_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_auth_code()) {
    _this->_impl_.auth_code_.Set(from._internal_auth_code(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceServiceApiAccessResponse)
}

inline void DeviceServiceApiAccessResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.auth_code_){}
  };
  _impl_.auth_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceServiceApiAccessResponse::~DeviceServiceApiAccessResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceServiceApiAccessResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceServiceApiAccessResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.auth_code_.Destroy();
}

void DeviceServiceApiAccessResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceServiceApiAccessResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceServiceApiAccessResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.auth_code_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceServiceApiAccessResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string auth_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_auth_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceServiceApiAccessResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceServiceApiAccessResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string auth_code = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_auth_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceServiceApiAccessResponse)
  return target;
}

size_t DeviceServiceApiAccessResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceServiceApiAccessResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string auth_code = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_auth_code());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceServiceApiAccessResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceServiceApiAccessResponse*>(
      &from));
}

void DeviceServiceApiAccessResponse::MergeFrom(const DeviceServiceApiAccessResponse& from) {
  DeviceServiceApiAccessResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceServiceApiAccessResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_auth_code()) {
    _this->_internal_set_auth_code(from._internal_auth_code());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceServiceApiAccessResponse::CopyFrom(const DeviceServiceApiAccessResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceServiceApiAccessResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceServiceApiAccessResponse::IsInitialized() const {
  return true;
}

void DeviceServiceApiAccessResponse::InternalSwap(DeviceServiceApiAccessResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.auth_code_, lhs_arena,
      &other->_impl_.auth_code_, rhs_arena
  );
}

std::string DeviceServiceApiAccessResponse::GetTypeName() const {
  return "enterprise_management.DeviceServiceApiAccessResponse";
}


// ===================================================================

class BrowserDeviceIdentifier::_Internal {
 public:
  using HasBits = decltype(std::declval<BrowserDeviceIdentifier>()._impl_._has_bits_);
  static void set_has_computer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_serial_number(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BrowserDeviceIdentifier::BrowserDeviceIdentifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.BrowserDeviceIdentifier)
}
BrowserDeviceIdentifier::BrowserDeviceIdentifier(const BrowserDeviceIdentifier& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BrowserDeviceIdentifier* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.computer_name_){}
    , decltype(_impl_.serial_number_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.computer_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.computer_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_computer_name()) {
    _this->_impl_.computer_name_.Set(from._internal_computer_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.serial_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serial_number()) {
    _this->_impl_.serial_number_.Set(from._internal_serial_number(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.BrowserDeviceIdentifier)
}

inline void BrowserDeviceIdentifier::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.computer_name_){}
    , decltype(_impl_.serial_number_){}
  };
  _impl_.computer_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.computer_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.serial_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BrowserDeviceIdentifier::~BrowserDeviceIdentifier() {
  // @@protoc_insertion_point(destructor:enterprise_management.BrowserDeviceIdentifier)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BrowserDeviceIdentifier::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.computer_name_.Destroy();
  _impl_.serial_number_.Destroy();
}

void BrowserDeviceIdentifier::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BrowserDeviceIdentifier::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.BrowserDeviceIdentifier)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.computer_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.serial_number_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BrowserDeviceIdentifier::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string computer_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_computer_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string serial_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_serial_number();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BrowserDeviceIdentifier::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.BrowserDeviceIdentifier)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string computer_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_computer_name(), target);
  }

  // optional string serial_number = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_serial_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.BrowserDeviceIdentifier)
  return target;
}

size_t BrowserDeviceIdentifier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.BrowserDeviceIdentifier)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string computer_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_computer_name());
    }

    // optional string serial_number = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_serial_number());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BrowserDeviceIdentifier::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BrowserDeviceIdentifier*>(
      &from));
}

void BrowserDeviceIdentifier::MergeFrom(const BrowserDeviceIdentifier& from) {
  BrowserDeviceIdentifier* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.BrowserDeviceIdentifier)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_computer_name(from._internal_computer_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_serial_number(from._internal_serial_number());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BrowserDeviceIdentifier::CopyFrom(const BrowserDeviceIdentifier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.BrowserDeviceIdentifier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BrowserDeviceIdentifier::IsInitialized() const {
  return true;
}

void BrowserDeviceIdentifier::InternalSwap(BrowserDeviceIdentifier* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.computer_name_, lhs_arena,
      &other->_impl_.computer_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.serial_number_, lhs_arena,
      &other->_impl_.serial_number_, rhs_arena
  );
}

std::string BrowserDeviceIdentifier::GetTypeName() const {
  return "enterprise_management.BrowserDeviceIdentifier";
}


// ===================================================================

class PolicyFetchRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<PolicyFetchRequest>()._impl_._has_bits_);
  static void set_has_policy_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_signature_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_public_key_version(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_settings_entity_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_invalidation_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_invalidation_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_verification_key_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_policy_invalidation_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_invalidation_topics_only(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_device_dm_token(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::enterprise_management::BrowserDeviceIdentifier& browser_device_identifier(const PolicyFetchRequest* msg);
  static void set_has_browser_device_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::enterprise_management::BrowserDeviceIdentifier&
PolicyFetchRequest::_Internal::browser_device_identifier(const PolicyFetchRequest* msg) {
  return *msg->_impl_.browser_device_identifier_;
}
PolicyFetchRequest::PolicyFetchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PolicyFetchRequest)
}
PolicyFetchRequest::PolicyFetchRequest(const PolicyFetchRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PolicyFetchRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.policy_type_){}
    , decltype(_impl_.settings_entity_id_){}
    , decltype(_impl_.invalidation_payload_){}
    , decltype(_impl_.verification_key_hash_){}
    , decltype(_impl_.policy_invalidation_info_){}
    , decltype(_impl_.device_dm_token_){}
    , decltype(_impl_.browser_device_identifier_){nullptr}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.signature_type_){}
    , decltype(_impl_.public_key_version_){}
    , decltype(_impl_.invalidation_version_){}
    , decltype(_impl_.invalidation_topics_only_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.policy_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_policy_type()) {
    _this->_impl_.policy_type_.Set(from._internal_policy_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.settings_entity_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.settings_entity_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_settings_entity_id()) {
    _this->_impl_.settings_entity_id_.Set(from._internal_settings_entity_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.invalidation_payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.invalidation_payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_invalidation_payload()) {
    _this->_impl_.invalidation_payload_.Set(from._internal_invalidation_payload(), 
      _this->GetArenaForAllocation());
  }
  _impl_.verification_key_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.verification_key_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_verification_key_hash()) {
    _this->_impl_.verification_key_hash_.Set(from._internal_verification_key_hash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.policy_invalidation_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_invalidation_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_policy_invalidation_info()) {
    _this->_impl_.policy_invalidation_info_.Set(from._internal_policy_invalidation_info(), 
      _this->GetArenaForAllocation());
  }
  _impl_.device_dm_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_dm_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_dm_token()) {
    _this->_impl_.device_dm_token_.Set(from._internal_device_dm_token(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_browser_device_identifier()) {
    _this->_impl_.browser_device_identifier_ = new ::enterprise_management::BrowserDeviceIdentifier(*from._impl_.browser_device_identifier_);
  }
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.invalidation_topics_only_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.invalidation_topics_only_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PolicyFetchRequest)
}

inline void PolicyFetchRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.policy_type_){}
    , decltype(_impl_.settings_entity_id_){}
    , decltype(_impl_.invalidation_payload_){}
    , decltype(_impl_.verification_key_hash_){}
    , decltype(_impl_.policy_invalidation_info_){}
    , decltype(_impl_.device_dm_token_){}
    , decltype(_impl_.browser_device_identifier_){nullptr}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , decltype(_impl_.signature_type_){0}
    , decltype(_impl_.public_key_version_){0}
    , decltype(_impl_.invalidation_version_){int64_t{0}}
    , decltype(_impl_.invalidation_topics_only_){false}
  };
  _impl_.policy_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.settings_entity_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.settings_entity_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.invalidation_payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.invalidation_payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.verification_key_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.verification_key_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.policy_invalidation_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_invalidation_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.device_dm_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_dm_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PolicyFetchRequest::~PolicyFetchRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.PolicyFetchRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PolicyFetchRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.policy_type_.Destroy();
  _impl_.settings_entity_id_.Destroy();
  _impl_.invalidation_payload_.Destroy();
  _impl_.verification_key_hash_.Destroy();
  _impl_.policy_invalidation_info_.Destroy();
  _impl_.device_dm_token_.Destroy();
  if (this != internal_default_instance()) delete _impl_.browser_device_identifier_;
}

void PolicyFetchRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PolicyFetchRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PolicyFetchRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.policy_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.settings_entity_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.invalidation_payload_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.verification_key_hash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.policy_invalidation_info_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.device_dm_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.browser_device_identifier_ != nullptr);
      _impl_.browser_device_identifier_->Clear();
    }
  }
  _impl_.timestamp_ = int64_t{0};
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.signature_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.invalidation_topics_only_) -
        reinterpret_cast<char*>(&_impl_.signature_type_)) + sizeof(_impl_.invalidation_topics_only_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PolicyFetchRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string policy_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_policy_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyFetchRequest.SignatureType signature_type = 3 [default = NONE];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::PolicyFetchRequest_SignatureType_IsValid(val))) {
            _internal_set_signature_type(static_cast<::enterprise_management::PolicyFetchRequest_SignatureType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 public_key_version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_public_key_version(&has_bits);
          _impl_.public_key_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string settings_entity_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_settings_entity_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 invalidation_version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_invalidation_version(&has_bits);
          _impl_.invalidation_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes invalidation_payload = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_invalidation_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string verification_key_hash = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_verification_key_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string policy_invalidation_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_policy_invalidation_info();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool invalidation_topics_only = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_invalidation_topics_only(&has_bits);
          _impl_.invalidation_topics_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string device_dm_token = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_device_dm_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BrowserDeviceIdentifier browser_device_identifier = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_browser_device_identifier(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PolicyFetchRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PolicyFetchRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string policy_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_policy_type(), target);
  }

  // optional int64 timestamp = 2;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_timestamp(), target);
  }

  // optional .enterprise_management.PolicyFetchRequest.SignatureType signature_type = 3 [default = NONE];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_signature_type(), target);
  }

  // optional int32 public_key_version = 4;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_public_key_version(), target);
  }

  // optional string settings_entity_id = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_settings_entity_id(), target);
  }

  // optional int64 invalidation_version = 7;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_invalidation_version(), target);
  }

  // optional bytes invalidation_payload = 8;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_invalidation_payload(), target);
  }

  // optional string verification_key_hash = 9;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_verification_key_hash(), target);
  }

  // optional string policy_invalidation_info = 10;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_policy_invalidation_info(), target);
  }

  // optional bool invalidation_topics_only = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_invalidation_topics_only(), target);
  }

  // optional string device_dm_token = 12;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_device_dm_token(), target);
  }

  // optional .enterprise_management.BrowserDeviceIdentifier browser_device_identifier = 13;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::browser_device_identifier(this),
        _Internal::browser_device_identifier(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PolicyFetchRequest)
  return target;
}

size_t PolicyFetchRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PolicyFetchRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string policy_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_policy_type());
    }

    // optional string settings_entity_id = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_settings_entity_id());
    }

    // optional bytes invalidation_payload = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_invalidation_payload());
    }

    // optional string verification_key_hash = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_verification_key_hash());
    }

    // optional string policy_invalidation_info = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_policy_invalidation_info());
    }

    // optional string device_dm_token = 12;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_dm_token());
    }

    // optional .enterprise_management.BrowserDeviceIdentifier browser_device_identifier = 13;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.browser_device_identifier_);
    }

    // optional int64 timestamp = 2;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional .enterprise_management.PolicyFetchRequest.SignatureType signature_type = 3 [default = NONE];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_signature_type());
    }

    // optional int32 public_key_version = 4;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_public_key_version());
    }

    // optional int64 invalidation_version = 7;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_invalidation_version());
    }

    // optional bool invalidation_topics_only = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PolicyFetchRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PolicyFetchRequest*>(
      &from));
}

void PolicyFetchRequest::MergeFrom(const PolicyFetchRequest& from) {
  PolicyFetchRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PolicyFetchRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_policy_type(from._internal_policy_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_settings_entity_id(from._internal_settings_entity_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_invalidation_payload(from._internal_invalidation_payload());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_verification_key_hash(from._internal_verification_key_hash());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_policy_invalidation_info(from._internal_policy_invalidation_info());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_device_dm_token(from._internal_device_dm_token());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_browser_device_identifier()->::enterprise_management::BrowserDeviceIdentifier::MergeFrom(
          from._internal_browser_device_identifier());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.signature_type_ = from._impl_.signature_type_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.public_key_version_ = from._impl_.public_key_version_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.invalidation_version_ = from._impl_.invalidation_version_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.invalidation_topics_only_ = from._impl_.invalidation_topics_only_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PolicyFetchRequest::CopyFrom(const PolicyFetchRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PolicyFetchRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PolicyFetchRequest::IsInitialized() const {
  return true;
}

void PolicyFetchRequest::InternalSwap(PolicyFetchRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.policy_type_, lhs_arena,
      &other->_impl_.policy_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.settings_entity_id_, lhs_arena,
      &other->_impl_.settings_entity_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.invalidation_payload_, lhs_arena,
      &other->_impl_.invalidation_payload_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.verification_key_hash_, lhs_arena,
      &other->_impl_.verification_key_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.policy_invalidation_info_, lhs_arena,
      &other->_impl_.policy_invalidation_info_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_dm_token_, lhs_arena,
      &other->_impl_.device_dm_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PolicyFetchRequest, _impl_.invalidation_topics_only_)
      + sizeof(PolicyFetchRequest::_impl_.invalidation_topics_only_)
      - PROTOBUF_FIELD_OFFSET(PolicyFetchRequest, _impl_.browser_device_identifier_)>(
          reinterpret_cast<char*>(&_impl_.browser_device_identifier_),
          reinterpret_cast<char*>(&other->_impl_.browser_device_identifier_));
}

std::string PolicyFetchRequest::GetTypeName() const {
  return "enterprise_management.PolicyFetchRequest";
}


// ===================================================================

class DisabledState::_Internal {
 public:
  using HasBits = decltype(std::declval<DisabledState>()._impl_._has_bits_);
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DisabledState::DisabledState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DisabledState)
}
DisabledState::DisabledState(const DisabledState& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DisabledState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DisabledState)
}

inline void DisabledState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DisabledState::~DisabledState() {
  // @@protoc_insertion_point(destructor:enterprise_management.DisabledState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DisabledState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void DisabledState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DisabledState::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DisabledState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DisabledState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DisabledState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DisabledState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string message = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DisabledState)
  return target;
}

size_t DisabledState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DisabledState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DisabledState::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DisabledState*>(
      &from));
}

void DisabledState::MergeFrom(const DisabledState& from) {
  DisabledState* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DisabledState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_message()) {
    _this->_internal_set_message(from._internal_message());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DisabledState::CopyFrom(const DisabledState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DisabledState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DisabledState::IsInitialized() const {
  return true;
}

void DisabledState::InternalSwap(DisabledState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
}

std::string DisabledState::GetTypeName() const {
  return "enterprise_management.DisabledState";
}


// ===================================================================

class DeviceState::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceState>()._impl_._has_bits_);
  static void set_has_device_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::enterprise_management::DisabledState& disabled_state(const DeviceState* msg);
  static void set_has_disabled_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::enterprise_management::DisabledState&
DeviceState::_Internal::disabled_state(const DeviceState* msg) {
  return *msg->_impl_.disabled_state_;
}
DeviceState::DeviceState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceState)
}
DeviceState::DeviceState(const DeviceState& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.disabled_state_){nullptr}
    , decltype(_impl_.device_mode_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_disabled_state()) {
    _this->_impl_.disabled_state_ = new ::enterprise_management::DisabledState(*from._impl_.disabled_state_);
  }
  _this->_impl_.device_mode_ = from._impl_.device_mode_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceState)
}

inline void DeviceState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.disabled_state_){nullptr}
    , decltype(_impl_.device_mode_){0}
  };
}

DeviceState::~DeviceState() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.disabled_state_;
}

void DeviceState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceState::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.disabled_state_ != nullptr);
    _impl_.disabled_state_->Clear();
  }
  _impl_.device_mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DeviceState.DeviceMode device_mode = 1 [default = DEVICE_MODE_NORMAL];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceState_DeviceMode_IsValid(val))) {
            _internal_set_device_mode(static_cast<::enterprise_management::DeviceState_DeviceMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DisabledState disabled_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_disabled_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DeviceState.DeviceMode device_mode = 1 [default = DEVICE_MODE_NORMAL];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_device_mode(), target);
  }

  // optional .enterprise_management.DisabledState disabled_state = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::disabled_state(this),
        _Internal::disabled_state(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceState)
  return target;
}

size_t DeviceState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .enterprise_management.DisabledState disabled_state = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.disabled_state_);
    }

    // optional .enterprise_management.DeviceState.DeviceMode device_mode = 1 [default = DEVICE_MODE_NORMAL];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_device_mode());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceState::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceState*>(
      &from));
}

void DeviceState::MergeFrom(const DeviceState& from) {
  DeviceState* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_disabled_state()->::enterprise_management::DisabledState::MergeFrom(
          from._internal_disabled_state());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.device_mode_ = from._impl_.device_mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceState::CopyFrom(const DeviceState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceState::IsInitialized() const {
  return true;
}

void DeviceState::InternalSwap(DeviceState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceState, _impl_.device_mode_)
      + sizeof(DeviceState::_impl_.device_mode_)
      - PROTOBUF_FIELD_OFFSET(DeviceState, _impl_.disabled_state_)>(
          reinterpret_cast<char*>(&_impl_.disabled_state_),
          reinterpret_cast<char*>(&other->_impl_.disabled_state_));
}

std::string DeviceState::GetTypeName() const {
  return "enterprise_management.DeviceState";
}


// ===================================================================

class CustomerLogo::_Internal {
 public:
  using HasBits = decltype(std::declval<CustomerLogo>()._impl_._has_bits_);
  static void set_has_logo_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CustomerLogo::CustomerLogo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CustomerLogo)
}
CustomerLogo::CustomerLogo(const CustomerLogo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CustomerLogo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.logo_url_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_logo_url()) {
    _this->_impl_.logo_url_.Set(from._internal_logo_url(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CustomerLogo)
}

inline void CustomerLogo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.logo_url_){}
  };
  _impl_.logo_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.logo_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CustomerLogo::~CustomerLogo() {
  // @@protoc_insertion_point(destructor:enterprise_management.CustomerLogo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CustomerLogo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.logo_url_.Destroy();
}

void CustomerLogo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CustomerLogo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CustomerLogo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.logo_url_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CustomerLogo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string logo_url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_logo_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CustomerLogo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CustomerLogo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string logo_url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_logo_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CustomerLogo)
  return target;
}

size_t CustomerLogo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CustomerLogo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string logo_url = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_logo_url());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CustomerLogo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CustomerLogo*>(
      &from));
}

void CustomerLogo::MergeFrom(const CustomerLogo& from) {
  CustomerLogo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CustomerLogo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_logo_url()) {
    _this->_internal_set_logo_url(from._internal_logo_url());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CustomerLogo::CopyFrom(const CustomerLogo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CustomerLogo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CustomerLogo::IsInitialized() const {
  return true;
}

void CustomerLogo::InternalSwap(CustomerLogo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.logo_url_, lhs_arena,
      &other->_impl_.logo_url_, rhs_arena
  );
}

std::string CustomerLogo::GetTypeName() const {
  return "enterprise_management.CustomerLogo";
}


// ===================================================================

class PolicyData::_Internal {
 public:
  using HasBits = decltype(std::declval<PolicyData>()._impl_._has_bits_);
  static void set_has_policy_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_request_token(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_policy_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_machine_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_public_key_version(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_username(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_settings_entity_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_service_account_identity(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_policy_token(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_management_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static const ::enterprise_management::DeviceState& device_state(const PolicyData* msg);
  static void set_has_device_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_annotated_location(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_annotated_asset_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_directory_api_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_display_domain(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_policy_invalidation_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_command_invalidation_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_enrollment_id_needed(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_gaia_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_market_segment(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static const ::enterprise_management::CustomerLogo& customer_logo(const PolicyData* msg);
  static void set_has_customer_logo(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_change_password_uri(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::enterprise_management::ClientActionRequired& client_action_required(const PolicyData* msg);
  static void set_has_client_action_required(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_obfuscated_customer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_metrics_log_segment(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_managed_by(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_sso_profile(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_license_sku(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
};

const ::enterprise_management::DeviceState&
PolicyData::_Internal::device_state(const PolicyData* msg) {
  return *msg->_impl_.device_state_;
}
const ::enterprise_management::CustomerLogo&
PolicyData::_Internal::customer_logo(const PolicyData* msg) {
  return *msg->_impl_.customer_logo_;
}
const ::enterprise_management::ClientActionRequired&
PolicyData::_Internal::client_action_required(const PolicyData* msg) {
  return *msg->_impl_.client_action_required_;
}
PolicyData::PolicyData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PolicyData)
}
PolicyData::PolicyData(const PolicyData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PolicyData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_affiliation_ids_){from._impl_.device_affiliation_ids_}
    , decltype(_impl_.user_affiliation_ids_){from._impl_.user_affiliation_ids_}
    , decltype(_impl_.policy_type_){}
    , decltype(_impl_.request_token_){}
    , decltype(_impl_.policy_value_){}
    , decltype(_impl_.machine_name_){}
    , decltype(_impl_.username_){}
    , decltype(_impl_.device_id_){}
    , decltype(_impl_.settings_entity_id_){}
    , decltype(_impl_.service_account_identity_){}
    , decltype(_impl_.policy_token_){}
    , decltype(_impl_.annotated_location_){}
    , decltype(_impl_.annotated_asset_id_){}
    , decltype(_impl_.directory_api_id_){}
    , decltype(_impl_.display_domain_){}
    , decltype(_impl_.policy_invalidation_topic_){}
    , decltype(_impl_.command_invalidation_topic_){}
    , decltype(_impl_.gaia_id_){}
    , decltype(_impl_.change_password_uri_){}
    , decltype(_impl_.obfuscated_customer_id_){}
    , decltype(_impl_.managed_by_){}
    , decltype(_impl_.sso_profile_){}
    , decltype(_impl_.license_sku_){}
    , decltype(_impl_.device_state_){nullptr}
    , decltype(_impl_.customer_logo_){nullptr}
    , decltype(_impl_.client_action_required_){nullptr}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.public_key_version_){}
    , decltype(_impl_.state_){}
    , decltype(_impl_.management_mode_){}
    , decltype(_impl_.enrollment_id_needed_){}
    , decltype(_impl_.market_segment_){}
    , decltype(_impl_.metrics_log_segment_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.policy_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_policy_type()) {
    _this->_impl_.policy_type_.Set(from._internal_policy_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.request_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.request_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_request_token()) {
    _this->_impl_.request_token_.Set(from._internal_request_token(), 
      _this->GetArenaForAllocation());
  }
  _impl_.policy_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_policy_value()) {
    _this->_impl_.policy_value_.Set(from._internal_policy_value(), 
      _this->GetArenaForAllocation());
  }
  _impl_.machine_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_machine_name()) {
    _this->_impl_.machine_name_.Set(from._internal_machine_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.username_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_username()) {
    _this->_impl_.username_.Set(from._internal_username(), 
      _this->GetArenaForAllocation());
  }
  _impl_.device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_id()) {
    _this->_impl_.device_id_.Set(from._internal_device_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.settings_entity_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.settings_entity_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_settings_entity_id()) {
    _this->_impl_.settings_entity_id_.Set(from._internal_settings_entity_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.service_account_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.service_account_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_service_account_identity()) {
    _this->_impl_.service_account_identity_.Set(from._internal_service_account_identity(), 
      _this->GetArenaForAllocation());
  }
  _impl_.policy_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_policy_token()) {
    _this->_impl_.policy_token_.Set(from._internal_policy_token(), 
      _this->GetArenaForAllocation());
  }
  _impl_.annotated_location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.annotated_location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_annotated_location()) {
    _this->_impl_.annotated_location_.Set(from._internal_annotated_location(), 
      _this->GetArenaForAllocation());
  }
  _impl_.annotated_asset_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.annotated_asset_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_annotated_asset_id()) {
    _this->_impl_.annotated_asset_id_.Set(from._internal_annotated_asset_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.directory_api_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.directory_api_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_directory_api_id()) {
    _this->_impl_.directory_api_id_.Set(from._internal_directory_api_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.display_domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_display_domain()) {
    _this->_impl_.display_domain_.Set(from._internal_display_domain(), 
      _this->GetArenaForAllocation());
  }
  _impl_.policy_invalidation_topic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_invalidation_topic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_policy_invalidation_topic()) {
    _this->_impl_.policy_invalidation_topic_.Set(from._internal_policy_invalidation_topic(), 
      _this->GetArenaForAllocation());
  }
  _impl_.command_invalidation_topic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.command_invalidation_topic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_command_invalidation_topic()) {
    _this->_impl_.command_invalidation_topic_.Set(from._internal_command_invalidation_topic(), 
      _this->GetArenaForAllocation());
  }
  _impl_.gaia_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gaia_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gaia_id()) {
    _this->_impl_.gaia_id_.Set(from._internal_gaia_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.change_password_uri_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.change_password_uri_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_change_password_uri()) {
    _this->_impl_.change_password_uri_.Set(from._internal_change_password_uri(), 
      _this->GetArenaForAllocation());
  }
  _impl_.obfuscated_customer_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obfuscated_customer_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_obfuscated_customer_id()) {
    _this->_impl_.obfuscated_customer_id_.Set(from._internal_obfuscated_customer_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.managed_by_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.managed_by_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_managed_by()) {
    _this->_impl_.managed_by_.Set(from._internal_managed_by(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sso_profile_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sso_profile_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sso_profile()) {
    _this->_impl_.sso_profile_.Set(from._internal_sso_profile(), 
      _this->GetArenaForAllocation());
  }
  _impl_.license_sku_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.license_sku_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_license_sku()) {
    _this->_impl_.license_sku_.Set(from._internal_license_sku(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_device_state()) {
    _this->_impl_.device_state_ = new ::enterprise_management::DeviceState(*from._impl_.device_state_);
  }
  if (from._internal_has_customer_logo()) {
    _this->_impl_.customer_logo_ = new ::enterprise_management::CustomerLogo(*from._impl_.customer_logo_);
  }
  if (from._internal_has_client_action_required()) {
    _this->_impl_.client_action_required_ = new ::enterprise_management::ClientActionRequired(*from._impl_.client_action_required_);
  }
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.metrics_log_segment_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.metrics_log_segment_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PolicyData)
}

inline void PolicyData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_affiliation_ids_){arena}
    , decltype(_impl_.user_affiliation_ids_){arena}
    , decltype(_impl_.policy_type_){}
    , decltype(_impl_.request_token_){}
    , decltype(_impl_.policy_value_){}
    , decltype(_impl_.machine_name_){}
    , decltype(_impl_.username_){}
    , decltype(_impl_.device_id_){}
    , decltype(_impl_.settings_entity_id_){}
    , decltype(_impl_.service_account_identity_){}
    , decltype(_impl_.policy_token_){}
    , decltype(_impl_.annotated_location_){}
    , decltype(_impl_.annotated_asset_id_){}
    , decltype(_impl_.directory_api_id_){}
    , decltype(_impl_.display_domain_){}
    , decltype(_impl_.policy_invalidation_topic_){}
    , decltype(_impl_.command_invalidation_topic_){}
    , decltype(_impl_.gaia_id_){}
    , decltype(_impl_.change_password_uri_){}
    , decltype(_impl_.obfuscated_customer_id_){}
    , decltype(_impl_.managed_by_){}
    , decltype(_impl_.sso_profile_){}
    , decltype(_impl_.license_sku_){}
    , decltype(_impl_.device_state_){nullptr}
    , decltype(_impl_.customer_logo_){nullptr}
    , decltype(_impl_.client_action_required_){nullptr}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , decltype(_impl_.public_key_version_){0}
    , decltype(_impl_.state_){0}
    , decltype(_impl_.management_mode_){0}
    , decltype(_impl_.enrollment_id_needed_){false}
    , decltype(_impl_.market_segment_){0}
    , decltype(_impl_.metrics_log_segment_){0}
  };
  _impl_.policy_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.request_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.request_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.policy_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.machine_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.username_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.settings_entity_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.settings_entity_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.service_account_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.service_account_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.policy_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.annotated_location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.annotated_location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.annotated_asset_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.annotated_asset_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.directory_api_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.directory_api_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.display_domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.policy_invalidation_topic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_invalidation_topic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.command_invalidation_topic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.command_invalidation_topic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gaia_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gaia_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.change_password_uri_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.change_password_uri_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.obfuscated_customer_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obfuscated_customer_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.managed_by_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.managed_by_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sso_profile_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sso_profile_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.license_sku_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.license_sku_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PolicyData::~PolicyData() {
  // @@protoc_insertion_point(destructor:enterprise_management.PolicyData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PolicyData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.device_affiliation_ids_.~RepeatedPtrField();
  _impl_.user_affiliation_ids_.~RepeatedPtrField();
  _impl_.policy_type_.Destroy();
  _impl_.request_token_.Destroy();
  _impl_.policy_value_.Destroy();
  _impl_.machine_name_.Destroy();
  _impl_.username_.Destroy();
  _impl_.device_id_.Destroy();
  _impl_.settings_entity_id_.Destroy();
  _impl_.service_account_identity_.Destroy();
  _impl_.policy_token_.Destroy();
  _impl_.annotated_location_.Destroy();
  _impl_.annotated_asset_id_.Destroy();
  _impl_.directory_api_id_.Destroy();
  _impl_.display_domain_.Destroy();
  _impl_.policy_invalidation_topic_.Destroy();
  _impl_.command_invalidation_topic_.Destroy();
  _impl_.gaia_id_.Destroy();
  _impl_.change_password_uri_.Destroy();
  _impl_.obfuscated_customer_id_.Destroy();
  _impl_.managed_by_.Destroy();
  _impl_.sso_profile_.Destroy();
  _impl_.license_sku_.Destroy();
  if (this != internal_default_instance()) delete _impl_.device_state_;
  if (this != internal_default_instance()) delete _impl_.customer_logo_;
  if (this != internal_default_instance()) delete _impl_.client_action_required_;
}

void PolicyData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PolicyData::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PolicyData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.device_affiliation_ids_.Clear();
  _impl_.user_affiliation_ids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.policy_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.request_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.policy_value_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.machine_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.username_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.device_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.settings_entity_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.service_account_identity_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _impl_.policy_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      _impl_.annotated_location_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000400u) {
      _impl_.annotated_asset_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000800u) {
      _impl_.directory_api_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00001000u) {
      _impl_.display_domain_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00002000u) {
      _impl_.policy_invalidation_topic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00004000u) {
      _impl_.command_invalidation_topic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00008000u) {
      _impl_.gaia_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _impl_.change_password_uri_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00020000u) {
      _impl_.obfuscated_customer_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00040000u) {
      _impl_.managed_by_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00080000u) {
      _impl_.sso_profile_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00100000u) {
      _impl_.license_sku_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00200000u) {
      GOOGLE_DCHECK(_impl_.device_state_ != nullptr);
      _impl_.device_state_->Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      GOOGLE_DCHECK(_impl_.customer_logo_ != nullptr);
      _impl_.customer_logo_->Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      GOOGLE_DCHECK(_impl_.client_action_required_ != nullptr);
      _impl_.client_action_required_->Clear();
    }
  }
  if (cached_has_bits & 0x7f000000u) {
    ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.metrics_log_segment_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.metrics_log_segment_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PolicyData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string policy_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_policy_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string request_token = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_request_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes policy_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_policy_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string machine_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_machine_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 public_key_version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_public_key_version(&has_bits);
          _impl_.public_key_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string username = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_username();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string device_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_device_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyData.AssociationState state = 9 [default = ACTIVE];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::PolicyData_AssociationState_IsValid(val))) {
            _internal_set_state(static_cast<::enterprise_management::PolicyData_AssociationState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string settings_entity_id = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_settings_entity_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string service_account_identity = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_service_account_identity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string policy_token = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_policy_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyData.ManagementMode management_mode = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::PolicyData_ManagementMode_IsValid(val))) {
            _internal_set_management_mode(static_cast<::enterprise_management::PolicyData_ManagementMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(16, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceState device_state = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string annotated_location = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_annotated_location();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string annotated_asset_id = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_annotated_asset_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string directory_api_id = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          auto str = _internal_mutable_directory_api_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string device_affiliation_ids = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_device_affiliation_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<186>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string user_affiliation_ids = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_user_affiliation_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<194>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string display_domain = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          auto str = _internal_mutable_display_domain();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string policy_invalidation_topic = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          auto str = _internal_mutable_policy_invalidation_topic();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string command_invalidation_topic = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          auto str = _internal_mutable_command_invalidation_topic();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enrollment_id_needed = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_enrollment_id_needed(&has_bits);
          _impl_.enrollment_id_needed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string gaia_id = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          auto str = _internal_mutable_gaia_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyData.MarketSegment market_segment = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::PolicyData_MarketSegment_IsValid(val))) {
            _internal_set_market_segment(static_cast<::enterprise_management::PolicyData_MarketSegment>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(30, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.CustomerLogo customer_logo = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_customer_logo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string change_password_uri = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          auto str = _internal_mutable_change_password_uri();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ClientActionRequired client_action_required = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_action_required(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string obfuscated_customer_id = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_obfuscated_customer_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyData.MetricsLogSegment metrics_log_segment = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::PolicyData_MetricsLogSegment_IsValid(val))) {
            _internal_set_metrics_log_segment(static_cast<::enterprise_management::PolicyData_MetricsLogSegment>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(35, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string managed_by = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_managed_by();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string sso_profile = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_sso_profile();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string license_sku = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_license_sku();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PolicyData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PolicyData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string policy_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_policy_type(), target);
  }

  // optional int64 timestamp = 2;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_timestamp(), target);
  }

  // optional string request_token = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_request_token(), target);
  }

  // optional bytes policy_value = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_policy_value(), target);
  }

  // optional string machine_name = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_machine_name(), target);
  }

  // optional int32 public_key_version = 6;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_public_key_version(), target);
  }

  // optional string username = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_username(), target);
  }

  // optional string device_id = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_device_id(), target);
  }

  // optional .enterprise_management.PolicyData.AssociationState state = 9 [default = ACTIVE];
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_state(), target);
  }

  // optional string settings_entity_id = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_settings_entity_id(), target);
  }

  // optional string service_account_identity = 12;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_service_account_identity(), target);
  }

  // optional string policy_token = 15;
  if (cached_has_bits & 0x00000100u) {
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_policy_token(), target);
  }

  // optional .enterprise_management.PolicyData.ManagementMode management_mode = 16;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      16, this->_internal_management_mode(), target);
  }

  // optional .enterprise_management.DeviceState device_state = 17;
  if (cached_has_bits & 0x00200000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::device_state(this),
        _Internal::device_state(this).GetCachedSize(), target, stream);
  }

  // optional string annotated_location = 20;
  if (cached_has_bits & 0x00000200u) {
    target = stream->WriteStringMaybeAliased(
        20, this->_internal_annotated_location(), target);
  }

  // optional string annotated_asset_id = 21;
  if (cached_has_bits & 0x00000400u) {
    target = stream->WriteStringMaybeAliased(
        21, this->_internal_annotated_asset_id(), target);
  }

  // optional string directory_api_id = 22;
  if (cached_has_bits & 0x00000800u) {
    target = stream->WriteStringMaybeAliased(
        22, this->_internal_directory_api_id(), target);
  }

  // repeated string device_affiliation_ids = 23;
  for (int i = 0, n = this->_internal_device_affiliation_ids_size(); i < n; i++) {
    const auto& s = this->_internal_device_affiliation_ids(i);
    target = stream->WriteString(23, s, target);
  }

  // repeated string user_affiliation_ids = 24;
  for (int i = 0, n = this->_internal_user_affiliation_ids_size(); i < n; i++) {
    const auto& s = this->_internal_user_affiliation_ids(i);
    target = stream->WriteString(24, s, target);
  }

  // optional string display_domain = 25;
  if (cached_has_bits & 0x00001000u) {
    target = stream->WriteStringMaybeAliased(
        25, this->_internal_display_domain(), target);
  }

  // optional string policy_invalidation_topic = 26;
  if (cached_has_bits & 0x00002000u) {
    target = stream->WriteStringMaybeAliased(
        26, this->_internal_policy_invalidation_topic(), target);
  }

  // optional string command_invalidation_topic = 27;
  if (cached_has_bits & 0x00004000u) {
    target = stream->WriteStringMaybeAliased(
        27, this->_internal_command_invalidation_topic(), target);
  }

  // optional bool enrollment_id_needed = 28;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(28, this->_internal_enrollment_id_needed(), target);
  }

  // optional string gaia_id = 29;
  if (cached_has_bits & 0x00008000u) {
    target = stream->WriteStringMaybeAliased(
        29, this->_internal_gaia_id(), target);
  }

  // optional .enterprise_management.PolicyData.MarketSegment market_segment = 30;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      30, this->_internal_market_segment(), target);
  }

  // optional .enterprise_management.CustomerLogo customer_logo = 31;
  if (cached_has_bits & 0x00400000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(31, _Internal::customer_logo(this),
        _Internal::customer_logo(this).GetCachedSize(), target, stream);
  }

  // optional string change_password_uri = 32;
  if (cached_has_bits & 0x00010000u) {
    target = stream->WriteStringMaybeAliased(
        32, this->_internal_change_password_uri(), target);
  }

  // optional .enterprise_management.ClientActionRequired client_action_required = 33;
  if (cached_has_bits & 0x00800000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(33, _Internal::client_action_required(this),
        _Internal::client_action_required(this).GetCachedSize(), target, stream);
  }

  // optional string obfuscated_customer_id = 34;
  if (cached_has_bits & 0x00020000u) {
    target = stream->WriteStringMaybeAliased(
        34, this->_internal_obfuscated_customer_id(), target);
  }

  // optional .enterprise_management.PolicyData.MetricsLogSegment metrics_log_segment = 35;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      35, this->_internal_metrics_log_segment(), target);
  }

  // optional string managed_by = 36;
  if (cached_has_bits & 0x00040000u) {
    target = stream->WriteStringMaybeAliased(
        36, this->_internal_managed_by(), target);
  }

  // optional string sso_profile = 37;
  if (cached_has_bits & 0x00080000u) {
    target = stream->WriteStringMaybeAliased(
        37, this->_internal_sso_profile(), target);
  }

  // optional string license_sku = 38;
  if (cached_has_bits & 0x00100000u) {
    target = stream->WriteStringMaybeAliased(
        38, this->_internal_license_sku(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PolicyData)
  return target;
}

size_t PolicyData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PolicyData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string device_affiliation_ids = 23;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.device_affiliation_ids_.size());
  for (int i = 0, n = _impl_.device_affiliation_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.device_affiliation_ids_.Get(i));
  }

  // repeated string user_affiliation_ids = 24;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.user_affiliation_ids_.size());
  for (int i = 0, n = _impl_.user_affiliation_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.user_affiliation_ids_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string policy_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_policy_type());
    }

    // optional string request_token = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_request_token());
    }

    // optional bytes policy_value = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_policy_value());
    }

    // optional string machine_name = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_machine_name());
    }

    // optional string username = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_username());
    }

    // optional string device_id = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_id());
    }

    // optional string settings_entity_id = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_settings_entity_id());
    }

    // optional string service_account_identity = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_service_account_identity());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional string policy_token = 15;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_policy_token());
    }

    // optional string annotated_location = 20;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_annotated_location());
    }

    // optional string annotated_asset_id = 21;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_annotated_asset_id());
    }

    // optional string directory_api_id = 22;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_directory_api_id());
    }

    // optional string display_domain = 25;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_display_domain());
    }

    // optional string policy_invalidation_topic = 26;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_policy_invalidation_topic());
    }

    // optional string command_invalidation_topic = 27;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_command_invalidation_topic());
    }

    // optional string gaia_id = 29;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gaia_id());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional string change_password_uri = 32;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_change_password_uri());
    }

    // optional string obfuscated_customer_id = 34;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_obfuscated_customer_id());
    }

    // optional string managed_by = 36;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_managed_by());
    }

    // optional string sso_profile = 37;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sso_profile());
    }

    // optional string license_sku = 38;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_license_sku());
    }

    // optional .enterprise_management.DeviceState device_state = 17;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_state_);
    }

    // optional .enterprise_management.CustomerLogo customer_logo = 31;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.customer_logo_);
    }

    // optional .enterprise_management.ClientActionRequired client_action_required = 33;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.client_action_required_);
    }

  }
  if (cached_has_bits & 0x7f000000u) {
    // optional int64 timestamp = 2;
    if (cached_has_bits & 0x01000000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
    }

    // optional int32 public_key_version = 6;
    if (cached_has_bits & 0x02000000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_public_key_version());
    }

    // optional .enterprise_management.PolicyData.AssociationState state = 9 [default = ACTIVE];
    if (cached_has_bits & 0x04000000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
    }

    // optional .enterprise_management.PolicyData.ManagementMode management_mode = 16;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_management_mode());
    }

    // optional bool enrollment_id_needed = 28;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 1;
    }

    // optional .enterprise_management.PolicyData.MarketSegment market_segment = 30;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_market_segment());
    }

    // optional .enterprise_management.PolicyData.MetricsLogSegment metrics_log_segment = 35;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_metrics_log_segment());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PolicyData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PolicyData*>(
      &from));
}

void PolicyData::MergeFrom(const PolicyData& from) {
  PolicyData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PolicyData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.device_affiliation_ids_.MergeFrom(from._impl_.device_affiliation_ids_);
  _this->_impl_.user_affiliation_ids_.MergeFrom(from._impl_.user_affiliation_ids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_policy_type(from._internal_policy_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_request_token(from._internal_request_token());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_policy_value(from._internal_policy_value());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_machine_name(from._internal_machine_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_username(from._internal_username());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_device_id(from._internal_device_id());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_settings_entity_id(from._internal_settings_entity_id());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_service_account_identity(from._internal_service_account_identity());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_set_policy_token(from._internal_policy_token());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_set_annotated_location(from._internal_annotated_location());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_set_annotated_asset_id(from._internal_annotated_asset_id());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_set_directory_api_id(from._internal_directory_api_id());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_set_display_domain(from._internal_display_domain());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_set_policy_invalidation_topic(from._internal_policy_invalidation_topic());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_set_command_invalidation_topic(from._internal_command_invalidation_topic());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_set_gaia_id(from._internal_gaia_id());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_internal_set_change_password_uri(from._internal_change_password_uri());
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_internal_set_obfuscated_customer_id(from._internal_obfuscated_customer_id());
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_internal_set_managed_by(from._internal_managed_by());
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_internal_set_sso_profile(from._internal_sso_profile());
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_internal_set_license_sku(from._internal_license_sku());
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_internal_mutable_device_state()->::enterprise_management::DeviceState::MergeFrom(
          from._internal_device_state());
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_internal_mutable_customer_logo()->::enterprise_management::CustomerLogo::MergeFrom(
          from._internal_customer_logo());
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_internal_mutable_client_action_required()->::enterprise_management::ClientActionRequired::MergeFrom(
          from._internal_client_action_required());
    }
  }
  if (cached_has_bits & 0x7f000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.public_key_version_ = from._impl_.public_key_version_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.state_ = from._impl_.state_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.management_mode_ = from._impl_.management_mode_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.enrollment_id_needed_ = from._impl_.enrollment_id_needed_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.market_segment_ = from._impl_.market_segment_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.metrics_log_segment_ = from._impl_.metrics_log_segment_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PolicyData::CopyFrom(const PolicyData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PolicyData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PolicyData::IsInitialized() const {
  return true;
}

void PolicyData::InternalSwap(PolicyData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.device_affiliation_ids_.InternalSwap(&other->_impl_.device_affiliation_ids_);
  _impl_.user_affiliation_ids_.InternalSwap(&other->_impl_.user_affiliation_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.policy_type_, lhs_arena,
      &other->_impl_.policy_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.request_token_, lhs_arena,
      &other->_impl_.request_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.policy_value_, lhs_arena,
      &other->_impl_.policy_value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_name_, lhs_arena,
      &other->_impl_.machine_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.username_, lhs_arena,
      &other->_impl_.username_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_id_, lhs_arena,
      &other->_impl_.device_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.settings_entity_id_, lhs_arena,
      &other->_impl_.settings_entity_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.service_account_identity_, lhs_arena,
      &other->_impl_.service_account_identity_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.policy_token_, lhs_arena,
      &other->_impl_.policy_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.annotated_location_, lhs_arena,
      &other->_impl_.annotated_location_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.annotated_asset_id_, lhs_arena,
      &other->_impl_.annotated_asset_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.directory_api_id_, lhs_arena,
      &other->_impl_.directory_api_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.display_domain_, lhs_arena,
      &other->_impl_.display_domain_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.policy_invalidation_topic_, lhs_arena,
      &other->_impl_.policy_invalidation_topic_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.command_invalidation_topic_, lhs_arena,
      &other->_impl_.command_invalidation_topic_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gaia_id_, lhs_arena,
      &other->_impl_.gaia_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.change_password_uri_, lhs_arena,
      &other->_impl_.change_password_uri_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.obfuscated_customer_id_, lhs_arena,
      &other->_impl_.obfuscated_customer_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.managed_by_, lhs_arena,
      &other->_impl_.managed_by_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sso_profile_, lhs_arena,
      &other->_impl_.sso_profile_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.license_sku_, lhs_arena,
      &other->_impl_.license_sku_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PolicyData, _impl_.metrics_log_segment_)
      + sizeof(PolicyData::_impl_.metrics_log_segment_)
      - PROTOBUF_FIELD_OFFSET(PolicyData, _impl_.device_state_)>(
          reinterpret_cast<char*>(&_impl_.device_state_),
          reinterpret_cast<char*>(&other->_impl_.device_state_));
}

std::string PolicyData::GetTypeName() const {
  return "enterprise_management.PolicyData";
}


// ===================================================================

class ClientActionRequired::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientActionRequired>()._impl_._has_bits_);
  static void set_has_enrollment_certificate_needed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ClientActionRequired::ClientActionRequired(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ClientActionRequired)
}
ClientActionRequired::ClientActionRequired(const ClientActionRequired& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientActionRequired* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enrollment_certificate_needed_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.enrollment_certificate_needed_ = from._impl_.enrollment_certificate_needed_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ClientActionRequired)
}

inline void ClientActionRequired::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enrollment_certificate_needed_){false}
  };
}

ClientActionRequired::~ClientActionRequired() {
  // @@protoc_insertion_point(destructor:enterprise_management.ClientActionRequired)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientActionRequired::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientActionRequired::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientActionRequired::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ClientActionRequired)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enrollment_certificate_needed_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientActionRequired::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enrollment_certificate_needed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enrollment_certificate_needed(&has_bits);
          _impl_.enrollment_certificate_needed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientActionRequired::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ClientActionRequired)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enrollment_certificate_needed = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enrollment_certificate_needed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ClientActionRequired)
  return target;
}

size_t ClientActionRequired::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ClientActionRequired)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enrollment_certificate_needed = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientActionRequired::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientActionRequired*>(
      &from));
}

void ClientActionRequired::MergeFrom(const ClientActionRequired& from) {
  ClientActionRequired* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ClientActionRequired)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enrollment_certificate_needed()) {
    _this->_internal_set_enrollment_certificate_needed(from._internal_enrollment_certificate_needed());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientActionRequired::CopyFrom(const ClientActionRequired& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ClientActionRequired)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientActionRequired::IsInitialized() const {
  return true;
}

void ClientActionRequired::InternalSwap(ClientActionRequired* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enrollment_certificate_needed_, other->_impl_.enrollment_certificate_needed_);
}

std::string ClientActionRequired::GetTypeName() const {
  return "enterprise_management.ClientActionRequired";
}


// ===================================================================

class PolicyFetchResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<PolicyFetchResponse>()._impl_._has_bits_);
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_policy_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_policy_data_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_new_public_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_new_public_key_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_new_public_key_verification_signature_deprecated(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_new_public_key_verification_data(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_new_public_key_verification_data_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_policy_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_policy_data_signature_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

PolicyFetchResponse::PolicyFetchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PolicyFetchResponse)
}
PolicyFetchResponse::PolicyFetchResponse(const PolicyFetchResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PolicyFetchResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.policy_data_){}
    , decltype(_impl_.policy_data_signature_){}
    , decltype(_impl_.new_public_key_){}
    , decltype(_impl_.new_public_key_signature_){}
    , decltype(_impl_.new_public_key_verification_signature_deprecated_){}
    , decltype(_impl_.new_public_key_verification_data_){}
    , decltype(_impl_.new_public_key_verification_data_signature_){}
    , decltype(_impl_.policy_type_){}
    , decltype(_impl_.error_code_){}
    , decltype(_impl_.policy_data_signature_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error_message()) {
    _this->_impl_.error_message_.Set(from._internal_error_message(), 
      _this->GetArenaForAllocation());
  }
  _impl_.policy_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_policy_data()) {
    _this->_impl_.policy_data_.Set(from._internal_policy_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.policy_data_signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_data_signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_policy_data_signature()) {
    _this->_impl_.policy_data_signature_.Set(from._internal_policy_data_signature(), 
      _this->GetArenaForAllocation());
  }
  _impl_.new_public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_new_public_key()) {
    _this->_impl_.new_public_key_.Set(from._internal_new_public_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.new_public_key_signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_public_key_signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_new_public_key_signature()) {
    _this->_impl_.new_public_key_signature_.Set(from._internal_new_public_key_signature(), 
      _this->GetArenaForAllocation());
  }
  _impl_.new_public_key_verification_signature_deprecated_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_public_key_verification_signature_deprecated_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_new_public_key_verification_signature_deprecated()) {
    _this->_impl_.new_public_key_verification_signature_deprecated_.Set(from._internal_new_public_key_verification_signature_deprecated(), 
      _this->GetArenaForAllocation());
  }
  _impl_.new_public_key_verification_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_public_key_verification_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_new_public_key_verification_data()) {
    _this->_impl_.new_public_key_verification_data_.Set(from._internal_new_public_key_verification_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.new_public_key_verification_data_signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_public_key_verification_data_signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_new_public_key_verification_data_signature()) {
    _this->_impl_.new_public_key_verification_data_signature_.Set(from._internal_new_public_key_verification_data_signature(), 
      _this->GetArenaForAllocation());
  }
  _impl_.policy_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_policy_type()) {
    _this->_impl_.policy_type_.Set(from._internal_policy_type(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.error_code_, &from._impl_.error_code_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.policy_data_signature_type_) -
    reinterpret_cast<char*>(&_impl_.error_code_)) + sizeof(_impl_.policy_data_signature_type_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PolicyFetchResponse)
}

inline void PolicyFetchResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.policy_data_){}
    , decltype(_impl_.policy_data_signature_){}
    , decltype(_impl_.new_public_key_){}
    , decltype(_impl_.new_public_key_signature_){}
    , decltype(_impl_.new_public_key_verification_signature_deprecated_){}
    , decltype(_impl_.new_public_key_verification_data_){}
    , decltype(_impl_.new_public_key_verification_data_signature_){}
    , decltype(_impl_.policy_type_){}
    , decltype(_impl_.error_code_){0}
    , decltype(_impl_.policy_data_signature_type_){0}
  };
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.policy_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.policy_data_signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_data_signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.new_public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.new_public_key_signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_public_key_signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.new_public_key_verification_signature_deprecated_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_public_key_verification_signature_deprecated_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.new_public_key_verification_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_public_key_verification_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.new_public_key_verification_data_signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_public_key_verification_data_signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.policy_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PolicyFetchResponse::~PolicyFetchResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.PolicyFetchResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PolicyFetchResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_message_.Destroy();
  _impl_.policy_data_.Destroy();
  _impl_.policy_data_signature_.Destroy();
  _impl_.new_public_key_.Destroy();
  _impl_.new_public_key_signature_.Destroy();
  _impl_.new_public_key_verification_signature_deprecated_.Destroy();
  _impl_.new_public_key_verification_data_.Destroy();
  _impl_.new_public_key_verification_data_signature_.Destroy();
  _impl_.policy_type_.Destroy();
}

void PolicyFetchResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PolicyFetchResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PolicyFetchResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.error_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.policy_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.policy_data_signature_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.new_public_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.new_public_key_signature_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.new_public_key_verification_signature_deprecated_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.new_public_key_verification_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.new_public_key_verification_data_signature_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000100u) {
    _impl_.policy_type_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000600u) {
    ::memset(&_impl_.error_code_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.policy_data_signature_type_) -
        reinterpret_cast<char*>(&_impl_.error_code_)) + sizeof(_impl_.policy_data_signature_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PolicyFetchResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 error_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_error_code(&has_bits);
          _impl_.error_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string error_message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_error_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes policy_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_policy_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes policy_data_signature = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_policy_data_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes new_public_key = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_new_public_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes new_public_key_signature = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_new_public_key_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes new_public_key_verification_signature_deprecated = 7 [deprecated = true];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_new_public_key_verification_signature_deprecated();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes new_public_key_verification_data = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_new_public_key_verification_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes new_public_key_verification_data_signature = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_new_public_key_verification_data_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string policy_type = 10 [deprecated = true];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_policy_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyFetchRequest.SignatureType policy_data_signature_type = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::PolicyFetchRequest_SignatureType_IsValid(val))) {
            _internal_set_policy_data_signature_type(static_cast<::enterprise_management::PolicyFetchRequest_SignatureType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(11, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PolicyFetchResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PolicyFetchResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 error_code = 1;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_error_code(), target);
  }

  // optional string error_message = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_error_message(), target);
  }

  // optional bytes policy_data = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_policy_data(), target);
  }

  // optional bytes policy_data_signature = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_policy_data_signature(), target);
  }

  // optional bytes new_public_key = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_new_public_key(), target);
  }

  // optional bytes new_public_key_signature = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_new_public_key_signature(), target);
  }

  // optional bytes new_public_key_verification_signature_deprecated = 7 [deprecated = true];
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_new_public_key_verification_signature_deprecated(), target);
  }

  // optional bytes new_public_key_verification_data = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_new_public_key_verification_data(), target);
  }

  // optional bytes new_public_key_verification_data_signature = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_new_public_key_verification_data_signature(), target);
  }

  // optional string policy_type = 10 [deprecated = true];
  if (cached_has_bits & 0x00000100u) {
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_policy_type(), target);
  }

  // optional .enterprise_management.PolicyFetchRequest.SignatureType policy_data_signature_type = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      11, this->_internal_policy_data_signature_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PolicyFetchResponse)
  return target;
}

size_t PolicyFetchResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PolicyFetchResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string error_message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error_message());
    }

    // optional bytes policy_data = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_policy_data());
    }

    // optional bytes policy_data_signature = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_policy_data_signature());
    }

    // optional bytes new_public_key = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_new_public_key());
    }

    // optional bytes new_public_key_signature = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_new_public_key_signature());
    }

    // optional bytes new_public_key_verification_signature_deprecated = 7 [deprecated = true];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_new_public_key_verification_signature_deprecated());
    }

    // optional bytes new_public_key_verification_data = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_new_public_key_verification_data());
    }

    // optional bytes new_public_key_verification_data_signature = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_new_public_key_verification_data_signature());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional string policy_type = 10 [deprecated = true];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_policy_type());
    }

    // optional int32 error_code = 1;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_error_code());
    }

    // optional .enterprise_management.PolicyFetchRequest.SignatureType policy_data_signature_type = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_policy_data_signature_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PolicyFetchResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PolicyFetchResponse*>(
      &from));
}

void PolicyFetchResponse::MergeFrom(const PolicyFetchResponse& from) {
  PolicyFetchResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PolicyFetchResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_policy_data(from._internal_policy_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_policy_data_signature(from._internal_policy_data_signature());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_new_public_key(from._internal_new_public_key());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_new_public_key_signature(from._internal_new_public_key_signature());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_new_public_key_verification_signature_deprecated(from._internal_new_public_key_verification_signature_deprecated());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_new_public_key_verification_data(from._internal_new_public_key_verification_data());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_new_public_key_verification_data_signature(from._internal_new_public_key_verification_data_signature());
    }
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_set_policy_type(from._internal_policy_type());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.error_code_ = from._impl_.error_code_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.policy_data_signature_type_ = from._impl_.policy_data_signature_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PolicyFetchResponse::CopyFrom(const PolicyFetchResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PolicyFetchResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PolicyFetchResponse::IsInitialized() const {
  return true;
}

void PolicyFetchResponse::InternalSwap(PolicyFetchResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_message_, lhs_arena,
      &other->_impl_.error_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.policy_data_, lhs_arena,
      &other->_impl_.policy_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.policy_data_signature_, lhs_arena,
      &other->_impl_.policy_data_signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_public_key_, lhs_arena,
      &other->_impl_.new_public_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_public_key_signature_, lhs_arena,
      &other->_impl_.new_public_key_signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_public_key_verification_signature_deprecated_, lhs_arena,
      &other->_impl_.new_public_key_verification_signature_deprecated_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_public_key_verification_data_, lhs_arena,
      &other->_impl_.new_public_key_verification_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_public_key_verification_data_signature_, lhs_arena,
      &other->_impl_.new_public_key_verification_data_signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.policy_type_, lhs_arena,
      &other->_impl_.policy_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PolicyFetchResponse, _impl_.policy_data_signature_type_)
      + sizeof(PolicyFetchResponse::_impl_.policy_data_signature_type_)
      - PROTOBUF_FIELD_OFFSET(PolicyFetchResponse, _impl_.error_code_)>(
          reinterpret_cast<char*>(&_impl_.error_code_),
          reinterpret_cast<char*>(&other->_impl_.error_code_));
}

std::string PolicyFetchResponse::GetTypeName() const {
  return "enterprise_management.PolicyFetchResponse";
}


// ===================================================================

class DEPRECATEDPolicyPublicKeyAndDomain::_Internal {
 public:
  using HasBits = decltype(std::declval<DEPRECATEDPolicyPublicKeyAndDomain>()._impl_._has_bits_);
  static void set_has_new_public_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_domain(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DEPRECATEDPolicyPublicKeyAndDomain::DEPRECATEDPolicyPublicKeyAndDomain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain)
}
DEPRECATEDPolicyPublicKeyAndDomain::DEPRECATEDPolicyPublicKeyAndDomain(const DEPRECATEDPolicyPublicKeyAndDomain& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DEPRECATEDPolicyPublicKeyAndDomain* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_public_key_){}
    , decltype(_impl_.domain_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.new_public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_new_public_key()) {
    _this->_impl_.new_public_key_.Set(from._internal_new_public_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_domain()) {
    _this->_impl_.domain_.Set(from._internal_domain(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain)
}

inline void DEPRECATEDPolicyPublicKeyAndDomain::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_public_key_){}
    , decltype(_impl_.domain_){}
  };
  _impl_.new_public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DEPRECATEDPolicyPublicKeyAndDomain::~DEPRECATEDPolicyPublicKeyAndDomain() {
  // @@protoc_insertion_point(destructor:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DEPRECATEDPolicyPublicKeyAndDomain::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.new_public_key_.Destroy();
  _impl_.domain_.Destroy();
}

void DEPRECATEDPolicyPublicKeyAndDomain::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DEPRECATEDPolicyPublicKeyAndDomain::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.new_public_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.domain_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DEPRECATEDPolicyPublicKeyAndDomain::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes new_public_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_new_public_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string domain = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_domain();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DEPRECATEDPolicyPublicKeyAndDomain::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes new_public_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_new_public_key(), target);
  }

  // optional string domain = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_domain(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain)
  return target;
}

size_t DEPRECATEDPolicyPublicKeyAndDomain::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes new_public_key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_new_public_key());
    }

    // optional string domain = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_domain());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DEPRECATEDPolicyPublicKeyAndDomain::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DEPRECATEDPolicyPublicKeyAndDomain*>(
      &from));
}

void DEPRECATEDPolicyPublicKeyAndDomain::MergeFrom(const DEPRECATEDPolicyPublicKeyAndDomain& from) {
  DEPRECATEDPolicyPublicKeyAndDomain* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_new_public_key(from._internal_new_public_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_domain(from._internal_domain());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DEPRECATEDPolicyPublicKeyAndDomain::CopyFrom(const DEPRECATEDPolicyPublicKeyAndDomain& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DEPRECATEDPolicyPublicKeyAndDomain::IsInitialized() const {
  return true;
}

void DEPRECATEDPolicyPublicKeyAndDomain::InternalSwap(DEPRECATEDPolicyPublicKeyAndDomain* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_public_key_, lhs_arena,
      &other->_impl_.new_public_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.domain_, lhs_arena,
      &other->_impl_.domain_, rhs_arena
  );
}

std::string DEPRECATEDPolicyPublicKeyAndDomain::GetTypeName() const {
  return "enterprise_management.DEPRECATEDPolicyPublicKeyAndDomain";
}


// ===================================================================

class PublicKeyVerificationData::_Internal {
 public:
  using HasBits = decltype(std::declval<PublicKeyVerificationData>()._impl_._has_bits_);
  static void set_has_new_public_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_domain(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_new_public_key_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

PublicKeyVerificationData::PublicKeyVerificationData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PublicKeyVerificationData)
}
PublicKeyVerificationData::PublicKeyVerificationData(const PublicKeyVerificationData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PublicKeyVerificationData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_public_key_){}
    , decltype(_impl_.domain_){}
    , decltype(_impl_.new_public_key_version_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.new_public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_new_public_key()) {
    _this->_impl_.new_public_key_.Set(from._internal_new_public_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_domain()) {
    _this->_impl_.domain_.Set(from._internal_domain(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.new_public_key_version_ = from._impl_.new_public_key_version_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PublicKeyVerificationData)
}

inline void PublicKeyVerificationData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_public_key_){}
    , decltype(_impl_.domain_){}
    , decltype(_impl_.new_public_key_version_){0}
  };
  _impl_.new_public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PublicKeyVerificationData::~PublicKeyVerificationData() {
  // @@protoc_insertion_point(destructor:enterprise_management.PublicKeyVerificationData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PublicKeyVerificationData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.new_public_key_.Destroy();
  _impl_.domain_.Destroy();
}

void PublicKeyVerificationData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PublicKeyVerificationData::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PublicKeyVerificationData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.new_public_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.domain_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.new_public_key_version_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PublicKeyVerificationData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes new_public_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_new_public_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string domain = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_domain();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 new_public_key_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_new_public_key_version(&has_bits);
          _impl_.new_public_key_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PublicKeyVerificationData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PublicKeyVerificationData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes new_public_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_new_public_key(), target);
  }

  // optional string domain = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_domain(), target);
  }

  // optional int32 new_public_key_version = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_new_public_key_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PublicKeyVerificationData)
  return target;
}

size_t PublicKeyVerificationData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PublicKeyVerificationData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes new_public_key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_new_public_key());
    }

    // optional string domain = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_domain());
    }

    // optional int32 new_public_key_version = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_new_public_key_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PublicKeyVerificationData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PublicKeyVerificationData*>(
      &from));
}

void PublicKeyVerificationData::MergeFrom(const PublicKeyVerificationData& from) {
  PublicKeyVerificationData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PublicKeyVerificationData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_new_public_key(from._internal_new_public_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_domain(from._internal_domain());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.new_public_key_version_ = from._impl_.new_public_key_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PublicKeyVerificationData::CopyFrom(const PublicKeyVerificationData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PublicKeyVerificationData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublicKeyVerificationData::IsInitialized() const {
  return true;
}

void PublicKeyVerificationData::InternalSwap(PublicKeyVerificationData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_public_key_, lhs_arena,
      &other->_impl_.new_public_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.domain_, lhs_arena,
      &other->_impl_.domain_, rhs_arena
  );
  swap(_impl_.new_public_key_version_, other->_impl_.new_public_key_version_);
}

std::string PublicKeyVerificationData::GetTypeName() const {
  return "enterprise_management.PublicKeyVerificationData";
}


// ===================================================================

class DevicePolicyRequest::_Internal {
 public:
};

DevicePolicyRequest::DevicePolicyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DevicePolicyRequest)
}
DevicePolicyRequest::DevicePolicyRequest(const DevicePolicyRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DevicePolicyRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.requests_){from._impl_.requests_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DevicePolicyRequest)
}

inline void DevicePolicyRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.requests_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DevicePolicyRequest::~DevicePolicyRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.DevicePolicyRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DevicePolicyRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.requests_.~RepeatedPtrField();
}

void DevicePolicyRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DevicePolicyRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DevicePolicyRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.requests_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DevicePolicyRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .enterprise_management.PolicyFetchRequest requests = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_requests(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DevicePolicyRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DevicePolicyRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .enterprise_management.PolicyFetchRequest requests = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_requests_size()); i < n; i++) {
    const auto& repfield = this->_internal_requests(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DevicePolicyRequest)
  return target;
}

size_t DevicePolicyRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DevicePolicyRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.PolicyFetchRequest requests = 3;
  total_size += 1UL * this->_internal_requests_size();
  for (const auto& msg : this->_impl_.requests_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DevicePolicyRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DevicePolicyRequest*>(
      &from));
}

void DevicePolicyRequest::MergeFrom(const DevicePolicyRequest& from) {
  DevicePolicyRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DevicePolicyRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.requests_.MergeFrom(from._impl_.requests_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DevicePolicyRequest::CopyFrom(const DevicePolicyRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DevicePolicyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DevicePolicyRequest::IsInitialized() const {
  return true;
}

void DevicePolicyRequest::InternalSwap(DevicePolicyRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.requests_.InternalSwap(&other->_impl_.requests_);
}

std::string DevicePolicyRequest::GetTypeName() const {
  return "enterprise_management.DevicePolicyRequest";
}


// ===================================================================

class DevicePolicyResponse::_Internal {
 public:
};

DevicePolicyResponse::DevicePolicyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DevicePolicyResponse)
}
DevicePolicyResponse::DevicePolicyResponse(const DevicePolicyResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DevicePolicyResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.responses_){from._impl_.responses_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DevicePolicyResponse)
}

inline void DevicePolicyResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.responses_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DevicePolicyResponse::~DevicePolicyResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.DevicePolicyResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DevicePolicyResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.responses_.~RepeatedPtrField();
}

void DevicePolicyResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DevicePolicyResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DevicePolicyResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.responses_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DevicePolicyResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .enterprise_management.PolicyFetchResponse responses = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_responses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DevicePolicyResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DevicePolicyResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .enterprise_management.PolicyFetchResponse responses = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_responses_size()); i < n; i++) {
    const auto& repfield = this->_internal_responses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DevicePolicyResponse)
  return target;
}

size_t DevicePolicyResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DevicePolicyResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.PolicyFetchResponse responses = 3;
  total_size += 1UL * this->_internal_responses_size();
  for (const auto& msg : this->_impl_.responses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DevicePolicyResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DevicePolicyResponse*>(
      &from));
}

void DevicePolicyResponse::MergeFrom(const DevicePolicyResponse& from) {
  DevicePolicyResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DevicePolicyResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.responses_.MergeFrom(from._impl_.responses_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DevicePolicyResponse::CopyFrom(const DevicePolicyResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DevicePolicyResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DevicePolicyResponse::IsInitialized() const {
  return true;
}

void DevicePolicyResponse::InternalSwap(DevicePolicyResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.responses_.InternalSwap(&other->_impl_.responses_);
}

std::string DevicePolicyResponse::GetTypeName() const {
  return "enterprise_management.DevicePolicyResponse";
}


// ===================================================================

class TimePeriod::_Internal {
 public:
  using HasBits = decltype(std::declval<TimePeriod>()._impl_._has_bits_);
  static void set_has_start_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_end_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TimePeriod::TimePeriod(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.TimePeriod)
}
TimePeriod::TimePeriod(const TimePeriod& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TimePeriod* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_timestamp_){}
    , decltype(_impl_.end_timestamp_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.start_timestamp_, &from._impl_.start_timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.end_timestamp_) -
    reinterpret_cast<char*>(&_impl_.start_timestamp_)) + sizeof(_impl_.end_timestamp_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.TimePeriod)
}

inline void TimePeriod::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_timestamp_){int64_t{0}}
    , decltype(_impl_.end_timestamp_){int64_t{0}}
  };
}

TimePeriod::~TimePeriod() {
  // @@protoc_insertion_point(destructor:enterprise_management.TimePeriod)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TimePeriod::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TimePeriod::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TimePeriod::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.TimePeriod)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.start_timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.end_timestamp_) -
        reinterpret_cast<char*>(&_impl_.start_timestamp_)) + sizeof(_impl_.end_timestamp_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TimePeriod::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 start_timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_start_timestamp(&has_bits);
          _impl_.start_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 end_timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_end_timestamp(&has_bits);
          _impl_.end_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TimePeriod::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.TimePeriod)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 start_timestamp = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_start_timestamp(), target);
  }

  // optional int64 end_timestamp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_end_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.TimePeriod)
  return target;
}

size_t TimePeriod::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.TimePeriod)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 start_timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_start_timestamp());
    }

    // optional int64 end_timestamp = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_end_timestamp());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TimePeriod::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TimePeriod*>(
      &from));
}

void TimePeriod::MergeFrom(const TimePeriod& from) {
  TimePeriod* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.TimePeriod)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.start_timestamp_ = from._impl_.start_timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.end_timestamp_ = from._impl_.end_timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TimePeriod::CopyFrom(const TimePeriod& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.TimePeriod)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimePeriod::IsInitialized() const {
  return true;
}

void TimePeriod::InternalSwap(TimePeriod* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimePeriod, _impl_.end_timestamp_)
      + sizeof(TimePeriod::_impl_.end_timestamp_)
      - PROTOBUF_FIELD_OFFSET(TimePeriod, _impl_.start_timestamp_)>(
          reinterpret_cast<char*>(&_impl_.start_timestamp_),
          reinterpret_cast<char*>(&other->_impl_.start_timestamp_));
}

std::string TimePeriod::GetTypeName() const {
  return "enterprise_management.TimePeriod";
}


// ===================================================================

class ActiveTimePeriod::_Internal {
 public:
  using HasBits = decltype(std::declval<ActiveTimePeriod>()._impl_._has_bits_);
  static const ::enterprise_management::TimePeriod& time_period(const ActiveTimePeriod* msg);
  static void set_has_time_period(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_active_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user_email(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_session_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::enterprise_management::TimePeriod&
ActiveTimePeriod::_Internal::time_period(const ActiveTimePeriod* msg) {
  return *msg->_impl_.time_period_;
}
ActiveTimePeriod::ActiveTimePeriod(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ActiveTimePeriod)
}
ActiveTimePeriod::ActiveTimePeriod(const ActiveTimePeriod& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ActiveTimePeriod* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_email_){}
    , decltype(_impl_.time_period_){nullptr}
    , decltype(_impl_.active_duration_){}
    , decltype(_impl_.session_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.user_email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_email()) {
    _this->_impl_.user_email_.Set(from._internal_user_email(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_time_period()) {
    _this->_impl_.time_period_ = new ::enterprise_management::TimePeriod(*from._impl_.time_period_);
  }
  ::memcpy(&_impl_.active_duration_, &from._impl_.active_duration_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.session_type_) -
    reinterpret_cast<char*>(&_impl_.active_duration_)) + sizeof(_impl_.session_type_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ActiveTimePeriod)
}

inline void ActiveTimePeriod::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_email_){}
    , decltype(_impl_.time_period_){nullptr}
    , decltype(_impl_.active_duration_){0}
    , decltype(_impl_.session_type_){0}
  };
  _impl_.user_email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ActiveTimePeriod::~ActiveTimePeriod() {
  // @@protoc_insertion_point(destructor:enterprise_management.ActiveTimePeriod)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActiveTimePeriod::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_email_.Destroy();
  if (this != internal_default_instance()) delete _impl_.time_period_;
}

void ActiveTimePeriod::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActiveTimePeriod::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ActiveTimePeriod)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.user_email_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.time_period_ != nullptr);
      _impl_.time_period_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.active_duration_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.session_type_) -
        reinterpret_cast<char*>(&_impl_.active_duration_)) + sizeof(_impl_.session_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ActiveTimePeriod::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.TimePeriod time_period = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_time_period(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 active_duration = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_active_duration(&has_bits);
          _impl_.active_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string user_email = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_user_email();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ActiveTimePeriod.SessionType session_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::ActiveTimePeriod_SessionType_IsValid(val))) {
            _internal_set_session_type(static_cast<::enterprise_management::ActiveTimePeriod_SessionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActiveTimePeriod::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ActiveTimePeriod)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.TimePeriod time_period = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::time_period(this),
        _Internal::time_period(this).GetCachedSize(), target, stream);
  }

  // optional int32 active_duration = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_active_duration(), target);
  }

  // optional string user_email = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_user_email(), target);
  }

  // optional .enterprise_management.ActiveTimePeriod.SessionType session_type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_session_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ActiveTimePeriod)
  return target;
}

size_t ActiveTimePeriod::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ActiveTimePeriod)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string user_email = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_email());
    }

    // optional .enterprise_management.TimePeriod time_period = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.time_period_);
    }

    // optional int32 active_duration = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_active_duration());
    }

    // optional .enterprise_management.ActiveTimePeriod.SessionType session_type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_session_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActiveTimePeriod::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ActiveTimePeriod*>(
      &from));
}

void ActiveTimePeriod::MergeFrom(const ActiveTimePeriod& from) {
  ActiveTimePeriod* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ActiveTimePeriod)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_user_email(from._internal_user_email());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_time_period()->::enterprise_management::TimePeriod::MergeFrom(
          from._internal_time_period());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.active_duration_ = from._impl_.active_duration_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.session_type_ = from._impl_.session_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActiveTimePeriod::CopyFrom(const ActiveTimePeriod& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ActiveTimePeriod)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActiveTimePeriod::IsInitialized() const {
  return true;
}

void ActiveTimePeriod::InternalSwap(ActiveTimePeriod* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_email_, lhs_arena,
      &other->_impl_.user_email_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ActiveTimePeriod, _impl_.session_type_)
      + sizeof(ActiveTimePeriod::_impl_.session_type_)
      - PROTOBUF_FIELD_OFFSET(ActiveTimePeriod, _impl_.time_period_)>(
          reinterpret_cast<char*>(&_impl_.time_period_),
          reinterpret_cast<char*>(&other->_impl_.time_period_));
}

std::string ActiveTimePeriod::GetTypeName() const {
  return "enterprise_management.ActiveTimePeriod";
}


// ===================================================================

class NetworkInterface::_Internal {
 public:
  using HasBits = decltype(std::declval<NetworkInterface>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_mac_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_meid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_imei(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_device_path(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_iccid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mdn(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

NetworkInterface::NetworkInterface(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.NetworkInterface)
}
NetworkInterface::NetworkInterface(const NetworkInterface& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  NetworkInterface* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eids_){from._impl_.eids_}
    , decltype(_impl_.mac_address_){}
    , decltype(_impl_.meid_){}
    , decltype(_impl_.imei_){}
    , decltype(_impl_.device_path_){}
    , decltype(_impl_.iccid_){}
    , decltype(_impl_.mdn_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.mac_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mac_address()) {
    _this->_impl_.mac_address_.Set(from._internal_mac_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.meid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_meid()) {
    _this->_impl_.meid_.Set(from._internal_meid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.imei_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imei_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_imei()) {
    _this->_impl_.imei_.Set(from._internal_imei(), 
      _this->GetArenaForAllocation());
  }
  _impl_.device_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_path()) {
    _this->_impl_.device_path_.Set(from._internal_device_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.iccid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iccid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_iccid()) {
    _this->_impl_.iccid_.Set(from._internal_iccid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mdn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mdn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mdn()) {
    _this->_impl_.mdn_.Set(from._internal_mdn(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.NetworkInterface)
}

inline void NetworkInterface::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eids_){arena}
    , decltype(_impl_.mac_address_){}
    , decltype(_impl_.meid_){}
    , decltype(_impl_.imei_){}
    , decltype(_impl_.device_path_){}
    , decltype(_impl_.iccid_){}
    , decltype(_impl_.mdn_){}
    , decltype(_impl_.type_){0}
  };
  _impl_.mac_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.meid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.imei_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imei_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.device_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.iccid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iccid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mdn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mdn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NetworkInterface::~NetworkInterface() {
  // @@protoc_insertion_point(destructor:enterprise_management.NetworkInterface)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NetworkInterface::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.eids_.~RepeatedPtrField();
  _impl_.mac_address_.Destroy();
  _impl_.meid_.Destroy();
  _impl_.imei_.Destroy();
  _impl_.device_path_.Destroy();
  _impl_.iccid_.Destroy();
  _impl_.mdn_.Destroy();
}

void NetworkInterface::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NetworkInterface::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.NetworkInterface)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.eids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.mac_address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.meid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.imei_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.device_path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.iccid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.mdn_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NetworkInterface::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.NetworkInterface.NetworkDeviceType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::NetworkInterface_NetworkDeviceType_IsValid(val))) {
            _internal_set_type(static_cast<::enterprise_management::NetworkInterface_NetworkDeviceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string mac_address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_mac_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string meid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_meid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string imei = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_imei();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string device_path = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_device_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string iccid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_iccid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string mdn = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_mdn();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string eids = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_eids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NetworkInterface::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.NetworkInterface)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.NetworkInterface.NetworkDeviceType type = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional string mac_address = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_mac_address(), target);
  }

  // optional string meid = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_meid(), target);
  }

  // optional string imei = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_imei(), target);
  }

  // optional string device_path = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_device_path(), target);
  }

  // optional string iccid = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_iccid(), target);
  }

  // optional string mdn = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_mdn(), target);
  }

  // repeated string eids = 8;
  for (int i = 0, n = this->_internal_eids_size(); i < n; i++) {
    const auto& s = this->_internal_eids(i);
    target = stream->WriteString(8, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.NetworkInterface)
  return target;
}

size_t NetworkInterface::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.NetworkInterface)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string eids = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.eids_.size());
  for (int i = 0, n = _impl_.eids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.eids_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string mac_address = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_mac_address());
    }

    // optional string meid = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_meid());
    }

    // optional string imei = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_imei());
    }

    // optional string device_path = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_path());
    }

    // optional string iccid = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_iccid());
    }

    // optional string mdn = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_mdn());
    }

    // optional .enterprise_management.NetworkInterface.NetworkDeviceType type = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NetworkInterface::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NetworkInterface*>(
      &from));
}

void NetworkInterface::MergeFrom(const NetworkInterface& from) {
  NetworkInterface* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.NetworkInterface)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.eids_.MergeFrom(from._impl_.eids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_mac_address(from._internal_mac_address());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_meid(from._internal_meid());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_imei(from._internal_imei());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_device_path(from._internal_device_path());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_iccid(from._internal_iccid());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_mdn(from._internal_mdn());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetworkInterface::CopyFrom(const NetworkInterface& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.NetworkInterface)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkInterface::IsInitialized() const {
  return true;
}

void NetworkInterface::InternalSwap(NetworkInterface* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.eids_.InternalSwap(&other->_impl_.eids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mac_address_, lhs_arena,
      &other->_impl_.mac_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.meid_, lhs_arena,
      &other->_impl_.meid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.imei_, lhs_arena,
      &other->_impl_.imei_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_path_, lhs_arena,
      &other->_impl_.device_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.iccid_, lhs_arena,
      &other->_impl_.iccid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mdn_, lhs_arena,
      &other->_impl_.mdn_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

std::string NetworkInterface::GetTypeName() const {
  return "enterprise_management.NetworkInterface";
}


// ===================================================================

class NetworkState::_Internal {
 public:
  using HasBits = decltype(std::declval<NetworkState>()._impl_._has_bits_);
  static void set_has_device_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_connection_state(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_signal_strength(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ip_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gateway(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

NetworkState::NetworkState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.NetworkState)
}
NetworkState::NetworkState(const NetworkState& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  NetworkState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_path_){}
    , decltype(_impl_.ip_address_){}
    , decltype(_impl_.gateway_){}
    , decltype(_impl_.connection_state_){}
    , decltype(_impl_.signal_strength_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.device_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_path()) {
    _this->_impl_.device_path_.Set(from._internal_device_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ip_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip_address()) {
    _this->_impl_.ip_address_.Set(from._internal_ip_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.gateway_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gateway_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gateway()) {
    _this->_impl_.gateway_.Set(from._internal_gateway(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.connection_state_, &from._impl_.connection_state_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.signal_strength_) -
    reinterpret_cast<char*>(&_impl_.connection_state_)) + sizeof(_impl_.signal_strength_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.NetworkState)
}

inline void NetworkState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_path_){}
    , decltype(_impl_.ip_address_){}
    , decltype(_impl_.gateway_){}
    , decltype(_impl_.connection_state_){0}
    , decltype(_impl_.signal_strength_){0}
  };
  _impl_.device_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ip_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gateway_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gateway_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NetworkState::~NetworkState() {
  // @@protoc_insertion_point(destructor:enterprise_management.NetworkState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NetworkState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.device_path_.Destroy();
  _impl_.ip_address_.Destroy();
  _impl_.gateway_.Destroy();
}

void NetworkState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NetworkState::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.NetworkState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.device_path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ip_address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.gateway_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.connection_state_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.signal_strength_) -
        reinterpret_cast<char*>(&_impl_.connection_state_)) + sizeof(_impl_.signal_strength_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NetworkState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device_path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.NetworkState.ConnectionState connection_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::NetworkState_ConnectionState_IsValid(val))) {
            _internal_set_connection_state(static_cast<::enterprise_management::NetworkState_ConnectionState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 signal_strength = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_signal_strength(&has_bits);
          _impl_.signal_strength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ip_address = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_ip_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string gateway = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_gateway();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NetworkState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.NetworkState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string device_path = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_path(), target);
  }

  // optional .enterprise_management.NetworkState.ConnectionState connection_state = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_connection_state(), target);
  }

  // optional int32 signal_strength = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_signal_strength(), target);
  }

  // optional string ip_address = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_ip_address(), target);
  }

  // optional string gateway = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_gateway(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.NetworkState)
  return target;
}

size_t NetworkState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.NetworkState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string device_path = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_path());
    }

    // optional string ip_address = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ip_address());
    }

    // optional string gateway = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gateway());
    }

    // optional .enterprise_management.NetworkState.ConnectionState connection_state = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_connection_state());
    }

    // optional int32 signal_strength = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_signal_strength());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NetworkState::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NetworkState*>(
      &from));
}

void NetworkState::MergeFrom(const NetworkState& from) {
  NetworkState* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.NetworkState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_device_path(from._internal_device_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_ip_address(from._internal_ip_address());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_gateway(from._internal_gateway());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.connection_state_ = from._impl_.connection_state_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.signal_strength_ = from._impl_.signal_strength_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetworkState::CopyFrom(const NetworkState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.NetworkState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkState::IsInitialized() const {
  return true;
}

void NetworkState::InternalSwap(NetworkState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_path_, lhs_arena,
      &other->_impl_.device_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ip_address_, lhs_arena,
      &other->_impl_.ip_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gateway_, lhs_arena,
      &other->_impl_.gateway_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NetworkState, _impl_.signal_strength_)
      + sizeof(NetworkState::_impl_.signal_strength_)
      - PROTOBUF_FIELD_OFFSET(NetworkState, _impl_.connection_state_)>(
          reinterpret_cast<char*>(&_impl_.connection_state_),
          reinterpret_cast<char*>(&other->_impl_.connection_state_));
}

std::string NetworkState::GetTypeName() const {
  return "enterprise_management.NetworkState";
}


// ===================================================================

class DeviceUser::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceUser>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_email(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

DeviceUser::DeviceUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceUser)
}
DeviceUser::DeviceUser(const DeviceUser& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceUser* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.email_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_email()) {
    _this->_impl_.email_.Set(from._internal_email(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceUser)
}

inline void DeviceUser::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.email_){}
    , decltype(_impl_.type_){0}
  };
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceUser::~DeviceUser() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceUser)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceUser::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.email_.Destroy();
}

void DeviceUser::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceUser::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceUser)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.email_.ClearNonDefaultToEmpty();
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceUser::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .enterprise_management.DeviceUser.UserType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceUser_UserType_IsValid(val))) {
            _internal_set_type(static_cast<::enterprise_management::DeviceUser_UserType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string email = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_email();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceUser::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceUser)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .enterprise_management.DeviceUser.UserType type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional string email = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_email(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceUser)
  return target;
}

size_t DeviceUser::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceUser)
  size_t total_size = 0;

  // required .enterprise_management.DeviceUser.UserType type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string email = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceUser::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceUser*>(
      &from));
}

void DeviceUser::MergeFrom(const DeviceUser& from) {
  DeviceUser* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceUser)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_email(from._internal_email());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceUser::CopyFrom(const DeviceUser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceUser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceUser::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void DeviceUser::InternalSwap(DeviceUser* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.email_, lhs_arena,
      &other->_impl_.email_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

std::string DeviceUser::GetTypeName() const {
  return "enterprise_management.DeviceUser";
}


// ===================================================================

class VolumeInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<VolumeInfo>()._impl_._has_bits_);
  static void set_has_volume_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_storage_total(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_storage_free(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

VolumeInfo::VolumeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.VolumeInfo)
}
VolumeInfo::VolumeInfo(const VolumeInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  VolumeInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volume_id_){}
    , decltype(_impl_.storage_total_){}
    , decltype(_impl_.storage_free_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.volume_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volume_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_volume_id()) {
    _this->_impl_.volume_id_.Set(from._internal_volume_id(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.storage_total_, &from._impl_.storage_total_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.storage_free_) -
    reinterpret_cast<char*>(&_impl_.storage_total_)) + sizeof(_impl_.storage_free_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.VolumeInfo)
}

inline void VolumeInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volume_id_){}
    , decltype(_impl_.storage_total_){int64_t{0}}
    , decltype(_impl_.storage_free_){int64_t{0}}
  };
  _impl_.volume_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volume_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VolumeInfo::~VolumeInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.VolumeInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VolumeInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.volume_id_.Destroy();
}

void VolumeInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VolumeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.VolumeInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.volume_id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.storage_total_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.storage_free_) -
        reinterpret_cast<char*>(&_impl_.storage_total_)) + sizeof(_impl_.storage_free_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VolumeInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string volume_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_volume_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 storage_total = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_storage_total(&has_bits);
          _impl_.storage_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 storage_free = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_storage_free(&has_bits);
          _impl_.storage_free_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VolumeInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.VolumeInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string volume_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_volume_id(), target);
  }

  // optional int64 storage_total = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_storage_total(), target);
  }

  // optional int64 storage_free = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_storage_free(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.VolumeInfo)
  return target;
}

size_t VolumeInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.VolumeInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string volume_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_volume_id());
    }

    // optional int64 storage_total = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_storage_total());
    }

    // optional int64 storage_free = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_storage_free());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VolumeInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VolumeInfo*>(
      &from));
}

void VolumeInfo::MergeFrom(const VolumeInfo& from) {
  VolumeInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.VolumeInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_volume_id(from._internal_volume_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.storage_total_ = from._impl_.storage_total_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.storage_free_ = from._impl_.storage_free_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VolumeInfo::CopyFrom(const VolumeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.VolumeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VolumeInfo::IsInitialized() const {
  return true;
}

void VolumeInfo::InternalSwap(VolumeInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volume_id_, lhs_arena,
      &other->_impl_.volume_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VolumeInfo, _impl_.storage_free_)
      + sizeof(VolumeInfo::_impl_.storage_free_)
      - PROTOBUF_FIELD_OFFSET(VolumeInfo, _impl_.storage_total_)>(
          reinterpret_cast<char*>(&_impl_.storage_total_),
          reinterpret_cast<char*>(&other->_impl_.storage_total_));
}

std::string VolumeInfo::GetTypeName() const {
  return "enterprise_management.VolumeInfo";
}


// ===================================================================

class CpuUtilizationInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CpuUtilizationInfo>()._impl_._has_bits_);
  static void set_has_cpu_utilization_pct(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CpuUtilizationInfo::CpuUtilizationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CpuUtilizationInfo)
}
CpuUtilizationInfo::CpuUtilizationInfo(const CpuUtilizationInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CpuUtilizationInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.cpu_utilization_pct_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cpu_utilization_pct_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.cpu_utilization_pct_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CpuUtilizationInfo)
}

inline void CpuUtilizationInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , decltype(_impl_.cpu_utilization_pct_){0}
  };
}

CpuUtilizationInfo::~CpuUtilizationInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.CpuUtilizationInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CpuUtilizationInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CpuUtilizationInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CpuUtilizationInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CpuUtilizationInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cpu_utilization_pct_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.cpu_utilization_pct_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CpuUtilizationInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 cpu_utilization_pct = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cpu_utilization_pct(&has_bits);
          _impl_.cpu_utilization_pct_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CpuUtilizationInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CpuUtilizationInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 cpu_utilization_pct = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_cpu_utilization_pct(), target);
  }

  // optional int64 timestamp = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CpuUtilizationInfo)
  return target;
}

size_t CpuUtilizationInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CpuUtilizationInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 timestamp = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
    }

    // optional int32 cpu_utilization_pct = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cpu_utilization_pct());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CpuUtilizationInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CpuUtilizationInfo*>(
      &from));
}

void CpuUtilizationInfo::MergeFrom(const CpuUtilizationInfo& from) {
  CpuUtilizationInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CpuUtilizationInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.cpu_utilization_pct_ = from._impl_.cpu_utilization_pct_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CpuUtilizationInfo::CopyFrom(const CpuUtilizationInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CpuUtilizationInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CpuUtilizationInfo::IsInitialized() const {
  return true;
}

void CpuUtilizationInfo::InternalSwap(CpuUtilizationInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CpuUtilizationInfo, _impl_.cpu_utilization_pct_)
      + sizeof(CpuUtilizationInfo::_impl_.cpu_utilization_pct_)
      - PROTOBUF_FIELD_OFFSET(CpuUtilizationInfo, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

std::string CpuUtilizationInfo::GetTypeName() const {
  return "enterprise_management.CpuUtilizationInfo";
}


// ===================================================================

class SystemFreeRamInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemFreeRamInfo>()._impl_._has_bits_);
  static void set_has_size_in_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SystemFreeRamInfo::SystemFreeRamInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.SystemFreeRamInfo)
}
SystemFreeRamInfo::SystemFreeRamInfo(const SystemFreeRamInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SystemFreeRamInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.size_in_bytes_){}
    , decltype(_impl_.timestamp_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.size_in_bytes_, &from._impl_.size_in_bytes_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.timestamp_) -
    reinterpret_cast<char*>(&_impl_.size_in_bytes_)) + sizeof(_impl_.timestamp_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.SystemFreeRamInfo)
}

inline void SystemFreeRamInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.size_in_bytes_){int64_t{0}}
    , decltype(_impl_.timestamp_){int64_t{0}}
  };
}

SystemFreeRamInfo::~SystemFreeRamInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.SystemFreeRamInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemFreeRamInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SystemFreeRamInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SystemFreeRamInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.SystemFreeRamInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.size_in_bytes_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.timestamp_) -
        reinterpret_cast<char*>(&_impl_.size_in_bytes_)) + sizeof(_impl_.timestamp_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemFreeRamInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 size_in_bytes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_size_in_bytes(&has_bits);
          _impl_.size_in_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemFreeRamInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.SystemFreeRamInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 size_in_bytes = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_size_in_bytes(), target);
  }

  // optional int64 timestamp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.SystemFreeRamInfo)
  return target;
}

size_t SystemFreeRamInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.SystemFreeRamInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 size_in_bytes = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size_in_bytes());
    }

    // optional int64 timestamp = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemFreeRamInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemFreeRamInfo*>(
      &from));
}

void SystemFreeRamInfo::MergeFrom(const SystemFreeRamInfo& from) {
  SystemFreeRamInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.SystemFreeRamInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.size_in_bytes_ = from._impl_.size_in_bytes_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemFreeRamInfo::CopyFrom(const SystemFreeRamInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.SystemFreeRamInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemFreeRamInfo::IsInitialized() const {
  return true;
}

void SystemFreeRamInfo::InternalSwap(SystemFreeRamInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemFreeRamInfo, _impl_.timestamp_)
      + sizeof(SystemFreeRamInfo::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(SystemFreeRamInfo, _impl_.size_in_bytes_)>(
          reinterpret_cast<char*>(&_impl_.size_in_bytes_),
          reinterpret_cast<char*>(&other->_impl_.size_in_bytes_));
}

std::string SystemFreeRamInfo::GetTypeName() const {
  return "enterprise_management.SystemFreeRamInfo";
}


// ===================================================================

class CPUTempInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CPUTempInfo>()._impl_._has_bits_);
  static void set_has_cpu_label(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cpu_temp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CPUTempInfo::CPUTempInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CPUTempInfo)
}
CPUTempInfo::CPUTempInfo(const CPUTempInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CPUTempInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cpu_label_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.cpu_temp_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.cpu_label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cpu_label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cpu_label()) {
    _this->_impl_.cpu_label_.Set(from._internal_cpu_label(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cpu_temp_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.cpu_temp_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CPUTempInfo)
}

inline void CPUTempInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cpu_label_){}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , decltype(_impl_.cpu_temp_){0}
  };
  _impl_.cpu_label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cpu_label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CPUTempInfo::~CPUTempInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.CPUTempInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CPUTempInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cpu_label_.Destroy();
}

void CPUTempInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CPUTempInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CPUTempInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.cpu_label_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cpu_temp_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.cpu_temp_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CPUTempInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string cpu_label = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_cpu_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cpu_temp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_cpu_temp(&has_bits);
          _impl_.cpu_temp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CPUTempInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CPUTempInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string cpu_label = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_cpu_label(), target);
  }

  // optional int32 cpu_temp = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_cpu_temp(), target);
  }

  // optional int64 timestamp = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CPUTempInfo)
  return target;
}

size_t CPUTempInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CPUTempInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string cpu_label = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cpu_label());
    }

    // optional int64 timestamp = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
    }

    // optional int32 cpu_temp = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cpu_temp());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CPUTempInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CPUTempInfo*>(
      &from));
}

void CPUTempInfo::MergeFrom(const CPUTempInfo& from) {
  CPUTempInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CPUTempInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_cpu_label(from._internal_cpu_label());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cpu_temp_ = from._impl_.cpu_temp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CPUTempInfo::CopyFrom(const CPUTempInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CPUTempInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CPUTempInfo::IsInitialized() const {
  return true;
}

void CPUTempInfo::InternalSwap(CPUTempInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cpu_label_, lhs_arena,
      &other->_impl_.cpu_label_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CPUTempInfo, _impl_.cpu_temp_)
      + sizeof(CPUTempInfo::_impl_.cpu_temp_)
      - PROTOBUF_FIELD_OFFSET(CPUTempInfo, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

std::string CPUTempInfo::GetTypeName() const {
  return "enterprise_management.CPUTempInfo";
}


// ===================================================================

class StatefulPartitionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<StatefulPartitionInfo>()._impl_._has_bits_);
  static void set_has_available_space(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_total_space(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_filesystem(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mount_source(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

StatefulPartitionInfo::StatefulPartitionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.StatefulPartitionInfo)
}
StatefulPartitionInfo::StatefulPartitionInfo(const StatefulPartitionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  StatefulPartitionInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filesystem_){}
    , decltype(_impl_.mount_source_){}
    , decltype(_impl_.available_space_){}
    , decltype(_impl_.total_space_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.filesystem_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filesystem_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filesystem()) {
    _this->_impl_.filesystem_.Set(from._internal_filesystem(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mount_source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mount_source_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mount_source()) {
    _this->_impl_.mount_source_.Set(from._internal_mount_source(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.available_space_, &from._impl_.available_space_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.total_space_) -
    reinterpret_cast<char*>(&_impl_.available_space_)) + sizeof(_impl_.total_space_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.StatefulPartitionInfo)
}

inline void StatefulPartitionInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filesystem_){}
    , decltype(_impl_.mount_source_){}
    , decltype(_impl_.available_space_){uint64_t{0u}}
    , decltype(_impl_.total_space_){uint64_t{0u}}
  };
  _impl_.filesystem_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filesystem_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mount_source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mount_source_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StatefulPartitionInfo::~StatefulPartitionInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.StatefulPartitionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatefulPartitionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.filesystem_.Destroy();
  _impl_.mount_source_.Destroy();
}

void StatefulPartitionInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatefulPartitionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.StatefulPartitionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.filesystem_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.mount_source_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.available_space_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.total_space_) -
        reinterpret_cast<char*>(&_impl_.available_space_)) + sizeof(_impl_.total_space_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StatefulPartitionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 available_space = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_available_space(&has_bits);
          _impl_.available_space_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 total_space = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_total_space(&has_bits);
          _impl_.total_space_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string filesystem = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_filesystem();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string mount_source = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_mount_source();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatefulPartitionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.StatefulPartitionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 available_space = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_available_space(), target);
  }

  // optional uint64 total_space = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_total_space(), target);
  }

  // optional string filesystem = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_filesystem(), target);
  }

  // optional string mount_source = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_mount_source(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.StatefulPartitionInfo)
  return target;
}

size_t StatefulPartitionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.StatefulPartitionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string filesystem = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filesystem());
    }

    // optional string mount_source = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_mount_source());
    }

    // optional uint64 available_space = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_available_space());
    }

    // optional uint64 total_space = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_total_space());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StatefulPartitionInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StatefulPartitionInfo*>(
      &from));
}

void StatefulPartitionInfo::MergeFrom(const StatefulPartitionInfo& from) {
  StatefulPartitionInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.StatefulPartitionInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_filesystem(from._internal_filesystem());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_mount_source(from._internal_mount_source());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.available_space_ = from._impl_.available_space_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.total_space_ = from._impl_.total_space_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StatefulPartitionInfo::CopyFrom(const StatefulPartitionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.StatefulPartitionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatefulPartitionInfo::IsInitialized() const {
  return true;
}

void StatefulPartitionInfo::InternalSwap(StatefulPartitionInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filesystem_, lhs_arena,
      &other->_impl_.filesystem_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mount_source_, lhs_arena,
      &other->_impl_.mount_source_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatefulPartitionInfo, _impl_.total_space_)
      + sizeof(StatefulPartitionInfo::_impl_.total_space_)
      - PROTOBUF_FIELD_OFFSET(StatefulPartitionInfo, _impl_.available_space_)>(
          reinterpret_cast<char*>(&_impl_.available_space_),
          reinterpret_cast<char*>(&other->_impl_.available_space_));
}

std::string StatefulPartitionInfo::GetTypeName() const {
  return "enterprise_management.StatefulPartitionInfo";
}


// ===================================================================

class BatterySample::_Internal {
 public:
  using HasBits = decltype(std::declval<BatterySample>()._impl_._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_voltage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_remaining_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_temperature(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_discharge_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_charge_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_current(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BatterySample::BatterySample(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.BatterySample)
}
BatterySample::BatterySample(const BatterySample& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BatterySample* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.voltage_){}
    , decltype(_impl_.remaining_capacity_){}
    , decltype(_impl_.temperature_){}
    , decltype(_impl_.discharge_rate_){}
    , decltype(_impl_.current_){}
    , decltype(_impl_.charge_rate_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.charge_rate_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.charge_rate_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.BatterySample)
}

inline void BatterySample::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_){}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , decltype(_impl_.voltage_){int64_t{0}}
    , decltype(_impl_.remaining_capacity_){int64_t{0}}
    , decltype(_impl_.temperature_){0}
    , decltype(_impl_.discharge_rate_){0}
    , decltype(_impl_.current_){int64_t{0}}
    , decltype(_impl_.charge_rate_){0}
  };
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BatterySample::~BatterySample() {
  // @@protoc_insertion_point(destructor:enterprise_management.BatterySample)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatterySample::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.status_.Destroy();
}

void BatterySample::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatterySample::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.BatterySample)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.status_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.charge_rate_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.charge_rate_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BatterySample::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 voltage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_voltage(&has_bits);
          _impl_.voltage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 remaining_capacity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_remaining_capacity(&has_bits);
          _impl_.remaining_capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 temperature = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_temperature(&has_bits);
          _impl_.temperature_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 discharge_rate = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_discharge_rate(&has_bits);
          _impl_.discharge_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 charge_rate = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_charge_rate(&has_bits);
          _impl_.charge_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 current = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_current(&has_bits);
          _impl_.current_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string status = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatterySample::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.BatterySample)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp(), target);
  }

  // optional int64 voltage = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_voltage(), target);
  }

  // optional int64 remaining_capacity = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_remaining_capacity(), target);
  }

  // optional int32 temperature = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_temperature(), target);
  }

  // optional int32 discharge_rate = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_discharge_rate(), target);
  }

  // optional int32 charge_rate = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_charge_rate(), target);
  }

  // optional int64 current = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_current(), target);
  }

  // optional string status = 8;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.BatterySample)
  return target;
}

size_t BatterySample::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.BatterySample)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string status = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_status());
    }

    // optional int64 timestamp = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
    }

    // optional int64 voltage = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_voltage());
    }

    // optional int64 remaining_capacity = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_remaining_capacity());
    }

    // optional int32 temperature = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_temperature());
    }

    // optional int32 discharge_rate = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_discharge_rate());
    }

    // optional int64 current = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_current());
    }

    // optional int32 charge_rate = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_charge_rate());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BatterySample::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BatterySample*>(
      &from));
}

void BatterySample::MergeFrom(const BatterySample& from) {
  BatterySample* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.BatterySample)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_status(from._internal_status());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.voltage_ = from._impl_.voltage_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.remaining_capacity_ = from._impl_.remaining_capacity_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.temperature_ = from._impl_.temperature_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.discharge_rate_ = from._impl_.discharge_rate_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.current_ = from._impl_.current_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.charge_rate_ = from._impl_.charge_rate_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BatterySample::CopyFrom(const BatterySample& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.BatterySample)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatterySample::IsInitialized() const {
  return true;
}

void BatterySample::InternalSwap(BatterySample* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BatterySample, _impl_.charge_rate_)
      + sizeof(BatterySample::_impl_.charge_rate_)
      - PROTOBUF_FIELD_OFFSET(BatterySample, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

std::string BatterySample::GetTypeName() const {
  return "enterprise_management.BatterySample";
}


// ===================================================================

class BatteryInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<BatteryInfo>()._impl_._has_bits_);
  static void set_has_serial(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_manufacturer(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_battery_health(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_design_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_full_charge_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_cycle_count(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_design_min_voltage(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_manufacture_date(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_technology(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

BatteryInfo::BatteryInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.BatteryInfo)
}
BatteryInfo::BatteryInfo(const BatteryInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BatteryInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.samples_){from._impl_.samples_}
    , decltype(_impl_.serial_){}
    , decltype(_impl_.manufacturer_){}
    , decltype(_impl_.battery_health_){}
    , decltype(_impl_.manufacture_date_){}
    , decltype(_impl_.technology_){}
    , decltype(_impl_.design_capacity_){}
    , decltype(_impl_.full_charge_capacity_){}
    , decltype(_impl_.cycle_count_){}
    , decltype(_impl_.design_min_voltage_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.serial_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serial_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serial()) {
    _this->_impl_.serial_.Set(from._internal_serial(), 
      _this->GetArenaForAllocation());
  }
  _impl_.manufacturer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_manufacturer()) {
    _this->_impl_.manufacturer_.Set(from._internal_manufacturer(), 
      _this->GetArenaForAllocation());
  }
  _impl_.battery_health_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.battery_health_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_battery_health()) {
    _this->_impl_.battery_health_.Set(from._internal_battery_health(), 
      _this->GetArenaForAllocation());
  }
  _impl_.manufacture_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacture_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_manufacture_date()) {
    _this->_impl_.manufacture_date_.Set(from._internal_manufacture_date(), 
      _this->GetArenaForAllocation());
  }
  _impl_.technology_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.technology_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_technology()) {
    _this->_impl_.technology_.Set(from._internal_technology(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.design_capacity_, &from._impl_.design_capacity_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.design_min_voltage_) -
    reinterpret_cast<char*>(&_impl_.design_capacity_)) + sizeof(_impl_.design_min_voltage_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.BatteryInfo)
}

inline void BatteryInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.samples_){arena}
    , decltype(_impl_.serial_){}
    , decltype(_impl_.manufacturer_){}
    , decltype(_impl_.battery_health_){}
    , decltype(_impl_.manufacture_date_){}
    , decltype(_impl_.technology_){}
    , decltype(_impl_.design_capacity_){int64_t{0}}
    , decltype(_impl_.full_charge_capacity_){int64_t{0}}
    , decltype(_impl_.cycle_count_){0}
    , decltype(_impl_.design_min_voltage_){0}
  };
  _impl_.serial_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serial_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.manufacturer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.battery_health_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.battery_health_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.manufacture_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacture_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.technology_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.technology_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BatteryInfo::~BatteryInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.BatteryInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatteryInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.samples_.~RepeatedPtrField();
  _impl_.serial_.Destroy();
  _impl_.manufacturer_.Destroy();
  _impl_.battery_health_.Destroy();
  _impl_.manufacture_date_.Destroy();
  _impl_.technology_.Destroy();
}

void BatteryInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatteryInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.BatteryInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.samples_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.serial_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.manufacturer_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.battery_health_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.manufacture_date_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.technology_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.design_capacity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cycle_count_) -
        reinterpret_cast<char*>(&_impl_.design_capacity_)) + sizeof(_impl_.cycle_count_));
  }
  _impl_.design_min_voltage_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BatteryInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string serial = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_serial();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string manufacturer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_manufacturer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string battery_health = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_battery_health();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 design_capacity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_design_capacity(&has_bits);
          _impl_.design_capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 full_charge_capacity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_full_charge_capacity(&has_bits);
          _impl_.full_charge_capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cycle_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_cycle_count(&has_bits);
          _impl_.cycle_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.BatterySample samples = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_samples(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 design_min_voltage = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_design_min_voltage(&has_bits);
          _impl_.design_min_voltage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string manufacture_date = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_manufacture_date();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string technology = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_technology();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatteryInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.BatteryInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string serial = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_serial(), target);
  }

  // optional string manufacturer = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_manufacturer(), target);
  }

  // optional string battery_health = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_battery_health(), target);
  }

  // optional int64 design_capacity = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_design_capacity(), target);
  }

  // optional int64 full_charge_capacity = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_full_charge_capacity(), target);
  }

  // optional int32 cycle_count = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_cycle_count(), target);
  }

  // repeated .enterprise_management.BatterySample samples = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_samples_size()); i < n; i++) {
    const auto& repfield = this->_internal_samples(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 design_min_voltage = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_design_min_voltage(), target);
  }

  // optional string manufacture_date = 10;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_manufacture_date(), target);
  }

  // optional string technology = 11;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_technology(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.BatteryInfo)
  return target;
}

size_t BatteryInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.BatteryInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.BatterySample samples = 7;
  total_size += 1UL * this->_internal_samples_size();
  for (const auto& msg : this->_impl_.samples_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string serial = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_serial());
    }

    // optional string manufacturer = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_manufacturer());
    }

    // optional string battery_health = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_battery_health());
    }

    // optional string manufacture_date = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_manufacture_date());
    }

    // optional string technology = 11;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_technology());
    }

    // optional int64 design_capacity = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_design_capacity());
    }

    // optional int64 full_charge_capacity = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_full_charge_capacity());
    }

    // optional int32 cycle_count = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cycle_count());
    }

  }
  // optional int32 design_min_voltage = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_design_min_voltage());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BatteryInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BatteryInfo*>(
      &from));
}

void BatteryInfo::MergeFrom(const BatteryInfo& from) {
  BatteryInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.BatteryInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.samples_.MergeFrom(from._impl_.samples_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_serial(from._internal_serial());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_manufacturer(from._internal_manufacturer());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_battery_health(from._internal_battery_health());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_manufacture_date(from._internal_manufacture_date());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_technology(from._internal_technology());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.design_capacity_ = from._impl_.design_capacity_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.full_charge_capacity_ = from._impl_.full_charge_capacity_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.cycle_count_ = from._impl_.cycle_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_design_min_voltage(from._internal_design_min_voltage());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BatteryInfo::CopyFrom(const BatteryInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.BatteryInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatteryInfo::IsInitialized() const {
  return true;
}

void BatteryInfo::InternalSwap(BatteryInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.samples_.InternalSwap(&other->_impl_.samples_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.serial_, lhs_arena,
      &other->_impl_.serial_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.manufacturer_, lhs_arena,
      &other->_impl_.manufacturer_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.battery_health_, lhs_arena,
      &other->_impl_.battery_health_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.manufacture_date_, lhs_arena,
      &other->_impl_.manufacture_date_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.technology_, lhs_arena,
      &other->_impl_.technology_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BatteryInfo, _impl_.design_min_voltage_)
      + sizeof(BatteryInfo::_impl_.design_min_voltage_)
      - PROTOBUF_FIELD_OFFSET(BatteryInfo, _impl_.design_capacity_)>(
          reinterpret_cast<char*>(&_impl_.design_capacity_),
          reinterpret_cast<char*>(&other->_impl_.design_capacity_));
}

std::string BatteryInfo::GetTypeName() const {
  return "enterprise_management.BatteryInfo";
}


// ===================================================================

class PowerStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<PowerStatus>()._impl_._has_bits_);
  static void set_has_power_source(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PowerStatus::PowerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PowerStatus)
}
PowerStatus::PowerStatus(const PowerStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PowerStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.batteries_){from._impl_.batteries_}
    , decltype(_impl_.power_source_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.power_source_ = from._impl_.power_source_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PowerStatus)
}

inline void PowerStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.batteries_){arena}
    , decltype(_impl_.power_source_){0}
  };
}

PowerStatus::~PowerStatus() {
  // @@protoc_insertion_point(destructor:enterprise_management.PowerStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PowerStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.batteries_.~RepeatedPtrField();
}

void PowerStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PowerStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PowerStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.batteries_.Clear();
  _impl_.power_source_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PowerStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.PowerStatus.PowerSource power_source = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::PowerStatus_PowerSource_IsValid(val))) {
            _internal_set_power_source(static_cast<::enterprise_management::PowerStatus_PowerSource>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.BatteryInfo batteries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_batteries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PowerStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PowerStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.PowerStatus.PowerSource power_source = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_power_source(), target);
  }

  // repeated .enterprise_management.BatteryInfo batteries = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_batteries_size()); i < n; i++) {
    const auto& repfield = this->_internal_batteries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PowerStatus)
  return target;
}

size_t PowerStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PowerStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.BatteryInfo batteries = 2;
  total_size += 1UL * this->_internal_batteries_size();
  for (const auto& msg : this->_impl_.batteries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .enterprise_management.PowerStatus.PowerSource power_source = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_power_source());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PowerStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PowerStatus*>(
      &from));
}

void PowerStatus::MergeFrom(const PowerStatus& from) {
  PowerStatus* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PowerStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.batteries_.MergeFrom(from._impl_.batteries_);
  if (from._internal_has_power_source()) {
    _this->_internal_set_power_source(from._internal_power_source());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PowerStatus::CopyFrom(const PowerStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PowerStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PowerStatus::IsInitialized() const {
  return true;
}

void PowerStatus::InternalSwap(PowerStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.batteries_.InternalSwap(&other->_impl_.batteries_);
  swap(_impl_.power_source_, other->_impl_.power_source_);
}

std::string PowerStatus::GetTypeName() const {
  return "enterprise_management.PowerStatus";
}


// ===================================================================

class DiskLifetimeEstimation::_Internal {
 public:
  using HasBits = decltype(std::declval<DiskLifetimeEstimation>()._impl_._has_bits_);
  static void set_has_slc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mlc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DiskLifetimeEstimation::DiskLifetimeEstimation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DiskLifetimeEstimation)
}
DiskLifetimeEstimation::DiskLifetimeEstimation(const DiskLifetimeEstimation& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DiskLifetimeEstimation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slc_){}
    , decltype(_impl_.mlc_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.slc_, &from._impl_.slc_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mlc_) -
    reinterpret_cast<char*>(&_impl_.slc_)) + sizeof(_impl_.mlc_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DiskLifetimeEstimation)
}

inline void DiskLifetimeEstimation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slc_){0}
    , decltype(_impl_.mlc_){0}
  };
}

DiskLifetimeEstimation::~DiskLifetimeEstimation() {
  // @@protoc_insertion_point(destructor:enterprise_management.DiskLifetimeEstimation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DiskLifetimeEstimation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DiskLifetimeEstimation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DiskLifetimeEstimation::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DiskLifetimeEstimation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.slc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.mlc_) -
        reinterpret_cast<char*>(&_impl_.slc_)) + sizeof(_impl_.mlc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DiskLifetimeEstimation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 slc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_slc(&has_bits);
          _impl_.slc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mlc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_mlc(&has_bits);
          _impl_.mlc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DiskLifetimeEstimation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DiskLifetimeEstimation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 slc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_slc(), target);
  }

  // optional int32 mlc = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_mlc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DiskLifetimeEstimation)
  return target;
}

size_t DiskLifetimeEstimation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DiskLifetimeEstimation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 slc = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slc());
    }

    // optional int32 mlc = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mlc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DiskLifetimeEstimation::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DiskLifetimeEstimation*>(
      &from));
}

void DiskLifetimeEstimation::MergeFrom(const DiskLifetimeEstimation& from) {
  DiskLifetimeEstimation* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DiskLifetimeEstimation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.slc_ = from._impl_.slc_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.mlc_ = from._impl_.mlc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DiskLifetimeEstimation::CopyFrom(const DiskLifetimeEstimation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DiskLifetimeEstimation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DiskLifetimeEstimation::IsInitialized() const {
  return true;
}

void DiskLifetimeEstimation::InternalSwap(DiskLifetimeEstimation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DiskLifetimeEstimation, _impl_.mlc_)
      + sizeof(DiskLifetimeEstimation::_impl_.mlc_)
      - PROTOBUF_FIELD_OFFSET(DiskLifetimeEstimation, _impl_.slc_)>(
          reinterpret_cast<char*>(&_impl_.slc_),
          reinterpret_cast<char*>(&other->_impl_.slc_));
}

std::string DiskLifetimeEstimation::GetTypeName() const {
  return "enterprise_management.DiskLifetimeEstimation";
}


// ===================================================================

class DiskInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<DiskInfo>()._impl_._has_bits_);
  static void set_has_serial(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_manufacturer(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_model(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_health(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_bytes_read_since_last_boot(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_bytes_written_since_last_boot(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_read_time_seconds_since_last_boot(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_write_time_seconds_since_last_boot(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_io_time_seconds_since_last_boot(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_discard_time_seconds_since_last_boot(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_purpose(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

DiskInfo::DiskInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DiskInfo)
}
DiskInfo::DiskInfo(const DiskInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DiskInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumes_){from._impl_.volumes_}
    , decltype(_impl_.serial_){}
    , decltype(_impl_.manufacturer_){}
    , decltype(_impl_.model_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.health_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.bytes_read_since_last_boot_){}
    , decltype(_impl_.bytes_written_since_last_boot_){}
    , decltype(_impl_.read_time_seconds_since_last_boot_){}
    , decltype(_impl_.write_time_seconds_since_last_boot_){}
    , decltype(_impl_.io_time_seconds_since_last_boot_){}
    , decltype(_impl_.discard_time_seconds_since_last_boot_){}
    , decltype(_impl_.purpose_){}
    , decltype(_impl_.vendor_id_){}
    , decltype(_impl_.product_id_){}
    , decltype(_impl_.hardware_revision_){}
    , decltype(_impl_.firmware_revision_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.serial_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serial_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serial()) {
    _this->_impl_.serial_.Set(from._internal_serial(), 
      _this->GetArenaForAllocation());
  }
  _impl_.manufacturer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_manufacturer()) {
    _this->_impl_.manufacturer_.Set(from._internal_manufacturer(), 
      _this->GetArenaForAllocation());
  }
  _impl_.model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model()) {
    _this->_impl_.model_.Set(from._internal_model(), 
      _this->GetArenaForAllocation());
  }
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.health_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.health_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_health()) {
    _this->_impl_.health_.Set(from._internal_health(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.size_, &from._impl_.size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.purpose_) -
    reinterpret_cast<char*>(&_impl_.size_)) + sizeof(_impl_.purpose_));
  clear_has_vendor_id();
  switch (from.vendor_id_case()) {
    case kNvmeSubsystemVendor: {
      _this->_internal_set_nvme_subsystem_vendor(from._internal_nvme_subsystem_vendor());
      break;
    }
    case kEmmcOemid: {
      _this->_internal_set_emmc_oemid(from._internal_emmc_oemid());
      break;
    }
    case kOtherVendor: {
      _this->_internal_set_other_vendor(from._internal_other_vendor());
      break;
    }
    case kJedecManfid: {
      _this->_internal_set_jedec_manfid(from._internal_jedec_manfid());
      break;
    }
    case VENDOR_ID_NOT_SET: {
      break;
    }
  }
  clear_has_product_id();
  switch (from.product_id_case()) {
    case kNvmeSubsystemDevice: {
      _this->_internal_set_nvme_subsystem_device(from._internal_nvme_subsystem_device());
      break;
    }
    case kEmmcPnm: {
      _this->_internal_set_emmc_pnm(from._internal_emmc_pnm());
      break;
    }
    case kOtherProduct: {
      _this->_internal_set_other_product(from._internal_other_product());
      break;
    }
    case PRODUCT_ID_NOT_SET: {
      break;
    }
  }
  clear_has_hardware_revision();
  switch (from.hardware_revision_case()) {
    case kNvmeHardwareRev: {
      _this->_internal_set_nvme_hardware_rev(from._internal_nvme_hardware_rev());
      break;
    }
    case kEmmcHardwareRev: {
      _this->_internal_set_emmc_hardware_rev(from._internal_emmc_hardware_rev());
      break;
    }
    case kOtherHardwareRev: {
      _this->_internal_set_other_hardware_rev(from._internal_other_hardware_rev());
      break;
    }
    case HARDWARE_REVISION_NOT_SET: {
      break;
    }
  }
  clear_has_firmware_revision();
  switch (from.firmware_revision_case()) {
    case kNvmeFirmwareRev: {
      _this->_internal_set_nvme_firmware_rev(from._internal_nvme_firmware_rev());
      break;
    }
    case kEmmcFirmwareRev: {
      _this->_internal_set_emmc_firmware_rev(from._internal_emmc_firmware_rev());
      break;
    }
    case kOtherFirmwareRev: {
      _this->_internal_set_other_firmware_rev(from._internal_other_firmware_rev());
      break;
    }
    case kUfsFirmwareRev: {
      _this->_internal_set_ufs_firmware_rev(from._internal_ufs_firmware_rev());
      break;
    }
    case FIRMWARE_REVISION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DiskInfo)
}

inline void DiskInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volumes_){arena}
    , decltype(_impl_.serial_){}
    , decltype(_impl_.manufacturer_){}
    , decltype(_impl_.model_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.health_){}
    , decltype(_impl_.size_){int64_t{0}}
    , decltype(_impl_.bytes_read_since_last_boot_){uint64_t{0u}}
    , decltype(_impl_.bytes_written_since_last_boot_){uint64_t{0u}}
    , decltype(_impl_.read_time_seconds_since_last_boot_){uint64_t{0u}}
    , decltype(_impl_.write_time_seconds_since_last_boot_){uint64_t{0u}}
    , decltype(_impl_.io_time_seconds_since_last_boot_){uint64_t{0u}}
    , decltype(_impl_.discard_time_seconds_since_last_boot_){uint64_t{0u}}
    , decltype(_impl_.purpose_){0}
    , decltype(_impl_.vendor_id_){}
    , decltype(_impl_.product_id_){}
    , decltype(_impl_.hardware_revision_){}
    , decltype(_impl_.firmware_revision_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.serial_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serial_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.manufacturer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.health_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.health_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_vendor_id();
  clear_has_product_id();
  clear_has_hardware_revision();
  clear_has_firmware_revision();
}

DiskInfo::~DiskInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.DiskInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DiskInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.volumes_.~RepeatedPtrField();
  _impl_.serial_.Destroy();
  _impl_.manufacturer_.Destroy();
  _impl_.model_.Destroy();
  _impl_.type_.Destroy();
  _impl_.health_.Destroy();
  if (has_vendor_id()) {
    clear_vendor_id();
  }
  if (has_product_id()) {
    clear_product_id();
  }
  if (has_hardware_revision()) {
    clear_hardware_revision();
  }
  if (has_firmware_revision()) {
    clear_firmware_revision();
  }
}

void DiskInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DiskInfo::clear_vendor_id() {
// @@protoc_insertion_point(one_of_clear_start:enterprise_management.DiskInfo)
  switch (vendor_id_case()) {
    case kNvmeSubsystemVendor: {
      // No need to clear
      break;
    }
    case kEmmcOemid: {
      // No need to clear
      break;
    }
    case kOtherVendor: {
      // No need to clear
      break;
    }
    case kJedecManfid: {
      // No need to clear
      break;
    }
    case VENDOR_ID_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = VENDOR_ID_NOT_SET;
}

void DiskInfo::clear_product_id() {
// @@protoc_insertion_point(one_of_clear_start:enterprise_management.DiskInfo)
  switch (product_id_case()) {
    case kNvmeSubsystemDevice: {
      // No need to clear
      break;
    }
    case kEmmcPnm: {
      // No need to clear
      break;
    }
    case kOtherProduct: {
      // No need to clear
      break;
    }
    case PRODUCT_ID_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = PRODUCT_ID_NOT_SET;
}

void DiskInfo::clear_hardware_revision() {
// @@protoc_insertion_point(one_of_clear_start:enterprise_management.DiskInfo)
  switch (hardware_revision_case()) {
    case kNvmeHardwareRev: {
      // No need to clear
      break;
    }
    case kEmmcHardwareRev: {
      // No need to clear
      break;
    }
    case kOtherHardwareRev: {
      // No need to clear
      break;
    }
    case HARDWARE_REVISION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[2] = HARDWARE_REVISION_NOT_SET;
}

void DiskInfo::clear_firmware_revision() {
// @@protoc_insertion_point(one_of_clear_start:enterprise_management.DiskInfo)
  switch (firmware_revision_case()) {
    case kNvmeFirmwareRev: {
      // No need to clear
      break;
    }
    case kEmmcFirmwareRev: {
      // No need to clear
      break;
    }
    case kOtherFirmwareRev: {
      // No need to clear
      break;
    }
    case kUfsFirmwareRev: {
      // No need to clear
      break;
    }
    case FIRMWARE_REVISION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[3] = FIRMWARE_REVISION_NOT_SET;
}


void DiskInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DiskInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.volumes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.serial_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.manufacturer_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.model_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.health_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.bytes_written_since_last_boot_) -
        reinterpret_cast<char*>(&_impl_.size_)) + sizeof(_impl_.bytes_written_since_last_boot_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&_impl_.read_time_seconds_since_last_boot_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.purpose_) -
        reinterpret_cast<char*>(&_impl_.read_time_seconds_since_last_boot_)) + sizeof(_impl_.purpose_));
  }
  clear_vendor_id();
  clear_product_id();
  clear_hardware_revision();
  clear_firmware_revision();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DiskInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string serial = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_serial();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string manufacturer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_manufacturer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_model();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string health = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_health();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string volumes = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_volumes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 bytes_read_since_last_boot = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_bytes_read_since_last_boot(&has_bits);
          _impl_.bytes_read_since_last_boot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 bytes_written_since_last_boot = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_bytes_written_since_last_boot(&has_bits);
          _impl_.bytes_written_since_last_boot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 read_time_seconds_since_last_boot = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_read_time_seconds_since_last_boot(&has_bits);
          _impl_.read_time_seconds_since_last_boot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 write_time_seconds_since_last_boot = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_write_time_seconds_since_last_boot(&has_bits);
          _impl_.write_time_seconds_since_last_boot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 io_time_seconds_since_last_boot = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_io_time_seconds_since_last_boot(&has_bits);
          _impl_.io_time_seconds_since_last_boot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 discard_time_seconds_since_last_boot = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_discard_time_seconds_since_last_boot(&has_bits);
          _impl_.discard_time_seconds_since_last_boot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 nvme_subsystem_vendor = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _internal_set_nvme_subsystem_vendor(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 emmc_oemid = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _internal_set_emmc_oemid(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 other_vendor = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _internal_set_other_vendor(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 nvme_subsystem_device = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _internal_set_nvme_subsystem_device(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 emmc_pnm = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _internal_set_emmc_pnm(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 other_product = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _internal_set_other_product(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 nvme_hardware_rev = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _internal_set_nvme_hardware_rev(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 emmc_hardware_rev = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _internal_set_emmc_hardware_rev(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 other_hardware_rev = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _internal_set_other_hardware_rev(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 nvme_firmware_rev = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _internal_set_nvme_firmware_rev(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 emmc_firmware_rev = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _internal_set_emmc_firmware_rev(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 other_firmware_rev = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _internal_set_other_firmware_rev(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DiskInfo.DevicePurpose purpose = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DiskInfo_DevicePurpose_IsValid(val))) {
            _internal_set_purpose(static_cast<::enterprise_management::DiskInfo_DevicePurpose>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(26, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // uint32 jedec_manfid = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _internal_set_jedec_manfid(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ufs_firmware_rev = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _internal_set_ufs_firmware_rev(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DiskInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DiskInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string serial = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_serial(), target);
  }

  // optional string manufacturer = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_manufacturer(), target);
  }

  // optional string model = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_model(), target);
  }

  // optional int64 size = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_size(), target);
  }

  // optional string type = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_type(), target);
  }

  // optional string health = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_health(), target);
  }

  // repeated string volumes = 7;
  for (int i = 0, n = this->_internal_volumes_size(); i < n; i++) {
    const auto& s = this->_internal_volumes(i);
    target = stream->WriteString(7, s, target);
  }

  // optional uint64 bytes_read_since_last_boot = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_bytes_read_since_last_boot(), target);
  }

  // optional uint64 bytes_written_since_last_boot = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_bytes_written_since_last_boot(), target);
  }

  // optional uint64 read_time_seconds_since_last_boot = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_read_time_seconds_since_last_boot(), target);
  }

  // optional uint64 write_time_seconds_since_last_boot = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(11, this->_internal_write_time_seconds_since_last_boot(), target);
  }

  // optional uint64 io_time_seconds_since_last_boot = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(12, this->_internal_io_time_seconds_since_last_boot(), target);
  }

  // optional uint64 discard_time_seconds_since_last_boot = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(13, this->_internal_discard_time_seconds_since_last_boot(), target);
  }

  switch (vendor_id_case()) {
    case kNvmeSubsystemVendor: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_nvme_subsystem_vendor(), target);
      break;
    }
    case kEmmcOemid: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_emmc_oemid(), target);
      break;
    }
    case kOtherVendor: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_other_vendor(), target);
      break;
    }
    default: ;
  }
  switch (product_id_case()) {
    case kNvmeSubsystemDevice: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_nvme_subsystem_device(), target);
      break;
    }
    case kEmmcPnm: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_emmc_pnm(), target);
      break;
    }
    case kOtherProduct: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_other_product(), target);
      break;
    }
    default: ;
  }
  switch (hardware_revision_case()) {
    case kNvmeHardwareRev: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_nvme_hardware_rev(), target);
      break;
    }
    case kEmmcHardwareRev: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_emmc_hardware_rev(), target);
      break;
    }
    case kOtherHardwareRev: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_other_hardware_rev(), target);
      break;
    }
    default: ;
  }
  switch (firmware_revision_case()) {
    case kNvmeFirmwareRev: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(23, this->_internal_nvme_firmware_rev(), target);
      break;
    }
    case kEmmcFirmwareRev: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(24, this->_internal_emmc_firmware_rev(), target);
      break;
    }
    case kOtherFirmwareRev: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(25, this->_internal_other_firmware_rev(), target);
      break;
    }
    default: ;
  }
  // optional .enterprise_management.DiskInfo.DevicePurpose purpose = 26;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      26, this->_internal_purpose(), target);
  }

  // uint32 jedec_manfid = 27;
  if (_internal_has_jedec_manfid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_jedec_manfid(), target);
  }

  // uint32 ufs_firmware_rev = 28;
  if (_internal_has_ufs_firmware_rev()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(28, this->_internal_ufs_firmware_rev(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DiskInfo)
  return target;
}

size_t DiskInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DiskInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string volumes = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.volumes_.size());
  for (int i = 0, n = _impl_.volumes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.volumes_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string serial = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_serial());
    }

    // optional string manufacturer = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_manufacturer());
    }

    // optional string model = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model());
    }

    // optional string type = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

    // optional string health = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_health());
    }

    // optional int64 size = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

    // optional uint64 bytes_read_since_last_boot = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bytes_read_since_last_boot());
    }

    // optional uint64 bytes_written_since_last_boot = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bytes_written_since_last_boot());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional uint64 read_time_seconds_since_last_boot = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_read_time_seconds_since_last_boot());
    }

    // optional uint64 write_time_seconds_since_last_boot = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_write_time_seconds_since_last_boot());
    }

    // optional uint64 io_time_seconds_since_last_boot = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_io_time_seconds_since_last_boot());
    }

    // optional uint64 discard_time_seconds_since_last_boot = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_discard_time_seconds_since_last_boot());
    }

    // optional .enterprise_management.DiskInfo.DevicePurpose purpose = 26;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_purpose());
    }

  }
  switch (vendor_id_case()) {
    // uint32 nvme_subsystem_vendor = 14;
    case kNvmeSubsystemVendor: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nvme_subsystem_vendor());
      break;
    }
    // uint32 emmc_oemid = 15;
    case kEmmcOemid: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_emmc_oemid());
      break;
    }
    // uint32 other_vendor = 16;
    case kOtherVendor: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_other_vendor());
      break;
    }
    // uint32 jedec_manfid = 27;
    case kJedecManfid: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_jedec_manfid());
      break;
    }
    case VENDOR_ID_NOT_SET: {
      break;
    }
  }
  switch (product_id_case()) {
    // uint32 nvme_subsystem_device = 17;
    case kNvmeSubsystemDevice: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_nvme_subsystem_device());
      break;
    }
    // uint32 emmc_pnm = 18;
    case kEmmcPnm: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_emmc_pnm());
      break;
    }
    // uint32 other_product = 19;
    case kOtherProduct: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_other_product());
      break;
    }
    case PRODUCT_ID_NOT_SET: {
      break;
    }
  }
  switch (hardware_revision_case()) {
    // uint32 nvme_hardware_rev = 20;
    case kNvmeHardwareRev: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_nvme_hardware_rev());
      break;
    }
    // uint32 emmc_hardware_rev = 21;
    case kEmmcHardwareRev: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_emmc_hardware_rev());
      break;
    }
    // uint32 other_hardware_rev = 22;
    case kOtherHardwareRev: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_other_hardware_rev());
      break;
    }
    case HARDWARE_REVISION_NOT_SET: {
      break;
    }
  }
  switch (firmware_revision_case()) {
    // uint64 nvme_firmware_rev = 23;
    case kNvmeFirmwareRev: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_nvme_firmware_rev());
      break;
    }
    // uint64 emmc_firmware_rev = 24;
    case kEmmcFirmwareRev: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_emmc_firmware_rev());
      break;
    }
    // uint32 other_firmware_rev = 25;
    case kOtherFirmwareRev: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_other_firmware_rev());
      break;
    }
    // uint32 ufs_firmware_rev = 28;
    case kUfsFirmwareRev: {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_ufs_firmware_rev());
      break;
    }
    case FIRMWARE_REVISION_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DiskInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DiskInfo*>(
      &from));
}

void DiskInfo::MergeFrom(const DiskInfo& from) {
  DiskInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DiskInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.volumes_.MergeFrom(from._impl_.volumes_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_serial(from._internal_serial());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_manufacturer(from._internal_manufacturer());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_model(from._internal_model());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_health(from._internal_health());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.bytes_read_since_last_boot_ = from._impl_.bytes_read_since_last_boot_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.bytes_written_since_last_boot_ = from._impl_.bytes_written_since_last_boot_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.read_time_seconds_since_last_boot_ = from._impl_.read_time_seconds_since_last_boot_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.write_time_seconds_since_last_boot_ = from._impl_.write_time_seconds_since_last_boot_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.io_time_seconds_since_last_boot_ = from._impl_.io_time_seconds_since_last_boot_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.discard_time_seconds_since_last_boot_ = from._impl_.discard_time_seconds_since_last_boot_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.purpose_ = from._impl_.purpose_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.vendor_id_case()) {
    case kNvmeSubsystemVendor: {
      _this->_internal_set_nvme_subsystem_vendor(from._internal_nvme_subsystem_vendor());
      break;
    }
    case kEmmcOemid: {
      _this->_internal_set_emmc_oemid(from._internal_emmc_oemid());
      break;
    }
    case kOtherVendor: {
      _this->_internal_set_other_vendor(from._internal_other_vendor());
      break;
    }
    case kJedecManfid: {
      _this->_internal_set_jedec_manfid(from._internal_jedec_manfid());
      break;
    }
    case VENDOR_ID_NOT_SET: {
      break;
    }
  }
  switch (from.product_id_case()) {
    case kNvmeSubsystemDevice: {
      _this->_internal_set_nvme_subsystem_device(from._internal_nvme_subsystem_device());
      break;
    }
    case kEmmcPnm: {
      _this->_internal_set_emmc_pnm(from._internal_emmc_pnm());
      break;
    }
    case kOtherProduct: {
      _this->_internal_set_other_product(from._internal_other_product());
      break;
    }
    case PRODUCT_ID_NOT_SET: {
      break;
    }
  }
  switch (from.hardware_revision_case()) {
    case kNvmeHardwareRev: {
      _this->_internal_set_nvme_hardware_rev(from._internal_nvme_hardware_rev());
      break;
    }
    case kEmmcHardwareRev: {
      _this->_internal_set_emmc_hardware_rev(from._internal_emmc_hardware_rev());
      break;
    }
    case kOtherHardwareRev: {
      _this->_internal_set_other_hardware_rev(from._internal_other_hardware_rev());
      break;
    }
    case HARDWARE_REVISION_NOT_SET: {
      break;
    }
  }
  switch (from.firmware_revision_case()) {
    case kNvmeFirmwareRev: {
      _this->_internal_set_nvme_firmware_rev(from._internal_nvme_firmware_rev());
      break;
    }
    case kEmmcFirmwareRev: {
      _this->_internal_set_emmc_firmware_rev(from._internal_emmc_firmware_rev());
      break;
    }
    case kOtherFirmwareRev: {
      _this->_internal_set_other_firmware_rev(from._internal_other_firmware_rev());
      break;
    }
    case kUfsFirmwareRev: {
      _this->_internal_set_ufs_firmware_rev(from._internal_ufs_firmware_rev());
      break;
    }
    case FIRMWARE_REVISION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DiskInfo::CopyFrom(const DiskInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DiskInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DiskInfo::IsInitialized() const {
  return true;
}

void DiskInfo::InternalSwap(DiskInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.volumes_.InternalSwap(&other->_impl_.volumes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.serial_, lhs_arena,
      &other->_impl_.serial_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.manufacturer_, lhs_arena,
      &other->_impl_.manufacturer_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.model_, lhs_arena,
      &other->_impl_.model_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.health_, lhs_arena,
      &other->_impl_.health_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DiskInfo, _impl_.purpose_)
      + sizeof(DiskInfo::_impl_.purpose_)
      - PROTOBUF_FIELD_OFFSET(DiskInfo, _impl_.size_)>(
          reinterpret_cast<char*>(&_impl_.size_),
          reinterpret_cast<char*>(&other->_impl_.size_));
  swap(_impl_.vendor_id_, other->_impl_.vendor_id_);
  swap(_impl_.product_id_, other->_impl_.product_id_);
  swap(_impl_.hardware_revision_, other->_impl_.hardware_revision_);
  swap(_impl_.firmware_revision_, other->_impl_.firmware_revision_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
  swap(_impl_._oneof_case_[2], other->_impl_._oneof_case_[2]);
  swap(_impl_._oneof_case_[3], other->_impl_._oneof_case_[3]);
}

std::string DiskInfo::GetTypeName() const {
  return "enterprise_management.DiskInfo";
}


// ===================================================================

class StorageStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<StorageStatus>()._impl_._has_bits_);
  static const ::enterprise_management::DiskLifetimeEstimation& lifetime_estimation(const StorageStatus* msg);
  static void set_has_lifetime_estimation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::enterprise_management::DiskLifetimeEstimation&
StorageStatus::_Internal::lifetime_estimation(const StorageStatus* msg) {
  return *msg->_impl_.lifetime_estimation_;
}
StorageStatus::StorageStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.StorageStatus)
}
StorageStatus::StorageStatus(const StorageStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  StorageStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.disks_){from._impl_.disks_}
    , decltype(_impl_.lifetime_estimation_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_lifetime_estimation()) {
    _this->_impl_.lifetime_estimation_ = new ::enterprise_management::DiskLifetimeEstimation(*from._impl_.lifetime_estimation_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.StorageStatus)
}

inline void StorageStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.disks_){arena}
    , decltype(_impl_.lifetime_estimation_){nullptr}
  };
}

StorageStatus::~StorageStatus() {
  // @@protoc_insertion_point(destructor:enterprise_management.StorageStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StorageStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.disks_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.lifetime_estimation_;
}

void StorageStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StorageStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.StorageStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.disks_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.lifetime_estimation_ != nullptr);
    _impl_.lifetime_estimation_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StorageStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .enterprise_management.DiskInfo disks = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_disks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DiskLifetimeEstimation lifetime_estimation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_lifetime_estimation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StorageStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.StorageStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .enterprise_management.DiskInfo disks = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_disks_size()); i < n; i++) {
    const auto& repfield = this->_internal_disks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DiskLifetimeEstimation lifetime_estimation = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::lifetime_estimation(this),
        _Internal::lifetime_estimation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.StorageStatus)
  return target;
}

size_t StorageStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.StorageStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.DiskInfo disks = 1;
  total_size += 1UL * this->_internal_disks_size();
  for (const auto& msg : this->_impl_.disks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .enterprise_management.DiskLifetimeEstimation lifetime_estimation = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.lifetime_estimation_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StorageStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StorageStatus*>(
      &from));
}

void StorageStatus::MergeFrom(const StorageStatus& from) {
  StorageStatus* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.StorageStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.disks_.MergeFrom(from._impl_.disks_);
  if (from._internal_has_lifetime_estimation()) {
    _this->_internal_mutable_lifetime_estimation()->::enterprise_management::DiskLifetimeEstimation::MergeFrom(
        from._internal_lifetime_estimation());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StorageStatus::CopyFrom(const StorageStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.StorageStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StorageStatus::IsInitialized() const {
  return true;
}

void StorageStatus::InternalSwap(StorageStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.disks_.InternalSwap(&other->_impl_.disks_);
  swap(_impl_.lifetime_estimation_, other->_impl_.lifetime_estimation_);
}

std::string StorageStatus::GetTypeName() const {
  return "enterprise_management.StorageStatus";
}


// ===================================================================

class ThermalSample::_Internal {
 public:
  using HasBits = decltype(std::declval<ThermalSample>()._impl_._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_temperature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ThermalSample::ThermalSample(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ThermalSample)
}
ThermalSample::ThermalSample(const ThermalSample& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ThermalSample* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.temperature_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.temperature_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.temperature_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ThermalSample)
}

inline void ThermalSample::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , decltype(_impl_.temperature_){0}
  };
}

ThermalSample::~ThermalSample() {
  // @@protoc_insertion_point(destructor:enterprise_management.ThermalSample)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThermalSample::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ThermalSample::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThermalSample::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ThermalSample)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.temperature_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.temperature_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThermalSample::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 temperature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_temperature(&has_bits);
          _impl_.temperature_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThermalSample::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ThermalSample)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp(), target);
  }

  // optional int32 temperature = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_temperature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ThermalSample)
  return target;
}

size_t ThermalSample::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ThermalSample)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
    }

    // optional int32 temperature = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_temperature());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThermalSample::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThermalSample*>(
      &from));
}

void ThermalSample::MergeFrom(const ThermalSample& from) {
  ThermalSample* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ThermalSample)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.temperature_ = from._impl_.temperature_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThermalSample::CopyFrom(const ThermalSample& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ThermalSample)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThermalSample::IsInitialized() const {
  return true;
}

void ThermalSample::InternalSwap(ThermalSample* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ThermalSample, _impl_.temperature_)
      + sizeof(ThermalSample::_impl_.temperature_)
      - PROTOBUF_FIELD_OFFSET(ThermalSample, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

std::string ThermalSample::GetTypeName() const {
  return "enterprise_management.ThermalSample";
}


// ===================================================================

class ThermalInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ThermalInfo>()._impl_._has_bits_);
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ThermalInfo::ThermalInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ThermalInfo)
}
ThermalInfo::ThermalInfo(const ThermalInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ThermalInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.samples_){from._impl_.samples_}
    , decltype(_impl_.label_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_label()) {
    _this->_impl_.label_.Set(from._internal_label(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ThermalInfo)
}

inline void ThermalInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.samples_){arena}
    , decltype(_impl_.label_){}
  };
  _impl_.label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ThermalInfo::~ThermalInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.ThermalInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThermalInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.samples_.~RepeatedPtrField();
  _impl_.label_.Destroy();
}

void ThermalInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThermalInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ThermalInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.samples_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.label_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThermalInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string label = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.ThermalSample samples = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_samples(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThermalInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ThermalInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string label = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_label(), target);
  }

  // repeated .enterprise_management.ThermalSample samples = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_samples_size()); i < n; i++) {
    const auto& repfield = this->_internal_samples(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ThermalInfo)
  return target;
}

size_t ThermalInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ThermalInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.ThermalSample samples = 3;
  total_size += 1UL * this->_internal_samples_size();
  for (const auto& msg : this->_impl_.samples_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string label = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_label());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThermalInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThermalInfo*>(
      &from));
}

void ThermalInfo::MergeFrom(const ThermalInfo& from) {
  ThermalInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ThermalInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.samples_.MergeFrom(from._impl_.samples_);
  if (from._internal_has_label()) {
    _this->_internal_set_label(from._internal_label());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThermalInfo::CopyFrom(const ThermalInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ThermalInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThermalInfo::IsInitialized() const {
  return true;
}

void ThermalInfo::InternalSwap(ThermalInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.samples_.InternalSwap(&other->_impl_.samples_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.label_, lhs_arena,
      &other->_impl_.label_, rhs_arena
  );
}

std::string ThermalInfo::GetTypeName() const {
  return "enterprise_management.ThermalInfo";
}


// ===================================================================

class BoardStatus::_Internal {
 public:
};

BoardStatus::BoardStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.BoardStatus)
}
BoardStatus::BoardStatus(const BoardStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BoardStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.thermal_infos_){from._impl_.thermal_infos_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.BoardStatus)
}

inline void BoardStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.thermal_infos_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BoardStatus::~BoardStatus() {
  // @@protoc_insertion_point(destructor:enterprise_management.BoardStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BoardStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.thermal_infos_.~RepeatedPtrField();
}

void BoardStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BoardStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.BoardStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.thermal_infos_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BoardStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .enterprise_management.ThermalInfo thermal_infos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_thermal_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BoardStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.BoardStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .enterprise_management.ThermalInfo thermal_infos = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_thermal_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_thermal_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.BoardStatus)
  return target;
}

size_t BoardStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.BoardStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.ThermalInfo thermal_infos = 1;
  total_size += 1UL * this->_internal_thermal_infos_size();
  for (const auto& msg : this->_impl_.thermal_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BoardStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BoardStatus*>(
      &from));
}

void BoardStatus::MergeFrom(const BoardStatus& from) {
  BoardStatus* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.BoardStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.thermal_infos_.MergeFrom(from._impl_.thermal_infos_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BoardStatus::CopyFrom(const BoardStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.BoardStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BoardStatus::IsInitialized() const {
  return true;
}

void BoardStatus::InternalSwap(BoardStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.thermal_infos_.InternalSwap(&other->_impl_.thermal_infos_);
}

std::string BoardStatus::GetTypeName() const {
  return "enterprise_management.BoardStatus";
}


// ===================================================================

class SystemStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemStatus>()._impl_._has_bits_);
  static void set_has_vpd_sku_number(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_first_power_date(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_manufacture_date(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_marketing_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_bios_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_board_name(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_board_version(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_chassis_type(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_product_name(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_vpd_serial_number(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

SystemStatus::SystemStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.SystemStatus)
}
SystemStatus::SystemStatus(const SystemStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SystemStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vpd_sku_number_){}
    , decltype(_impl_.first_power_date_){}
    , decltype(_impl_.manufacture_date_){}
    , decltype(_impl_.marketing_name_){}
    , decltype(_impl_.bios_version_){}
    , decltype(_impl_.board_name_){}
    , decltype(_impl_.board_version_){}
    , decltype(_impl_.product_name_){}
    , decltype(_impl_.vpd_serial_number_){}
    , decltype(_impl_.chassis_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.vpd_sku_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vpd_sku_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vpd_sku_number()) {
    _this->_impl_.vpd_sku_number_.Set(from._internal_vpd_sku_number(), 
      _this->GetArenaForAllocation());
  }
  _impl_.first_power_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.first_power_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_first_power_date()) {
    _this->_impl_.first_power_date_.Set(from._internal_first_power_date(), 
      _this->GetArenaForAllocation());
  }
  _impl_.manufacture_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacture_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_manufacture_date()) {
    _this->_impl_.manufacture_date_.Set(from._internal_manufacture_date(), 
      _this->GetArenaForAllocation());
  }
  _impl_.marketing_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.marketing_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_marketing_name()) {
    _this->_impl_.marketing_name_.Set(from._internal_marketing_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.bios_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bios_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bios_version()) {
    _this->_impl_.bios_version_.Set(from._internal_bios_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.board_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.board_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_board_name()) {
    _this->_impl_.board_name_.Set(from._internal_board_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.board_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.board_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_board_version()) {
    _this->_impl_.board_version_.Set(from._internal_board_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.product_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.product_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_product_name()) {
    _this->_impl_.product_name_.Set(from._internal_product_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.vpd_serial_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vpd_serial_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vpd_serial_number()) {
    _this->_impl_.vpd_serial_number_.Set(from._internal_vpd_serial_number(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.chassis_type_ = from._impl_.chassis_type_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.SystemStatus)
}

inline void SystemStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vpd_sku_number_){}
    , decltype(_impl_.first_power_date_){}
    , decltype(_impl_.manufacture_date_){}
    , decltype(_impl_.marketing_name_){}
    , decltype(_impl_.bios_version_){}
    , decltype(_impl_.board_name_){}
    , decltype(_impl_.board_version_){}
    , decltype(_impl_.product_name_){}
    , decltype(_impl_.vpd_serial_number_){}
    , decltype(_impl_.chassis_type_){uint64_t{0u}}
  };
  _impl_.vpd_sku_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vpd_sku_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.first_power_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.first_power_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.manufacture_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacture_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.marketing_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.marketing_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bios_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bios_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.board_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.board_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.board_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.board_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.product_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.product_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vpd_serial_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vpd_serial_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SystemStatus::~SystemStatus() {
  // @@protoc_insertion_point(destructor:enterprise_management.SystemStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vpd_sku_number_.Destroy();
  _impl_.first_power_date_.Destroy();
  _impl_.manufacture_date_.Destroy();
  _impl_.marketing_name_.Destroy();
  _impl_.bios_version_.Destroy();
  _impl_.board_name_.Destroy();
  _impl_.board_version_.Destroy();
  _impl_.product_name_.Destroy();
  _impl_.vpd_serial_number_.Destroy();
}

void SystemStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SystemStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.SystemStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.vpd_sku_number_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.first_power_date_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.manufacture_date_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.marketing_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.bios_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.board_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.board_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.product_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000100u) {
    _impl_.vpd_serial_number_.ClearNonDefaultToEmpty();
  }
  _impl_.chassis_type_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string vpd_sku_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_vpd_sku_number();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string first_power_date = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_first_power_date();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string manufacture_date = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_manufacture_date();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string marketing_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_marketing_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string bios_version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_bios_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string board_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_board_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string board_version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_board_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 chassis_type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_chassis_type(&has_bits);
          _impl_.chassis_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string product_name = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_product_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string vpd_serial_number = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_vpd_serial_number();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.SystemStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string vpd_sku_number = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_vpd_sku_number(), target);
  }

  // optional string first_power_date = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_first_power_date(), target);
  }

  // optional string manufacture_date = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_manufacture_date(), target);
  }

  // optional string marketing_name = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_marketing_name(), target);
  }

  // optional string bios_version = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_bios_version(), target);
  }

  // optional string board_name = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_board_name(), target);
  }

  // optional string board_version = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_board_version(), target);
  }

  // optional uint64 chassis_type = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_chassis_type(), target);
  }

  // optional string product_name = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_product_name(), target);
  }

  // optional string vpd_serial_number = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_vpd_serial_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.SystemStatus)
  return target;
}

size_t SystemStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.SystemStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string vpd_sku_number = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_vpd_sku_number());
    }

    // optional string first_power_date = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_first_power_date());
    }

    // optional string manufacture_date = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_manufacture_date());
    }

    // optional string marketing_name = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_marketing_name());
    }

    // optional string bios_version = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_bios_version());
    }

    // optional string board_name = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_board_name());
    }

    // optional string board_version = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_board_version());
    }

    // optional string product_name = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_product_name());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional string vpd_serial_number = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_vpd_serial_number());
    }

    // optional uint64 chassis_type = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_chassis_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemStatus*>(
      &from));
}

void SystemStatus::MergeFrom(const SystemStatus& from) {
  SystemStatus* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.SystemStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_vpd_sku_number(from._internal_vpd_sku_number());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_first_power_date(from._internal_first_power_date());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_manufacture_date(from._internal_manufacture_date());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_marketing_name(from._internal_marketing_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_bios_version(from._internal_bios_version());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_board_name(from._internal_board_name());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_board_version(from._internal_board_version());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_product_name(from._internal_product_name());
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_set_vpd_serial_number(from._internal_vpd_serial_number());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.chassis_type_ = from._impl_.chassis_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemStatus::CopyFrom(const SystemStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.SystemStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemStatus::IsInitialized() const {
  return true;
}

void SystemStatus::InternalSwap(SystemStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vpd_sku_number_, lhs_arena,
      &other->_impl_.vpd_sku_number_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.first_power_date_, lhs_arena,
      &other->_impl_.first_power_date_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.manufacture_date_, lhs_arena,
      &other->_impl_.manufacture_date_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.marketing_name_, lhs_arena,
      &other->_impl_.marketing_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bios_version_, lhs_arena,
      &other->_impl_.bios_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.board_name_, lhs_arena,
      &other->_impl_.board_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.board_version_, lhs_arena,
      &other->_impl_.board_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.product_name_, lhs_arena,
      &other->_impl_.product_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vpd_serial_number_, lhs_arena,
      &other->_impl_.vpd_serial_number_, rhs_arena
  );
  swap(_impl_.chassis_type_, other->_impl_.chassis_type_);
}

std::string SystemStatus::GetTypeName() const {
  return "enterprise_management.SystemStatus";
}


// ===================================================================

class CpuCStateInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CpuCStateInfo>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_time_in_state_since_last_boot_us(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CpuCStateInfo::CpuCStateInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CpuCStateInfo)
}
CpuCStateInfo::CpuCStateInfo(const CpuCStateInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CpuCStateInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.time_in_state_since_last_boot_us_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.time_in_state_since_last_boot_us_ = from._impl_.time_in_state_since_last_boot_us_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CpuCStateInfo)
}

inline void CpuCStateInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.time_in_state_since_last_boot_us_){uint64_t{0u}}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CpuCStateInfo::~CpuCStateInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.CpuCStateInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CpuCStateInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CpuCStateInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CpuCStateInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CpuCStateInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.time_in_state_since_last_boot_us_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CpuCStateInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 time_in_state_since_last_boot_us = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_time_in_state_since_last_boot_us(&has_bits);
          _impl_.time_in_state_since_last_boot_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CpuCStateInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CpuCStateInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional uint64 time_in_state_since_last_boot_us = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_time_in_state_since_last_boot_us(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CpuCStateInfo)
  return target;
}

size_t CpuCStateInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CpuCStateInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint64 time_in_state_since_last_boot_us = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_time_in_state_since_last_boot_us());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CpuCStateInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CpuCStateInfo*>(
      &from));
}

void CpuCStateInfo::MergeFrom(const CpuCStateInfo& from) {
  CpuCStateInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CpuCStateInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.time_in_state_since_last_boot_us_ = from._impl_.time_in_state_since_last_boot_us_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CpuCStateInfo::CopyFrom(const CpuCStateInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CpuCStateInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CpuCStateInfo::IsInitialized() const {
  return true;
}

void CpuCStateInfo::InternalSwap(CpuCStateInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.time_in_state_since_last_boot_us_, other->_impl_.time_in_state_since_last_boot_us_);
}

std::string CpuCStateInfo::GetTypeName() const {
  return "enterprise_management.CpuCStateInfo";
}


// ===================================================================

class LogicalCpuInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<LogicalCpuInfo>()._impl_._has_bits_);
  static void set_has_scaling_max_frequency_khz(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_scaling_current_frequency_khz(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_idle_time_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

LogicalCpuInfo::LogicalCpuInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.LogicalCpuInfo)
}
LogicalCpuInfo::LogicalCpuInfo(const LogicalCpuInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LogicalCpuInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.c_states_){from._impl_.c_states_}
    , decltype(_impl_.scaling_max_frequency_khz_){}
    , decltype(_impl_.scaling_current_frequency_khz_){}
    , decltype(_impl_.idle_time_seconds_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.scaling_max_frequency_khz_, &from._impl_.scaling_max_frequency_khz_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.idle_time_seconds_) -
    reinterpret_cast<char*>(&_impl_.scaling_max_frequency_khz_)) + sizeof(_impl_.idle_time_seconds_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.LogicalCpuInfo)
}

inline void LogicalCpuInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.c_states_){arena}
    , decltype(_impl_.scaling_max_frequency_khz_){0u}
    , decltype(_impl_.scaling_current_frequency_khz_){0u}
    , decltype(_impl_.idle_time_seconds_){uint64_t{0u}}
  };
}

LogicalCpuInfo::~LogicalCpuInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.LogicalCpuInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogicalCpuInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.c_states_.~RepeatedPtrField();
}

void LogicalCpuInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LogicalCpuInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.LogicalCpuInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.c_states_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.scaling_max_frequency_khz_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.idle_time_seconds_) -
        reinterpret_cast<char*>(&_impl_.scaling_max_frequency_khz_)) + sizeof(_impl_.idle_time_seconds_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LogicalCpuInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 scaling_max_frequency_khz = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_scaling_max_frequency_khz(&has_bits);
          _impl_.scaling_max_frequency_khz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 scaling_current_frequency_khz = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_scaling_current_frequency_khz(&has_bits);
          _impl_.scaling_current_frequency_khz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 idle_time_seconds = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_idle_time_seconds(&has_bits);
          _impl_.idle_time_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.CpuCStateInfo c_states = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_c_states(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogicalCpuInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.LogicalCpuInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 scaling_max_frequency_khz = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_scaling_max_frequency_khz(), target);
  }

  // optional uint32 scaling_current_frequency_khz = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_scaling_current_frequency_khz(), target);
  }

  // optional uint64 idle_time_seconds = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_idle_time_seconds(), target);
  }

  // repeated .enterprise_management.CpuCStateInfo c_states = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_c_states_size()); i < n; i++) {
    const auto& repfield = this->_internal_c_states(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.LogicalCpuInfo)
  return target;
}

size_t LogicalCpuInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.LogicalCpuInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.CpuCStateInfo c_states = 4;
  total_size += 1UL * this->_internal_c_states_size();
  for (const auto& msg : this->_impl_.c_states_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 scaling_max_frequency_khz = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_scaling_max_frequency_khz());
    }

    // optional uint32 scaling_current_frequency_khz = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_scaling_current_frequency_khz());
    }

    // optional uint64 idle_time_seconds = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_idle_time_seconds());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogicalCpuInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LogicalCpuInfo*>(
      &from));
}

void LogicalCpuInfo::MergeFrom(const LogicalCpuInfo& from) {
  LogicalCpuInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.LogicalCpuInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.c_states_.MergeFrom(from._impl_.c_states_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.scaling_max_frequency_khz_ = from._impl_.scaling_max_frequency_khz_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.scaling_current_frequency_khz_ = from._impl_.scaling_current_frequency_khz_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.idle_time_seconds_ = from._impl_.idle_time_seconds_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LogicalCpuInfo::CopyFrom(const LogicalCpuInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.LogicalCpuInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalCpuInfo::IsInitialized() const {
  return true;
}

void LogicalCpuInfo::InternalSwap(LogicalCpuInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.c_states_.InternalSwap(&other->_impl_.c_states_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogicalCpuInfo, _impl_.idle_time_seconds_)
      + sizeof(LogicalCpuInfo::_impl_.idle_time_seconds_)
      - PROTOBUF_FIELD_OFFSET(LogicalCpuInfo, _impl_.scaling_max_frequency_khz_)>(
          reinterpret_cast<char*>(&_impl_.scaling_max_frequency_khz_),
          reinterpret_cast<char*>(&other->_impl_.scaling_max_frequency_khz_));
}

std::string LogicalCpuInfo::GetTypeName() const {
  return "enterprise_management.LogicalCpuInfo";
}


// ===================================================================

class CpuInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CpuInfo>()._impl_._has_bits_);
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_architecture(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_clock_speed_khz(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CpuInfo::CpuInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CpuInfo)
}
CpuInfo::CpuInfo(const CpuInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CpuInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.logical_cpus_){from._impl_.logical_cpus_}
    , decltype(_impl_.model_name_){}
    , decltype(_impl_.architecture_){}
    , decltype(_impl_.max_clock_speed_khz_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.model_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model_name()) {
    _this->_impl_.model_name_.Set(from._internal_model_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.architecture_, &from._impl_.architecture_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_clock_speed_khz_) -
    reinterpret_cast<char*>(&_impl_.architecture_)) + sizeof(_impl_.max_clock_speed_khz_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CpuInfo)
}

inline void CpuInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.logical_cpus_){arena}
    , decltype(_impl_.model_name_){}
    , decltype(_impl_.architecture_){0}
    , decltype(_impl_.max_clock_speed_khz_){0u}
  };
  _impl_.model_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CpuInfo::~CpuInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.CpuInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CpuInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.logical_cpus_.~RepeatedPtrField();
  _impl_.model_name_.Destroy();
}

void CpuInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CpuInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CpuInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.logical_cpus_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.model_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.architecture_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.max_clock_speed_khz_) -
        reinterpret_cast<char*>(&_impl_.architecture_)) + sizeof(_impl_.max_clock_speed_khz_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CpuInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string model_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_model_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.CpuInfo.Architecture architecture = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::CpuInfo_Architecture_IsValid(val))) {
            _internal_set_architecture(static_cast<::enterprise_management::CpuInfo_Architecture>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_clock_speed_khz = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_max_clock_speed_khz(&has_bits);
          _impl_.max_clock_speed_khz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.LogicalCpuInfo logical_cpus = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_logical_cpus(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CpuInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CpuInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string model_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_name(), target);
  }

  // optional .enterprise_management.CpuInfo.Architecture architecture = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_architecture(), target);
  }

  // optional uint32 max_clock_speed_khz = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_max_clock_speed_khz(), target);
  }

  // repeated .enterprise_management.LogicalCpuInfo logical_cpus = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_logical_cpus_size()); i < n; i++) {
    const auto& repfield = this->_internal_logical_cpus(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CpuInfo)
  return target;
}

size_t CpuInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CpuInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.LogicalCpuInfo logical_cpus = 4;
  total_size += 1UL * this->_internal_logical_cpus_size();
  for (const auto& msg : this->_impl_.logical_cpus_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string model_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_name());
    }

    // optional .enterprise_management.CpuInfo.Architecture architecture = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_architecture());
    }

    // optional uint32 max_clock_speed_khz = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_clock_speed_khz());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CpuInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CpuInfo*>(
      &from));
}

void CpuInfo::MergeFrom(const CpuInfo& from) {
  CpuInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CpuInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.logical_cpus_.MergeFrom(from._impl_.logical_cpus_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_model_name(from._internal_model_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.architecture_ = from._impl_.architecture_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.max_clock_speed_khz_ = from._impl_.max_clock_speed_khz_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CpuInfo::CopyFrom(const CpuInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CpuInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CpuInfo::IsInitialized() const {
  return true;
}

void CpuInfo::InternalSwap(CpuInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.logical_cpus_.InternalSwap(&other->_impl_.logical_cpus_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.model_name_, lhs_arena,
      &other->_impl_.model_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CpuInfo, _impl_.max_clock_speed_khz_)
      + sizeof(CpuInfo::_impl_.max_clock_speed_khz_)
      - PROTOBUF_FIELD_OFFSET(CpuInfo, _impl_.architecture_)>(
          reinterpret_cast<char*>(&_impl_.architecture_),
          reinterpret_cast<char*>(&other->_impl_.architecture_));
}

std::string CpuInfo::GetTypeName() const {
  return "enterprise_management.CpuInfo";
}


// ===================================================================

class GlobalCpuInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<GlobalCpuInfo>()._impl_._has_bits_);
  static void set_has_num_total_threads(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

GlobalCpuInfo::GlobalCpuInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.GlobalCpuInfo)
}
GlobalCpuInfo::GlobalCpuInfo(const GlobalCpuInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GlobalCpuInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.num_total_threads_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.num_total_threads_ = from._impl_.num_total_threads_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.GlobalCpuInfo)
}

inline void GlobalCpuInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.num_total_threads_){0u}
  };
}

GlobalCpuInfo::~GlobalCpuInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.GlobalCpuInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GlobalCpuInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GlobalCpuInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GlobalCpuInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.GlobalCpuInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.num_total_threads_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GlobalCpuInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 num_total_threads = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_num_total_threads(&has_bits);
          _impl_.num_total_threads_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GlobalCpuInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.GlobalCpuInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 num_total_threads = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_num_total_threads(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.GlobalCpuInfo)
  return target;
}

size_t GlobalCpuInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.GlobalCpuInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 num_total_threads = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_total_threads());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GlobalCpuInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GlobalCpuInfo*>(
      &from));
}

void GlobalCpuInfo::MergeFrom(const GlobalCpuInfo& from) {
  GlobalCpuInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.GlobalCpuInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_num_total_threads()) {
    _this->_internal_set_num_total_threads(from._internal_num_total_threads());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GlobalCpuInfo::CopyFrom(const GlobalCpuInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.GlobalCpuInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlobalCpuInfo::IsInitialized() const {
  return true;
}

void GlobalCpuInfo::InternalSwap(GlobalCpuInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.num_total_threads_, other->_impl_.num_total_threads_);
}

std::string GlobalCpuInfo::GetTypeName() const {
  return "enterprise_management.GlobalCpuInfo";
}


// ===================================================================

class DisplayInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<DisplayInfo>()._impl_._has_bits_);
  static void set_has_resolution_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_resolution_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_refresh_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_internal(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

DisplayInfo::DisplayInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DisplayInfo)
}
DisplayInfo::DisplayInfo(const DisplayInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DisplayInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resolution_width_){}
    , decltype(_impl_.resolution_height_){}
    , decltype(_impl_.refresh_rate_){}
    , decltype(_impl_.is_internal_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.resolution_width_, &from._impl_.resolution_width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_internal_) -
    reinterpret_cast<char*>(&_impl_.resolution_width_)) + sizeof(_impl_.is_internal_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DisplayInfo)
}

inline void DisplayInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resolution_width_){0u}
    , decltype(_impl_.resolution_height_){0u}
    , decltype(_impl_.refresh_rate_){0u}
    , decltype(_impl_.is_internal_){false}
  };
}

DisplayInfo::~DisplayInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.DisplayInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DisplayInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DisplayInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DisplayInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DisplayInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.resolution_width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_internal_) -
        reinterpret_cast<char*>(&_impl_.resolution_width_)) + sizeof(_impl_.is_internal_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DisplayInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 resolution_width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_resolution_width(&has_bits);
          _impl_.resolution_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 resolution_height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_resolution_height(&has_bits);
          _impl_.resolution_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 refresh_rate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_refresh_rate(&has_bits);
          _impl_.refresh_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_internal = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_internal(&has_bits);
          _impl_.is_internal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DisplayInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DisplayInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 resolution_width = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_resolution_width(), target);
  }

  // optional uint32 resolution_height = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_resolution_height(), target);
  }

  // optional uint32 refresh_rate = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_refresh_rate(), target);
  }

  // optional bool is_internal = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_internal(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DisplayInfo)
  return target;
}

size_t DisplayInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DisplayInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 resolution_width = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_resolution_width());
    }

    // optional uint32 resolution_height = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_resolution_height());
    }

    // optional uint32 refresh_rate = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_refresh_rate());
    }

    // optional bool is_internal = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DisplayInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DisplayInfo*>(
      &from));
}

void DisplayInfo::MergeFrom(const DisplayInfo& from) {
  DisplayInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DisplayInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.resolution_width_ = from._impl_.resolution_width_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.resolution_height_ = from._impl_.resolution_height_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.refresh_rate_ = from._impl_.refresh_rate_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_internal_ = from._impl_.is_internal_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DisplayInfo::CopyFrom(const DisplayInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DisplayInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DisplayInfo::IsInitialized() const {
  return true;
}

void DisplayInfo::InternalSwap(DisplayInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DisplayInfo, _impl_.is_internal_)
      + sizeof(DisplayInfo::_impl_.is_internal_)
      - PROTOBUF_FIELD_OFFSET(DisplayInfo, _impl_.resolution_width_)>(
          reinterpret_cast<char*>(&_impl_.resolution_width_),
          reinterpret_cast<char*>(&other->_impl_.resolution_width_));
}

std::string DisplayInfo::GetTypeName() const {
  return "enterprise_management.DisplayInfo";
}


// ===================================================================

class GraphicsAdapterInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<GraphicsAdapterInfo>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_driver_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_system_ram_usage(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

GraphicsAdapterInfo::GraphicsAdapterInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.GraphicsAdapterInfo)
}
GraphicsAdapterInfo::GraphicsAdapterInfo(const GraphicsAdapterInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GraphicsAdapterInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.driver_version_){}
    , decltype(_impl_.device_id_){}
    , decltype(_impl_.system_ram_usage_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.driver_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_driver_version()) {
    _this->_impl_.driver_version_.Set(from._internal_driver_version(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.device_id_, &from._impl_.device_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.system_ram_usage_) -
    reinterpret_cast<char*>(&_impl_.device_id_)) + sizeof(_impl_.system_ram_usage_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.GraphicsAdapterInfo)
}

inline void GraphicsAdapterInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.driver_version_){}
    , decltype(_impl_.device_id_){uint64_t{0u}}
    , decltype(_impl_.system_ram_usage_){uint64_t{0u}}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.driver_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GraphicsAdapterInfo::~GraphicsAdapterInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.GraphicsAdapterInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GraphicsAdapterInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.driver_version_.Destroy();
}

void GraphicsAdapterInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GraphicsAdapterInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.GraphicsAdapterInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.driver_version_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.device_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.system_ram_usage_) -
        reinterpret_cast<char*>(&_impl_.device_id_)) + sizeof(_impl_.system_ram_usage_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GraphicsAdapterInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string driver_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_driver_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 device_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_device_id(&has_bits);
          _impl_.device_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 system_ram_usage = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_system_ram_usage(&has_bits);
          _impl_.system_ram_usage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GraphicsAdapterInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.GraphicsAdapterInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string driver_version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_driver_version(), target);
  }

  // optional uint64 device_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_device_id(), target);
  }

  // optional uint64 system_ram_usage = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_system_ram_usage(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.GraphicsAdapterInfo)
  return target;
}

size_t GraphicsAdapterInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.GraphicsAdapterInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string driver_version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_driver_version());
    }

    // optional uint64 device_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_device_id());
    }

    // optional uint64 system_ram_usage = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_system_ram_usage());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GraphicsAdapterInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GraphicsAdapterInfo*>(
      &from));
}

void GraphicsAdapterInfo::MergeFrom(const GraphicsAdapterInfo& from) {
  GraphicsAdapterInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.GraphicsAdapterInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_driver_version(from._internal_driver_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.device_id_ = from._impl_.device_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.system_ram_usage_ = from._impl_.system_ram_usage_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GraphicsAdapterInfo::CopyFrom(const GraphicsAdapterInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.GraphicsAdapterInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GraphicsAdapterInfo::IsInitialized() const {
  return true;
}

void GraphicsAdapterInfo::InternalSwap(GraphicsAdapterInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.driver_version_, lhs_arena,
      &other->_impl_.driver_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GraphicsAdapterInfo, _impl_.system_ram_usage_)
      + sizeof(GraphicsAdapterInfo::_impl_.system_ram_usage_)
      - PROTOBUF_FIELD_OFFSET(GraphicsAdapterInfo, _impl_.device_id_)>(
          reinterpret_cast<char*>(&_impl_.device_id_),
          reinterpret_cast<char*>(&other->_impl_.device_id_));
}

std::string GraphicsAdapterInfo::GetTypeName() const {
  return "enterprise_management.GraphicsAdapterInfo";
}


// ===================================================================

class GraphicsStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<GraphicsStatus>()._impl_._has_bits_);
  static const ::enterprise_management::GraphicsAdapterInfo& adapter(const GraphicsStatus* msg);
  static void set_has_adapter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::enterprise_management::GraphicsAdapterInfo&
GraphicsStatus::_Internal::adapter(const GraphicsStatus* msg) {
  return *msg->_impl_.adapter_;
}
GraphicsStatus::GraphicsStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.GraphicsStatus)
}
GraphicsStatus::GraphicsStatus(const GraphicsStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GraphicsStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.displays_){from._impl_.displays_}
    , decltype(_impl_.adapter_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_adapter()) {
    _this->_impl_.adapter_ = new ::enterprise_management::GraphicsAdapterInfo(*from._impl_.adapter_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.GraphicsStatus)
}

inline void GraphicsStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.displays_){arena}
    , decltype(_impl_.adapter_){nullptr}
  };
}

GraphicsStatus::~GraphicsStatus() {
  // @@protoc_insertion_point(destructor:enterprise_management.GraphicsStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GraphicsStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.displays_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.adapter_;
}

void GraphicsStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GraphicsStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.GraphicsStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.displays_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.adapter_ != nullptr);
    _impl_.adapter_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GraphicsStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.GraphicsAdapterInfo adapter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_adapter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.DisplayInfo displays = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_displays(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GraphicsStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.GraphicsStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.GraphicsAdapterInfo adapter = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::adapter(this),
        _Internal::adapter(this).GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.DisplayInfo displays = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_displays_size()); i < n; i++) {
    const auto& repfield = this->_internal_displays(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.GraphicsStatus)
  return target;
}

size_t GraphicsStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.GraphicsStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.DisplayInfo displays = 2;
  total_size += 1UL * this->_internal_displays_size();
  for (const auto& msg : this->_impl_.displays_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .enterprise_management.GraphicsAdapterInfo adapter = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.adapter_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GraphicsStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GraphicsStatus*>(
      &from));
}

void GraphicsStatus::MergeFrom(const GraphicsStatus& from) {
  GraphicsStatus* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.GraphicsStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.displays_.MergeFrom(from._impl_.displays_);
  if (from._internal_has_adapter()) {
    _this->_internal_mutable_adapter()->::enterprise_management::GraphicsAdapterInfo::MergeFrom(
        from._internal_adapter());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GraphicsStatus::CopyFrom(const GraphicsStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.GraphicsStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GraphicsStatus::IsInitialized() const {
  return true;
}

void GraphicsStatus::InternalSwap(GraphicsStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.displays_.InternalSwap(&other->_impl_.displays_);
  swap(_impl_.adapter_, other->_impl_.adapter_);
}

std::string GraphicsStatus::GetTypeName() const {
  return "enterprise_management.GraphicsStatus";
}


// ===================================================================

class CrashReportInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CrashReportInfo>()._impl_._has_bits_);
  static void set_has_remote_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_capture_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cause(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_upload_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CrashReportInfo::CrashReportInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CrashReportInfo)
}
CrashReportInfo::CrashReportInfo(const CrashReportInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CrashReportInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.remote_id_){}
    , decltype(_impl_.cause_){}
    , decltype(_impl_.capture_timestamp_){}
    , decltype(_impl_.upload_status_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.remote_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_remote_id()) {
    _this->_impl_.remote_id_.Set(from._internal_remote_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.cause_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cause_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cause()) {
    _this->_impl_.cause_.Set(from._internal_cause(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.capture_timestamp_, &from._impl_.capture_timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.upload_status_) -
    reinterpret_cast<char*>(&_impl_.capture_timestamp_)) + sizeof(_impl_.upload_status_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CrashReportInfo)
}

inline void CrashReportInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.remote_id_){}
    , decltype(_impl_.cause_){}
    , decltype(_impl_.capture_timestamp_){int64_t{0}}
    , decltype(_impl_.upload_status_){0}
  };
  _impl_.remote_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cause_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cause_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CrashReportInfo::~CrashReportInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.CrashReportInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CrashReportInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.remote_id_.Destroy();
  _impl_.cause_.Destroy();
}

void CrashReportInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CrashReportInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CrashReportInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.remote_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.cause_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.capture_timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.upload_status_) -
        reinterpret_cast<char*>(&_impl_.capture_timestamp_)) + sizeof(_impl_.upload_status_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CrashReportInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string remote_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_remote_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 capture_timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_capture_timestamp(&has_bits);
          _impl_.capture_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string cause = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_cause();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.CrashReportInfo.CrashReportUploadStatus upload_status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::CrashReportInfo_CrashReportUploadStatus_IsValid(val))) {
            _internal_set_upload_status(static_cast<::enterprise_management::CrashReportInfo_CrashReportUploadStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CrashReportInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CrashReportInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string remote_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_remote_id(), target);
  }

  // optional int64 capture_timestamp = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_capture_timestamp(), target);
  }

  // optional string cause = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_cause(), target);
  }

  // optional .enterprise_management.CrashReportInfo.CrashReportUploadStatus upload_status = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_upload_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CrashReportInfo)
  return target;
}

size_t CrashReportInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CrashReportInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string remote_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_remote_id());
    }

    // optional string cause = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cause());
    }

    // optional int64 capture_timestamp = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_capture_timestamp());
    }

    // optional .enterprise_management.CrashReportInfo.CrashReportUploadStatus upload_status = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_upload_status());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CrashReportInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CrashReportInfo*>(
      &from));
}

void CrashReportInfo::MergeFrom(const CrashReportInfo& from) {
  CrashReportInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CrashReportInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_remote_id(from._internal_remote_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_cause(from._internal_cause());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.capture_timestamp_ = from._impl_.capture_timestamp_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.upload_status_ = from._impl_.upload_status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CrashReportInfo::CopyFrom(const CrashReportInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CrashReportInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CrashReportInfo::IsInitialized() const {
  return true;
}

void CrashReportInfo::InternalSwap(CrashReportInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.remote_id_, lhs_arena,
      &other->_impl_.remote_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cause_, lhs_arena,
      &other->_impl_.cause_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CrashReportInfo, _impl_.upload_status_)
      + sizeof(CrashReportInfo::_impl_.upload_status_)
      - PROTOBUF_FIELD_OFFSET(CrashReportInfo, _impl_.capture_timestamp_)>(
          reinterpret_cast<char*>(&_impl_.capture_timestamp_),
          reinterpret_cast<char*>(&other->_impl_.capture_timestamp_));
}

std::string CrashReportInfo::GetTypeName() const {
  return "enterprise_management.CrashReportInfo";
}


// ===================================================================

class TimezoneInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TimezoneInfo>()._impl_._has_bits_);
  static void set_has_posix(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_region(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TimezoneInfo::TimezoneInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.TimezoneInfo)
}
TimezoneInfo::TimezoneInfo(const TimezoneInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TimezoneInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.posix_){}
    , decltype(_impl_.region_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.posix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.posix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_posix()) {
    _this->_impl_.posix_.Set(from._internal_posix(), 
      _this->GetArenaForAllocation());
  }
  _impl_.region_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_region()) {
    _this->_impl_.region_.Set(from._internal_region(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.TimezoneInfo)
}

inline void TimezoneInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.posix_){}
    , decltype(_impl_.region_){}
  };
  _impl_.posix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.posix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.region_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TimezoneInfo::~TimezoneInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.TimezoneInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TimezoneInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.posix_.Destroy();
  _impl_.region_.Destroy();
}

void TimezoneInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TimezoneInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.TimezoneInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.posix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.region_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TimezoneInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string posix = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_posix();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string region = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_region();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TimezoneInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.TimezoneInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string posix = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_posix(), target);
  }

  // optional string region = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_region(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.TimezoneInfo)
  return target;
}

size_t TimezoneInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.TimezoneInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string posix = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_posix());
    }

    // optional string region = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_region());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TimezoneInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TimezoneInfo*>(
      &from));
}

void TimezoneInfo::MergeFrom(const TimezoneInfo& from) {
  TimezoneInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.TimezoneInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_posix(from._internal_posix());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_region(from._internal_region());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TimezoneInfo::CopyFrom(const TimezoneInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.TimezoneInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimezoneInfo::IsInitialized() const {
  return true;
}

void TimezoneInfo::InternalSwap(TimezoneInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.posix_, lhs_arena,
      &other->_impl_.posix_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.region_, lhs_arena,
      &other->_impl_.region_, rhs_arena
  );
}

std::string TimezoneInfo::GetTypeName() const {
  return "enterprise_management.TimezoneInfo";
}


// ===================================================================

class MemoryInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<MemoryInfo>()._impl_._has_bits_);
  static void set_has_total_memory_kib(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_free_memory_kib(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_available_memory_kib(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_page_faults_since_last_boot(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

MemoryInfo::MemoryInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.MemoryInfo)
}
MemoryInfo::MemoryInfo(const MemoryInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MemoryInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.total_memory_kib_){}
    , decltype(_impl_.free_memory_kib_){}
    , decltype(_impl_.page_faults_since_last_boot_){}
    , decltype(_impl_.available_memory_kib_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.total_memory_kib_, &from._impl_.total_memory_kib_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.available_memory_kib_) -
    reinterpret_cast<char*>(&_impl_.total_memory_kib_)) + sizeof(_impl_.available_memory_kib_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.MemoryInfo)
}

inline void MemoryInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.total_memory_kib_){0u}
    , decltype(_impl_.free_memory_kib_){0u}
    , decltype(_impl_.page_faults_since_last_boot_){uint64_t{0u}}
    , decltype(_impl_.available_memory_kib_){0u}
  };
}

MemoryInfo::~MemoryInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.MemoryInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MemoryInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MemoryInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MemoryInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.MemoryInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.total_memory_kib_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.available_memory_kib_) -
        reinterpret_cast<char*>(&_impl_.total_memory_kib_)) + sizeof(_impl_.available_memory_kib_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MemoryInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 total_memory_kib = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_total_memory_kib(&has_bits);
          _impl_.total_memory_kib_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 free_memory_kib = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_free_memory_kib(&has_bits);
          _impl_.free_memory_kib_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 available_memory_kib = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_available_memory_kib(&has_bits);
          _impl_.available_memory_kib_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 page_faults_since_last_boot = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_page_faults_since_last_boot(&has_bits);
          _impl_.page_faults_since_last_boot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MemoryInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.MemoryInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 total_memory_kib = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_total_memory_kib(), target);
  }

  // optional uint32 free_memory_kib = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_free_memory_kib(), target);
  }

  // optional uint32 available_memory_kib = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_available_memory_kib(), target);
  }

  // optional uint64 page_faults_since_last_boot = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_page_faults_since_last_boot(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.MemoryInfo)
  return target;
}

size_t MemoryInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.MemoryInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 total_memory_kib = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_total_memory_kib());
    }

    // optional uint32 free_memory_kib = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_free_memory_kib());
    }

    // optional uint64 page_faults_since_last_boot = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_page_faults_since_last_boot());
    }

    // optional uint32 available_memory_kib = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_available_memory_kib());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MemoryInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MemoryInfo*>(
      &from));
}

void MemoryInfo::MergeFrom(const MemoryInfo& from) {
  MemoryInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.MemoryInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.total_memory_kib_ = from._impl_.total_memory_kib_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.free_memory_kib_ = from._impl_.free_memory_kib_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.page_faults_since_last_boot_ = from._impl_.page_faults_since_last_boot_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.available_memory_kib_ = from._impl_.available_memory_kib_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MemoryInfo::CopyFrom(const MemoryInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.MemoryInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemoryInfo::IsInitialized() const {
  return true;
}

void MemoryInfo::InternalSwap(MemoryInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MemoryInfo, _impl_.available_memory_kib_)
      + sizeof(MemoryInfo::_impl_.available_memory_kib_)
      - PROTOBUF_FIELD_OFFSET(MemoryInfo, _impl_.total_memory_kib_)>(
          reinterpret_cast<char*>(&_impl_.total_memory_kib_),
          reinterpret_cast<char*>(&other->_impl_.total_memory_kib_));
}

std::string MemoryInfo::GetTypeName() const {
  return "enterprise_management.MemoryInfo";
}


// ===================================================================

class BacklightInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<BacklightInfo>()._impl_._has_bits_);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max_brightness(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_brightness(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

BacklightInfo::BacklightInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.BacklightInfo)
}
BacklightInfo::BacklightInfo(const BacklightInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BacklightInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){}
    , decltype(_impl_.max_brightness_){}
    , decltype(_impl_.brightness_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.max_brightness_, &from._impl_.max_brightness_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.brightness_) -
    reinterpret_cast<char*>(&_impl_.max_brightness_)) + sizeof(_impl_.brightness_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.BacklightInfo)
}

inline void BacklightInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){}
    , decltype(_impl_.max_brightness_){0u}
    , decltype(_impl_.brightness_){0u}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BacklightInfo::~BacklightInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.BacklightInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BacklightInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
}

void BacklightInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BacklightInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.BacklightInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.path_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.max_brightness_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.brightness_) -
        reinterpret_cast<char*>(&_impl_.max_brightness_)) + sizeof(_impl_.brightness_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BacklightInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_brightness = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_max_brightness(&has_bits);
          _impl_.max_brightness_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 brightness = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_brightness(&has_bits);
          _impl_.brightness_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BacklightInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.BacklightInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string path = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_path(), target);
  }

  // optional uint32 max_brightness = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_max_brightness(), target);
  }

  // optional uint32 brightness = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_brightness(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.BacklightInfo)
  return target;
}

size_t BacklightInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.BacklightInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string path = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_path());
    }

    // optional uint32 max_brightness = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_brightness());
    }

    // optional uint32 brightness = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_brightness());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BacklightInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BacklightInfo*>(
      &from));
}

void BacklightInfo::MergeFrom(const BacklightInfo& from) {
  BacklightInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.BacklightInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.max_brightness_ = from._impl_.max_brightness_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.brightness_ = from._impl_.brightness_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BacklightInfo::CopyFrom(const BacklightInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.BacklightInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BacklightInfo::IsInitialized() const {
  return true;
}

void BacklightInfo::InternalSwap(BacklightInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BacklightInfo, _impl_.brightness_)
      + sizeof(BacklightInfo::_impl_.brightness_)
      - PROTOBUF_FIELD_OFFSET(BacklightInfo, _impl_.max_brightness_)>(
          reinterpret_cast<char*>(&_impl_.max_brightness_),
          reinterpret_cast<char*>(&other->_impl_.max_brightness_));
}

std::string BacklightInfo::GetTypeName() const {
  return "enterprise_management.BacklightInfo";
}


// ===================================================================

class FanInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<FanInfo>()._impl_._has_bits_);
  static void set_has_speed_rpm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FanInfo::FanInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.FanInfo)
}
FanInfo::FanInfo(const FanInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FanInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.speed_rpm_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.speed_rpm_ = from._impl_.speed_rpm_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.FanInfo)
}

inline void FanInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.speed_rpm_){0u}
  };
}

FanInfo::~FanInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.FanInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FanInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FanInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FanInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.FanInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.speed_rpm_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FanInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 speed_rpm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_speed_rpm(&has_bits);
          _impl_.speed_rpm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FanInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.FanInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 speed_rpm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_speed_rpm(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.FanInfo)
  return target;
}

size_t FanInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.FanInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 speed_rpm = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_speed_rpm());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FanInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FanInfo*>(
      &from));
}

void FanInfo::MergeFrom(const FanInfo& from) {
  FanInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.FanInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_speed_rpm()) {
    _this->_internal_set_speed_rpm(from._internal_speed_rpm());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FanInfo::CopyFrom(const FanInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.FanInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FanInfo::IsInitialized() const {
  return true;
}

void FanInfo::InternalSwap(FanInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.speed_rpm_, other->_impl_.speed_rpm_);
}

std::string FanInfo::GetTypeName() const {
  return "enterprise_management.FanInfo";
}


// ===================================================================

class BluetoothAdapterInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<BluetoothAdapterInfo>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_powered(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_connected_devices(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

BluetoothAdapterInfo::BluetoothAdapterInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.BluetoothAdapterInfo)
}
BluetoothAdapterInfo::BluetoothAdapterInfo(const BluetoothAdapterInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BluetoothAdapterInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.address_){}
    , decltype(_impl_.powered_){}
    , decltype(_impl_.num_connected_devices_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_address()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.powered_, &from._impl_.powered_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_connected_devices_) -
    reinterpret_cast<char*>(&_impl_.powered_)) + sizeof(_impl_.num_connected_devices_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.BluetoothAdapterInfo)
}

inline void BluetoothAdapterInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.address_){}
    , decltype(_impl_.powered_){false}
    , decltype(_impl_.num_connected_devices_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BluetoothAdapterInfo::~BluetoothAdapterInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.BluetoothAdapterInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BluetoothAdapterInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.address_.Destroy();
}

void BluetoothAdapterInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BluetoothAdapterInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.BluetoothAdapterInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.address_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.powered_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_connected_devices_) -
        reinterpret_cast<char*>(&_impl_.powered_)) + sizeof(_impl_.num_connected_devices_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BluetoothAdapterInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool powered = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_powered(&has_bits);
          _impl_.powered_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_connected_devices = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_num_connected_devices(&has_bits);
          _impl_.num_connected_devices_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BluetoothAdapterInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.BluetoothAdapterInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string address = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_address(), target);
  }

  // optional bool powered = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_powered(), target);
  }

  // optional uint32 num_connected_devices = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_num_connected_devices(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.BluetoothAdapterInfo)
  return target;
}

size_t BluetoothAdapterInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.BluetoothAdapterInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string address = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_address());
    }

    // optional bool powered = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint32 num_connected_devices = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_connected_devices());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BluetoothAdapterInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BluetoothAdapterInfo*>(
      &from));
}

void BluetoothAdapterInfo::MergeFrom(const BluetoothAdapterInfo& from) {
  BluetoothAdapterInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.BluetoothAdapterInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_address(from._internal_address());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.powered_ = from._impl_.powered_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.num_connected_devices_ = from._impl_.num_connected_devices_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BluetoothAdapterInfo::CopyFrom(const BluetoothAdapterInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.BluetoothAdapterInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BluetoothAdapterInfo::IsInitialized() const {
  return true;
}

void BluetoothAdapterInfo::InternalSwap(BluetoothAdapterInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BluetoothAdapterInfo, _impl_.num_connected_devices_)
      + sizeof(BluetoothAdapterInfo::_impl_.num_connected_devices_)
      - PROTOBUF_FIELD_OFFSET(BluetoothAdapterInfo, _impl_.powered_)>(
          reinterpret_cast<char*>(&_impl_.powered_),
          reinterpret_cast<char*>(&other->_impl_.powered_));
}

std::string BluetoothAdapterInfo::GetTypeName() const {
  return "enterprise_management.BluetoothAdapterInfo";
}


// ===================================================================

class SmbiosInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<SmbiosInfo>()._impl_._has_bits_);
  static void set_has_sys_vendor(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_product_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_product_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bios_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SmbiosInfo::SmbiosInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.SmbiosInfo)
}
SmbiosInfo::SmbiosInfo(const SmbiosInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SmbiosInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sys_vendor_){}
    , decltype(_impl_.product_name_){}
    , decltype(_impl_.product_version_){}
    , decltype(_impl_.bios_version_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.sys_vendor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sys_vendor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sys_vendor()) {
    _this->_impl_.sys_vendor_.Set(from._internal_sys_vendor(), 
      _this->GetArenaForAllocation());
  }
  _impl_.product_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.product_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_product_name()) {
    _this->_impl_.product_name_.Set(from._internal_product_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.product_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.product_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_product_version()) {
    _this->_impl_.product_version_.Set(from._internal_product_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.bios_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bios_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bios_version()) {
    _this->_impl_.bios_version_.Set(from._internal_bios_version(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.SmbiosInfo)
}

inline void SmbiosInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sys_vendor_){}
    , decltype(_impl_.product_name_){}
    , decltype(_impl_.product_version_){}
    , decltype(_impl_.bios_version_){}
  };
  _impl_.sys_vendor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sys_vendor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.product_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.product_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.product_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.product_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bios_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bios_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SmbiosInfo::~SmbiosInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.SmbiosInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SmbiosInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sys_vendor_.Destroy();
  _impl_.product_name_.Destroy();
  _impl_.product_version_.Destroy();
  _impl_.bios_version_.Destroy();
}

void SmbiosInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SmbiosInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.SmbiosInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.sys_vendor_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.product_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.product_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.bios_version_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SmbiosInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string sys_vendor = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_sys_vendor();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string product_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_product_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string product_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_product_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string bios_version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_bios_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SmbiosInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.SmbiosInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string sys_vendor = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_sys_vendor(), target);
  }

  // optional string product_name = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_product_name(), target);
  }

  // optional string product_version = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_product_version(), target);
  }

  // optional string bios_version = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_bios_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.SmbiosInfo)
  return target;
}

size_t SmbiosInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.SmbiosInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string sys_vendor = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sys_vendor());
    }

    // optional string product_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_product_name());
    }

    // optional string product_version = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_product_version());
    }

    // optional string bios_version = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_bios_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SmbiosInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SmbiosInfo*>(
      &from));
}

void SmbiosInfo::MergeFrom(const SmbiosInfo& from) {
  SmbiosInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.SmbiosInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_sys_vendor(from._internal_sys_vendor());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_product_name(from._internal_product_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_product_version(from._internal_product_version());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_bios_version(from._internal_bios_version());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SmbiosInfo::CopyFrom(const SmbiosInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.SmbiosInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SmbiosInfo::IsInitialized() const {
  return true;
}

void SmbiosInfo::InternalSwap(SmbiosInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sys_vendor_, lhs_arena,
      &other->_impl_.sys_vendor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.product_name_, lhs_arena,
      &other->_impl_.product_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.product_version_, lhs_arena,
      &other->_impl_.product_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bios_version_, lhs_arena,
      &other->_impl_.bios_version_, rhs_arena
  );
}

std::string SmbiosInfo::GetTypeName() const {
  return "enterprise_management.SmbiosInfo";
}


// ===================================================================

class KernelParameters::_Internal {
 public:
  using HasBits = decltype(std::declval<KernelParameters>()._impl_._has_bits_);
  static void set_has_cros_efi(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KernelParameters::KernelParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.KernelParameters)
}
KernelParameters::KernelParameters(const KernelParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KernelParameters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cros_efi_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.cros_efi_ = from._impl_.cros_efi_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.KernelParameters)
}

inline void KernelParameters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cros_efi_){false}
  };
}

KernelParameters::~KernelParameters() {
  // @@protoc_insertion_point(destructor:enterprise_management.KernelParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KernelParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KernelParameters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KernelParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.KernelParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cros_efi_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KernelParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool cros_efi = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cros_efi(&has_bits);
          _impl_.cros_efi_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KernelParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.KernelParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool cros_efi = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_cros_efi(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.KernelParameters)
  return target;
}

size_t KernelParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.KernelParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool cros_efi = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KernelParameters::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KernelParameters*>(
      &from));
}

void KernelParameters::MergeFrom(const KernelParameters& from) {
  KernelParameters* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.KernelParameters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_cros_efi()) {
    _this->_internal_set_cros_efi(from._internal_cros_efi());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KernelParameters::CopyFrom(const KernelParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.KernelParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KernelParameters::IsInitialized() const {
  return true;
}

void KernelParameters::InternalSwap(KernelParameters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.cros_efi_, other->_impl_.cros_efi_);
}

std::string KernelParameters::GetTypeName() const {
  return "enterprise_management.KernelParameters";
}


// ===================================================================

class EFIVars::_Internal {
 public:
  using HasBits = decltype(std::declval<EFIVars>()._impl_._has_bits_);
  static void set_has_secure_boot(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

EFIVars::EFIVars(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.EFIVars)
}
EFIVars::EFIVars(const EFIVars& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  EFIVars* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.secure_boot_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.secure_boot_ = from._impl_.secure_boot_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.EFIVars)
}

inline void EFIVars::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.secure_boot_){false}
  };
}

EFIVars::~EFIVars() {
  // @@protoc_insertion_point(destructor:enterprise_management.EFIVars)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EFIVars::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EFIVars::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EFIVars::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.EFIVars)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.secure_boot_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EFIVars::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool secure_boot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_secure_boot(&has_bits);
          _impl_.secure_boot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EFIVars::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.EFIVars)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool secure_boot = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_secure_boot(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.EFIVars)
  return target;
}

size_t EFIVars::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.EFIVars)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool secure_boot = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EFIVars::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EFIVars*>(
      &from));
}

void EFIVars::MergeFrom(const EFIVars& from) {
  EFIVars* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.EFIVars)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_secure_boot()) {
    _this->_internal_set_secure_boot(from._internal_secure_boot());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EFIVars::CopyFrom(const EFIVars& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.EFIVars)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EFIVars::IsInitialized() const {
  return true;
}

void EFIVars::InternalSwap(EFIVars* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.secure_boot_, other->_impl_.secure_boot_);
}

std::string EFIVars::GetTypeName() const {
  return "enterprise_management.EFIVars";
}


// ===================================================================

class BootInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<BootInfo>()._impl_._has_bits_);
  static void set_has_boot_method(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_secure_boot(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BootInfo::BootInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.BootInfo)
}
BootInfo::BootInfo(const BootInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BootInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.boot_method_){}
    , decltype(_impl_.secure_boot_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.boot_method_, &from._impl_.boot_method_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.secure_boot_) -
    reinterpret_cast<char*>(&_impl_.boot_method_)) + sizeof(_impl_.secure_boot_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.BootInfo)
}

inline void BootInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.boot_method_){0}
    , decltype(_impl_.secure_boot_){false}
  };
}

BootInfo::~BootInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.BootInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BootInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BootInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BootInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.BootInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.boot_method_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.secure_boot_) -
        reinterpret_cast<char*>(&_impl_.boot_method_)) + sizeof(_impl_.secure_boot_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BootInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.BootInfo.BootMethod boot_method = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::BootInfo_BootMethod_IsValid(val))) {
            _internal_set_boot_method(static_cast<::enterprise_management::BootInfo_BootMethod>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool secure_boot = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_secure_boot(&has_bits);
          _impl_.secure_boot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BootInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.BootInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.BootInfo.BootMethod boot_method = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_boot_method(), target);
  }

  // optional bool secure_boot = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_secure_boot(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.BootInfo)
  return target;
}

size_t BootInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.BootInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .enterprise_management.BootInfo.BootMethod boot_method = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_boot_method());
    }

    // optional bool secure_boot = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BootInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BootInfo*>(
      &from));
}

void BootInfo::MergeFrom(const BootInfo& from) {
  BootInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.BootInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.boot_method_ = from._impl_.boot_method_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.secure_boot_ = from._impl_.secure_boot_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BootInfo::CopyFrom(const BootInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.BootInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BootInfo::IsInitialized() const {
  return true;
}

void BootInfo::InternalSwap(BootInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BootInfo, _impl_.secure_boot_)
      + sizeof(BootInfo::_impl_.secure_boot_)
      - PROTOBUF_FIELD_OFFSET(BootInfo, _impl_.boot_method_)>(
          reinterpret_cast<char*>(&_impl_.boot_method_),
          reinterpret_cast<char*>(&other->_impl_.boot_method_));
}

std::string BootInfo::GetTypeName() const {
  return "enterprise_management.BootInfo";
}


// ===================================================================

class NetworkAdapterInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<NetworkAdapterInfo>()._impl_._has_bits_);
  static void set_has_device_class(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bus_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_vendor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_vendor_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_device_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

NetworkAdapterInfo::NetworkAdapterInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.NetworkAdapterInfo)
}
NetworkAdapterInfo::NetworkAdapterInfo(const NetworkAdapterInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  NetworkAdapterInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.driver_){from._impl_.driver_}
    , decltype(_impl_.vendor_name_){}
    , decltype(_impl_.device_name_){}
    , decltype(_impl_.device_class_){}
    , decltype(_impl_.bus_type_){}
    , decltype(_impl_.vendor_id_){}
    , decltype(_impl_.device_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.vendor_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vendor_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vendor_name()) {
    _this->_impl_.vendor_name_.Set(from._internal_vendor_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.device_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_name()) {
    _this->_impl_.device_name_.Set(from._internal_device_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.device_class_, &from._impl_.device_class_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.device_id_) -
    reinterpret_cast<char*>(&_impl_.device_class_)) + sizeof(_impl_.device_id_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.NetworkAdapterInfo)
}

inline void NetworkAdapterInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.driver_){arena}
    , decltype(_impl_.vendor_name_){}
    , decltype(_impl_.device_name_){}
    , decltype(_impl_.device_class_){0}
    , decltype(_impl_.bus_type_){0}
    , decltype(_impl_.vendor_id_){0}
    , decltype(_impl_.device_id_){0}
  };
  _impl_.vendor_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vendor_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.device_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NetworkAdapterInfo::~NetworkAdapterInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.NetworkAdapterInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NetworkAdapterInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.driver_.~RepeatedPtrField();
  _impl_.vendor_name_.Destroy();
  _impl_.device_name_.Destroy();
}

void NetworkAdapterInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NetworkAdapterInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.NetworkAdapterInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.driver_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.vendor_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.device_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.device_class_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.device_id_) -
        reinterpret_cast<char*>(&_impl_.device_class_)) + sizeof(_impl_.device_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NetworkAdapterInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.BusDeviceClass device_class = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::BusDeviceClass_IsValid(val))) {
            _internal_set_device_class(static_cast<::enterprise_management::BusDeviceClass>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BusType bus_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::BusType_IsValid(val))) {
            _internal_set_bus_type(static_cast<::enterprise_management::BusType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 vendor_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_vendor_id(&has_bits);
          _impl_.vendor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string vendor_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_vendor_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 device_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_device_id(&has_bits);
          _impl_.device_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string device_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_device_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string driver = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_driver();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NetworkAdapterInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.NetworkAdapterInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.BusDeviceClass device_class = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_device_class(), target);
  }

  // optional .enterprise_management.BusType bus_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_bus_type(), target);
  }

  // optional int32 vendor_id = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_vendor_id(), target);
  }

  // optional string vendor_name = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_vendor_name(), target);
  }

  // optional int32 device_id = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_device_id(), target);
  }

  // optional string device_name = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_device_name(), target);
  }

  // repeated string driver = 7;
  for (int i = 0, n = this->_internal_driver_size(); i < n; i++) {
    const auto& s = this->_internal_driver(i);
    target = stream->WriteString(7, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.NetworkAdapterInfo)
  return target;
}

size_t NetworkAdapterInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.NetworkAdapterInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string driver = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.driver_.size());
  for (int i = 0, n = _impl_.driver_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.driver_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string vendor_name = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_vendor_name());
    }

    // optional string device_name = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_name());
    }

    // optional .enterprise_management.BusDeviceClass device_class = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_device_class());
    }

    // optional .enterprise_management.BusType bus_type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_bus_type());
    }

    // optional int32 vendor_id = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_vendor_id());
    }

    // optional int32 device_id = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_device_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NetworkAdapterInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NetworkAdapterInfo*>(
      &from));
}

void NetworkAdapterInfo::MergeFrom(const NetworkAdapterInfo& from) {
  NetworkAdapterInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.NetworkAdapterInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.driver_.MergeFrom(from._impl_.driver_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_vendor_name(from._internal_vendor_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_device_name(from._internal_device_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.device_class_ = from._impl_.device_class_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.bus_type_ = from._impl_.bus_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.vendor_id_ = from._impl_.vendor_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.device_id_ = from._impl_.device_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetworkAdapterInfo::CopyFrom(const NetworkAdapterInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.NetworkAdapterInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkAdapterInfo::IsInitialized() const {
  return true;
}

void NetworkAdapterInfo::InternalSwap(NetworkAdapterInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.driver_.InternalSwap(&other->_impl_.driver_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vendor_name_, lhs_arena,
      &other->_impl_.vendor_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_name_, lhs_arena,
      &other->_impl_.device_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NetworkAdapterInfo, _impl_.device_id_)
      + sizeof(NetworkAdapterInfo::_impl_.device_id_)
      - PROTOBUF_FIELD_OFFSET(NetworkAdapterInfo, _impl_.device_class_)>(
          reinterpret_cast<char*>(&_impl_.device_class_),
          reinterpret_cast<char*>(&other->_impl_.device_class_));
}

std::string NetworkAdapterInfo::GetTypeName() const {
  return "enterprise_management.NetworkAdapterInfo";
}


// ===================================================================

class LaCrOsBrowserReport::_Internal {
 public:
  using HasBits = decltype(std::declval<LaCrOsBrowserReport>()._impl_._has_bits_);
  static const ::enterprise_management::DeviceUser& device_user(const LaCrOsBrowserReport* msg);
  static void set_has_device_user(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::enterprise_management::BrowserReport& browser_report(const LaCrOsBrowserReport* msg);
  static void set_has_browser_report(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::enterprise_management::DeviceUser&
LaCrOsBrowserReport::_Internal::device_user(const LaCrOsBrowserReport* msg) {
  return *msg->_impl_.device_user_;
}
const ::enterprise_management::BrowserReport&
LaCrOsBrowserReport::_Internal::browser_report(const LaCrOsBrowserReport* msg) {
  return *msg->_impl_.browser_report_;
}
LaCrOsBrowserReport::LaCrOsBrowserReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.LaCrOsBrowserReport)
}
LaCrOsBrowserReport::LaCrOsBrowserReport(const LaCrOsBrowserReport& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LaCrOsBrowserReport* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_user_){nullptr}
    , decltype(_impl_.browser_report_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_device_user()) {
    _this->_impl_.device_user_ = new ::enterprise_management::DeviceUser(*from._impl_.device_user_);
  }
  if (from._internal_has_browser_report()) {
    _this->_impl_.browser_report_ = new ::enterprise_management::BrowserReport(*from._impl_.browser_report_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.LaCrOsBrowserReport)
}

inline void LaCrOsBrowserReport::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_user_){nullptr}
    , decltype(_impl_.browser_report_){nullptr}
  };
}

LaCrOsBrowserReport::~LaCrOsBrowserReport() {
  // @@protoc_insertion_point(destructor:enterprise_management.LaCrOsBrowserReport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LaCrOsBrowserReport::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.device_user_;
  if (this != internal_default_instance()) delete _impl_.browser_report_;
}

void LaCrOsBrowserReport::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LaCrOsBrowserReport::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.LaCrOsBrowserReport)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.device_user_ != nullptr);
      _impl_.device_user_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.browser_report_ != nullptr);
      _impl_.browser_report_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LaCrOsBrowserReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DeviceUser device_user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_user(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BrowserReport browser_report = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_browser_report(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LaCrOsBrowserReport::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.LaCrOsBrowserReport)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DeviceUser device_user = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::device_user(this),
        _Internal::device_user(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.BrowserReport browser_report = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::browser_report(this),
        _Internal::browser_report(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.LaCrOsBrowserReport)
  return target;
}

size_t LaCrOsBrowserReport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.LaCrOsBrowserReport)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .enterprise_management.DeviceUser device_user = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_user_);
    }

    // optional .enterprise_management.BrowserReport browser_report = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.browser_report_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LaCrOsBrowserReport::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LaCrOsBrowserReport*>(
      &from));
}

void LaCrOsBrowserReport::MergeFrom(const LaCrOsBrowserReport& from) {
  LaCrOsBrowserReport* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.LaCrOsBrowserReport)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_device_user()->::enterprise_management::DeviceUser::MergeFrom(
          from._internal_device_user());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_browser_report()->::enterprise_management::BrowserReport::MergeFrom(
          from._internal_browser_report());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LaCrOsBrowserReport::CopyFrom(const LaCrOsBrowserReport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.LaCrOsBrowserReport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaCrOsBrowserReport::IsInitialized() const {
  if (_internal_has_device_user()) {
    if (!_impl_.device_user_->IsInitialized()) return false;
  }
  return true;
}

void LaCrOsBrowserReport::InternalSwap(LaCrOsBrowserReport* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LaCrOsBrowserReport, _impl_.browser_report_)
      + sizeof(LaCrOsBrowserReport::_impl_.browser_report_)
      - PROTOBUF_FIELD_OFFSET(LaCrOsBrowserReport, _impl_.device_user_)>(
          reinterpret_cast<char*>(&_impl_.device_user_),
          reinterpret_cast<char*>(&other->_impl_.device_user_));
}

std::string LaCrOsBrowserReport::GetTypeName() const {
  return "enterprise_management.LaCrOsBrowserReport";
}


// ===================================================================

class DeviceStatusReportRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceStatusReportRequest>()._impl_._has_bits_);
  static void set_has_os_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_firmware_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_boot_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_browser_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_system_ram_total(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::enterprise_management::OsUpdateStatus& os_update_status(const DeviceStatusReportRequest* msg);
  static void set_has_os_update_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::enterprise_management::AppStatus& running_kiosk_app(const DeviceStatusReportRequest* msg);
  static void set_has_running_kiosk_app(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_sound_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static const ::enterprise_management::TpmVersionInfo& tpm_version_info(const DeviceStatusReportRequest* msg);
  static void set_has_tpm_version_info(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static const ::enterprise_management::TpmStatusInfo& tpm_status_info(const DeviceStatusReportRequest* msg);
  static void set_has_tpm_status_info(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_write_protect_switch(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static const ::enterprise_management::PowerStatus& power_status(const DeviceStatusReportRequest* msg);
  static void set_has_power_status(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::enterprise_management::StorageStatus& storage_status(const DeviceStatusReportRequest* msg);
  static void set_has_storage_status(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::enterprise_management::BoardStatus& board_status(const DeviceStatusReportRequest* msg);
  static void set_has_board_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::enterprise_management::SystemStatus& system_status(const DeviceStatusReportRequest* msg);
  static void set_has_system_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::enterprise_management::StatefulPartitionInfo& stateful_partition_info(const DeviceStatusReportRequest* msg);
  static void set_has_stateful_partition_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::enterprise_management::GraphicsStatus& graphics_status(const DeviceStatusReportRequest* msg);
  static void set_has_graphics_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::enterprise_management::TimezoneInfo& timezone_info(const DeviceStatusReportRequest* msg);
  static void set_has_timezone_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::enterprise_management::MemoryInfo& memory_info(const DeviceStatusReportRequest* msg);
  static void set_has_memory_info(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::enterprise_management::GlobalCpuInfo& global_cpu_info(const DeviceStatusReportRequest* msg);
  static void set_has_global_cpu_info(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::enterprise_management::SmbiosInfo& smbios_info(const DeviceStatusReportRequest* msg);
  static void set_has_smbios_info(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::enterprise_management::KernelParameters& kernel_parameters(const DeviceStatusReportRequest* msg);
  static void set_has_kernel_parameters(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::enterprise_management::EFIVars& efi_vars(const DeviceStatusReportRequest* msg);
  static void set_has_efi_vars(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::enterprise_management::BootInfo& boot_info(const DeviceStatusReportRequest* msg);
  static void set_has_boot_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_root_device_total_storage_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
};

const ::enterprise_management::OsUpdateStatus&
DeviceStatusReportRequest::_Internal::os_update_status(const DeviceStatusReportRequest* msg) {
  return *msg->_impl_.os_update_status_;
}
const ::enterprise_management::AppStatus&
DeviceStatusReportRequest::_Internal::running_kiosk_app(const DeviceStatusReportRequest* msg) {
  return *msg->_impl_.running_kiosk_app_;
}
const ::enterprise_management::TpmVersionInfo&
DeviceStatusReportRequest::_Internal::tpm_version_info(const DeviceStatusReportRequest* msg) {
  return *msg->_impl_.tpm_version_info_;
}
const ::enterprise_management::TpmStatusInfo&
DeviceStatusReportRequest::_Internal::tpm_status_info(const DeviceStatusReportRequest* msg) {
  return *msg->_impl_.tpm_status_info_;
}
const ::enterprise_management::PowerStatus&
DeviceStatusReportRequest::_Internal::power_status(const DeviceStatusReportRequest* msg) {
  return *msg->_impl_.power_status_;
}
const ::enterprise_management::StorageStatus&
DeviceStatusReportRequest::_Internal::storage_status(const DeviceStatusReportRequest* msg) {
  return *msg->_impl_.storage_status_;
}
const ::enterprise_management::BoardStatus&
DeviceStatusReportRequest::_Internal::board_status(const DeviceStatusReportRequest* msg) {
  return *msg->_impl_.board_status_;
}
const ::enterprise_management::SystemStatus&
DeviceStatusReportRequest::_Internal::system_status(const DeviceStatusReportRequest* msg) {
  return *msg->_impl_.system_status_;
}
const ::enterprise_management::StatefulPartitionInfo&
DeviceStatusReportRequest::_Internal::stateful_partition_info(const DeviceStatusReportRequest* msg) {
  return *msg->_impl_.stateful_partition_info_;
}
const ::enterprise_management::GraphicsStatus&
DeviceStatusReportRequest::_Internal::graphics_status(const DeviceStatusReportRequest* msg) {
  return *msg->_impl_.graphics_status_;
}
const ::enterprise_management::TimezoneInfo&
DeviceStatusReportRequest::_Internal::timezone_info(const DeviceStatusReportRequest* msg) {
  return *msg->_impl_.timezone_info_;
}
const ::enterprise_management::MemoryInfo&
DeviceStatusReportRequest::_Internal::memory_info(const DeviceStatusReportRequest* msg) {
  return *msg->_impl_.memory_info_;
}
const ::enterprise_management::GlobalCpuInfo&
DeviceStatusReportRequest::_Internal::global_cpu_info(const DeviceStatusReportRequest* msg) {
  return *msg->_impl_.global_cpu_info_;
}
const ::enterprise_management::SmbiosInfo&
DeviceStatusReportRequest::_Internal::smbios_info(const DeviceStatusReportRequest* msg) {
  return *msg->_impl_.smbios_info_;
}
const ::enterprise_management::KernelParameters&
DeviceStatusReportRequest::_Internal::kernel_parameters(const DeviceStatusReportRequest* msg) {
  return *msg->_impl_.kernel_parameters_;
}
const ::enterprise_management::EFIVars&
DeviceStatusReportRequest::_Internal::efi_vars(const DeviceStatusReportRequest* msg) {
  return *msg->_impl_.efi_vars_;
}
const ::enterprise_management::BootInfo&
DeviceStatusReportRequest::_Internal::boot_info(const DeviceStatusReportRequest* msg) {
  return *msg->_impl_.boot_info_;
}
DeviceStatusReportRequest::DeviceStatusReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceStatusReportRequest)
}
DeviceStatusReportRequest::DeviceStatusReportRequest(const DeviceStatusReportRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceStatusReportRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.active_periods_){from._impl_.active_periods_}
    , decltype(_impl_.network_interfaces_){from._impl_.network_interfaces_}
    , decltype(_impl_.users_){from._impl_.users_}
    , decltype(_impl_.volume_infos_){from._impl_.volume_infos_}
    , decltype(_impl_.network_states_){from._impl_.network_states_}
    , decltype(_impl_.cpu_utilization_pct_samples_){from._impl_.cpu_utilization_pct_samples_}
    , decltype(_impl_.system_ram_free_samples_){from._impl_.system_ram_free_samples_}
    , decltype(_impl_.cpu_temp_infos_){from._impl_.cpu_temp_infos_}
    , decltype(_impl_.cpu_utilization_infos_){from._impl_.cpu_utilization_infos_}
    , decltype(_impl_.system_ram_free_infos_){from._impl_.system_ram_free_infos_}
    , decltype(_impl_.cpu_info_){from._impl_.cpu_info_}
    , decltype(_impl_.crash_report_infos_){from._impl_.crash_report_infos_}
    , decltype(_impl_.backlight_info_){from._impl_.backlight_info_}
    , decltype(_impl_.fan_info_){from._impl_.fan_info_}
    , decltype(_impl_.bluetooth_adapter_info_){from._impl_.bluetooth_adapter_info_}
    , decltype(_impl_.network_adapter_info_){from._impl_.network_adapter_info_}
    , decltype(_impl_.lacros_browser_report_){from._impl_.lacros_browser_report_}
    , decltype(_impl_.os_version_){}
    , decltype(_impl_.firmware_version_){}
    , decltype(_impl_.boot_mode_){}
    , decltype(_impl_.browser_version_){}
    , decltype(_impl_.os_update_status_){nullptr}
    , decltype(_impl_.running_kiosk_app_){nullptr}
    , decltype(_impl_.tpm_version_info_){nullptr}
    , decltype(_impl_.tpm_status_info_){nullptr}
    , decltype(_impl_.power_status_){nullptr}
    , decltype(_impl_.storage_status_){nullptr}
    , decltype(_impl_.board_status_){nullptr}
    , decltype(_impl_.system_status_){nullptr}
    , decltype(_impl_.stateful_partition_info_){nullptr}
    , decltype(_impl_.graphics_status_){nullptr}
    , decltype(_impl_.timezone_info_){nullptr}
    , decltype(_impl_.memory_info_){nullptr}
    , decltype(_impl_.global_cpu_info_){nullptr}
    , decltype(_impl_.smbios_info_){nullptr}
    , decltype(_impl_.kernel_parameters_){nullptr}
    , decltype(_impl_.efi_vars_){nullptr}
    , decltype(_impl_.boot_info_){nullptr}
    , decltype(_impl_.system_ram_total_){}
    , decltype(_impl_.sound_volume_){}
    , decltype(_impl_.channel_){}
    , decltype(_impl_.root_device_total_storage_bytes_){}
    , decltype(_impl_.write_protect_switch_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.os_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_os_version()) {
    _this->_impl_.os_version_.Set(from._internal_os_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.firmware_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.firmware_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_firmware_version()) {
    _this->_impl_.firmware_version_.Set(from._internal_firmware_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.boot_mode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.boot_mode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_boot_mode()) {
    _this->_impl_.boot_mode_.Set(from._internal_boot_mode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.browser_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_browser_version()) {
    _this->_impl_.browser_version_.Set(from._internal_browser_version(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_os_update_status()) {
    _this->_impl_.os_update_status_ = new ::enterprise_management::OsUpdateStatus(*from._impl_.os_update_status_);
  }
  if (from._internal_has_running_kiosk_app()) {
    _this->_impl_.running_kiosk_app_ = new ::enterprise_management::AppStatus(*from._impl_.running_kiosk_app_);
  }
  if (from._internal_has_tpm_version_info()) {
    _this->_impl_.tpm_version_info_ = new ::enterprise_management::TpmVersionInfo(*from._impl_.tpm_version_info_);
  }
  if (from._internal_has_tpm_status_info()) {
    _this->_impl_.tpm_status_info_ = new ::enterprise_management::TpmStatusInfo(*from._impl_.tpm_status_info_);
  }
  if (from._internal_has_power_status()) {
    _this->_impl_.power_status_ = new ::enterprise_management::PowerStatus(*from._impl_.power_status_);
  }
  if (from._internal_has_storage_status()) {
    _this->_impl_.storage_status_ = new ::enterprise_management::StorageStatus(*from._impl_.storage_status_);
  }
  if (from._internal_has_board_status()) {
    _this->_impl_.board_status_ = new ::enterprise_management::BoardStatus(*from._impl_.board_status_);
  }
  if (from._internal_has_system_status()) {
    _this->_impl_.system_status_ = new ::enterprise_management::SystemStatus(*from._impl_.system_status_);
  }
  if (from._internal_has_stateful_partition_info()) {
    _this->_impl_.stateful_partition_info_ = new ::enterprise_management::StatefulPartitionInfo(*from._impl_.stateful_partition_info_);
  }
  if (from._internal_has_graphics_status()) {
    _this->_impl_.graphics_status_ = new ::enterprise_management::GraphicsStatus(*from._impl_.graphics_status_);
  }
  if (from._internal_has_timezone_info()) {
    _this->_impl_.timezone_info_ = new ::enterprise_management::TimezoneInfo(*from._impl_.timezone_info_);
  }
  if (from._internal_has_memory_info()) {
    _this->_impl_.memory_info_ = new ::enterprise_management::MemoryInfo(*from._impl_.memory_info_);
  }
  if (from._internal_has_global_cpu_info()) {
    _this->_impl_.global_cpu_info_ = new ::enterprise_management::GlobalCpuInfo(*from._impl_.global_cpu_info_);
  }
  if (from._internal_has_smbios_info()) {
    _this->_impl_.smbios_info_ = new ::enterprise_management::SmbiosInfo(*from._impl_.smbios_info_);
  }
  if (from._internal_has_kernel_parameters()) {
    _this->_impl_.kernel_parameters_ = new ::enterprise_management::KernelParameters(*from._impl_.kernel_parameters_);
  }
  if (from._internal_has_efi_vars()) {
    _this->_impl_.efi_vars_ = new ::enterprise_management::EFIVars(*from._impl_.efi_vars_);
  }
  if (from._internal_has_boot_info()) {
    _this->_impl_.boot_info_ = new ::enterprise_management::BootInfo(*from._impl_.boot_info_);
  }
  ::memcpy(&_impl_.system_ram_total_, &from._impl_.system_ram_total_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.write_protect_switch_) -
    reinterpret_cast<char*>(&_impl_.system_ram_total_)) + sizeof(_impl_.write_protect_switch_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceStatusReportRequest)
}

inline void DeviceStatusReportRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.active_periods_){arena}
    , decltype(_impl_.network_interfaces_){arena}
    , decltype(_impl_.users_){arena}
    , decltype(_impl_.volume_infos_){arena}
    , decltype(_impl_.network_states_){arena}
    , decltype(_impl_.cpu_utilization_pct_samples_){arena}
    , decltype(_impl_.system_ram_free_samples_){arena}
    , decltype(_impl_.cpu_temp_infos_){arena}
    , decltype(_impl_.cpu_utilization_infos_){arena}
    , decltype(_impl_.system_ram_free_infos_){arena}
    , decltype(_impl_.cpu_info_){arena}
    , decltype(_impl_.crash_report_infos_){arena}
    , decltype(_impl_.backlight_info_){arena}
    , decltype(_impl_.fan_info_){arena}
    , decltype(_impl_.bluetooth_adapter_info_){arena}
    , decltype(_impl_.network_adapter_info_){arena}
    , decltype(_impl_.lacros_browser_report_){arena}
    , decltype(_impl_.os_version_){}
    , decltype(_impl_.firmware_version_){}
    , decltype(_impl_.boot_mode_){}
    , decltype(_impl_.browser_version_){}
    , decltype(_impl_.os_update_status_){nullptr}
    , decltype(_impl_.running_kiosk_app_){nullptr}
    , decltype(_impl_.tpm_version_info_){nullptr}
    , decltype(_impl_.tpm_status_info_){nullptr}
    , decltype(_impl_.power_status_){nullptr}
    , decltype(_impl_.storage_status_){nullptr}
    , decltype(_impl_.board_status_){nullptr}
    , decltype(_impl_.system_status_){nullptr}
    , decltype(_impl_.stateful_partition_info_){nullptr}
    , decltype(_impl_.graphics_status_){nullptr}
    , decltype(_impl_.timezone_info_){nullptr}
    , decltype(_impl_.memory_info_){nullptr}
    , decltype(_impl_.global_cpu_info_){nullptr}
    , decltype(_impl_.smbios_info_){nullptr}
    , decltype(_impl_.kernel_parameters_){nullptr}
    , decltype(_impl_.efi_vars_){nullptr}
    , decltype(_impl_.boot_info_){nullptr}
    , decltype(_impl_.system_ram_total_){int64_t{0}}
    , decltype(_impl_.sound_volume_){0}
    , decltype(_impl_.channel_){0}
    , decltype(_impl_.root_device_total_storage_bytes_){int64_t{0}}
    , decltype(_impl_.write_protect_switch_){false}
  };
  _impl_.os_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.firmware_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.firmware_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.boot_mode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.boot_mode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.browser_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceStatusReportRequest::~DeviceStatusReportRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceStatusReportRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceStatusReportRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.active_periods_.~RepeatedPtrField();
  _impl_.network_interfaces_.~RepeatedPtrField();
  _impl_.users_.~RepeatedPtrField();
  _impl_.volume_infos_.~RepeatedPtrField();
  _impl_.network_states_.~RepeatedPtrField();
  _impl_.cpu_utilization_pct_samples_.~RepeatedField();
  _impl_.system_ram_free_samples_.~RepeatedField();
  _impl_.cpu_temp_infos_.~RepeatedPtrField();
  _impl_.cpu_utilization_infos_.~RepeatedPtrField();
  _impl_.system_ram_free_infos_.~RepeatedPtrField();
  _impl_.cpu_info_.~RepeatedPtrField();
  _impl_.crash_report_infos_.~RepeatedPtrField();
  _impl_.backlight_info_.~RepeatedPtrField();
  _impl_.fan_info_.~RepeatedPtrField();
  _impl_.bluetooth_adapter_info_.~RepeatedPtrField();
  _impl_.network_adapter_info_.~RepeatedPtrField();
  _impl_.lacros_browser_report_.~RepeatedPtrField();
  _impl_.os_version_.Destroy();
  _impl_.firmware_version_.Destroy();
  _impl_.boot_mode_.Destroy();
  _impl_.browser_version_.Destroy();
  if (this != internal_default_instance()) delete _impl_.os_update_status_;
  if (this != internal_default_instance()) delete _impl_.running_kiosk_app_;
  if (this != internal_default_instance()) delete _impl_.tpm_version_info_;
  if (this != internal_default_instance()) delete _impl_.tpm_status_info_;
  if (this != internal_default_instance()) delete _impl_.power_status_;
  if (this != internal_default_instance()) delete _impl_.storage_status_;
  if (this != internal_default_instance()) delete _impl_.board_status_;
  if (this != internal_default_instance()) delete _impl_.system_status_;
  if (this != internal_default_instance()) delete _impl_.stateful_partition_info_;
  if (this != internal_default_instance()) delete _impl_.graphics_status_;
  if (this != internal_default_instance()) delete _impl_.timezone_info_;
  if (this != internal_default_instance()) delete _impl_.memory_info_;
  if (this != internal_default_instance()) delete _impl_.global_cpu_info_;
  if (this != internal_default_instance()) delete _impl_.smbios_info_;
  if (this != internal_default_instance()) delete _impl_.kernel_parameters_;
  if (this != internal_default_instance()) delete _impl_.efi_vars_;
  if (this != internal_default_instance()) delete _impl_.boot_info_;
}

void DeviceStatusReportRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceStatusReportRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceStatusReportRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.active_periods_.Clear();
  _impl_.network_interfaces_.Clear();
  _impl_.users_.Clear();
  _impl_.volume_infos_.Clear();
  _impl_.network_states_.Clear();
  _impl_.cpu_utilization_pct_samples_.Clear();
  _impl_.system_ram_free_samples_.Clear();
  _impl_.cpu_temp_infos_.Clear();
  _impl_.cpu_utilization_infos_.Clear();
  _impl_.system_ram_free_infos_.Clear();
  _impl_.cpu_info_.Clear();
  _impl_.crash_report_infos_.Clear();
  _impl_.backlight_info_.Clear();
  _impl_.fan_info_.Clear();
  _impl_.bluetooth_adapter_info_.Clear();
  _impl_.network_adapter_info_.Clear();
  _impl_.lacros_browser_report_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.os_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.firmware_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.boot_mode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.browser_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.os_update_status_ != nullptr);
      _impl_.os_update_status_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.running_kiosk_app_ != nullptr);
      _impl_.running_kiosk_app_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.tpm_version_info_ != nullptr);
      _impl_.tpm_version_info_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.tpm_status_info_ != nullptr);
      _impl_.tpm_status_info_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.power_status_ != nullptr);
      _impl_.power_status_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.storage_status_ != nullptr);
      _impl_.storage_status_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.board_status_ != nullptr);
      _impl_.board_status_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.system_status_ != nullptr);
      _impl_.system_status_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.stateful_partition_info_ != nullptr);
      _impl_.stateful_partition_info_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.graphics_status_ != nullptr);
      _impl_.graphics_status_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.timezone_info_ != nullptr);
      _impl_.timezone_info_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(_impl_.memory_info_ != nullptr);
      _impl_.memory_info_->Clear();
    }
  }
  if (cached_has_bits & 0x001f0000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(_impl_.global_cpu_info_ != nullptr);
      _impl_.global_cpu_info_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(_impl_.smbios_info_ != nullptr);
      _impl_.smbios_info_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(_impl_.kernel_parameters_ != nullptr);
      _impl_.kernel_parameters_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(_impl_.efi_vars_ != nullptr);
      _impl_.efi_vars_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(_impl_.boot_info_ != nullptr);
      _impl_.boot_info_->Clear();
    }
  }
  if (cached_has_bits & 0x00e00000u) {
    ::memset(&_impl_.system_ram_total_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.channel_) -
        reinterpret_cast<char*>(&_impl_.system_ram_total_)) + sizeof(_impl_.channel_));
  }
  if (cached_has_bits & 0x03000000u) {
    ::memset(&_impl_.root_device_total_storage_bytes_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.write_protect_switch_) -
        reinterpret_cast<char*>(&_impl_.root_device_total_storage_bytes_)) + sizeof(_impl_.write_protect_switch_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceStatusReportRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string os_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_os_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string firmware_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_firmware_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string boot_mode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_boot_mode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string browser_version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_browser_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.ActiveTimePeriod active_periods = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_active_periods(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.NetworkInterface network_interfaces = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_network_interfaces(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.DeviceUser users = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_users(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.VolumeInfo volume_infos = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_volume_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.NetworkState network_states = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_network_states(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 cpu_utilization_pct_samples = 12 [deprecated = true];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_cpu_utilization_pct_samples(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<96>(ptr));
        } else if (static_cast<uint8_t>(tag) == 98) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_cpu_utilization_pct_samples(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 system_ram_total = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_system_ram_total(&has_bits);
          _impl_.system_ram_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 system_ram_free_samples = 15 [deprecated = true];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_system_ram_free_samples(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<120>(ptr));
        } else if (static_cast<uint8_t>(tag) == 122) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_system_ram_free_samples(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.CPUTempInfo cpu_temp_infos = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_cpu_temp_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<130>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.OsUpdateStatus os_update_status = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_os_update_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AppStatus running_kiosk_app = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_running_kiosk_app(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sound_volume = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_sound_volume(&has_bits);
          _impl_.sound_volume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.TpmVersionInfo tpm_version_info = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_tpm_version_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.Channel channel = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::Channel_IsValid(val))) {
            _internal_set_channel(static_cast<::enterprise_management::Channel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(22, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.TpmStatusInfo tpm_status_info = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_tpm_status_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool write_protect_switch = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_write_protect_switch(&has_bits);
          _impl_.write_protect_switch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PowerStatus power_status = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_power_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.StorageStatus storage_status = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BoardStatus board_status = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_board_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.SystemStatus system_status = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_system_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.StatefulPartitionInfo stateful_partition_info = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_stateful_partition_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.CpuUtilizationInfo cpu_utilization_infos = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_cpu_utilization_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<242>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.SystemFreeRamInfo system_ram_free_infos = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_system_ram_free_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<250>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.CpuInfo cpu_info = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_cpu_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<258>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.GraphicsStatus graphics_status = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_graphics_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.CrashReportInfo crash_report_infos = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_crash_report_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<274>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.TimezoneInfo timezone_info = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_timezone_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.MemoryInfo memory_info = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_memory_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.BacklightInfo backlight_info = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_backlight_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<298>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.FanInfo fan_info = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_fan_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<306>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.GlobalCpuInfo global_cpu_info = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_global_cpu_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.BluetoothAdapterInfo bluetooth_adapter_info = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_bluetooth_adapter_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<322>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.SmbiosInfo smbios_info = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_smbios_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.KernelParameters kernel_parameters = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_kernel_parameters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.EFIVars efi_vars = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_efi_vars(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BootInfo boot_info = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_boot_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.NetworkAdapterInfo network_adapter_info = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_network_adapter_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<362>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.LaCrOsBrowserReport lacros_browser_report = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_lacros_browser_report(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<370>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 root_device_total_storage_bytes = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_root_device_total_storage_bytes(&has_bits);
          _impl_.root_device_total_storage_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceStatusReportRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceStatusReportRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string os_version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_os_version(), target);
  }

  // optional string firmware_version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_firmware_version(), target);
  }

  // optional string boot_mode = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_boot_mode(), target);
  }

  // optional string browser_version = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_browser_version(), target);
  }

  // repeated .enterprise_management.ActiveTimePeriod active_periods = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_active_periods_size()); i < n; i++) {
    const auto& repfield = this->_internal_active_periods(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.NetworkInterface network_interfaces = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_network_interfaces_size()); i < n; i++) {
    const auto& repfield = this->_internal_network_interfaces(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.DeviceUser users = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_users_size()); i < n; i++) {
    const auto& repfield = this->_internal_users(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.VolumeInfo volume_infos = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_volume_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_volume_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.NetworkState network_states = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_network_states_size()); i < n; i++) {
    const auto& repfield = this->_internal_network_states(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated int32 cpu_utilization_pct_samples = 12 [deprecated = true];
  for (int i = 0, n = this->_internal_cpu_utilization_pct_samples_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_cpu_utilization_pct_samples(i), target);
  }

  // optional int64 system_ram_total = 14;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(14, this->_internal_system_ram_total(), target);
  }

  // repeated int64 system_ram_free_samples = 15 [deprecated = true];
  for (int i = 0, n = this->_internal_system_ram_free_samples_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(15, this->_internal_system_ram_free_samples(i), target);
  }

  // repeated .enterprise_management.CPUTempInfo cpu_temp_infos = 16;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cpu_temp_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_cpu_temp_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.OsUpdateStatus os_update_status = 17;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::os_update_status(this),
        _Internal::os_update_status(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.AppStatus running_kiosk_app = 18;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::running_kiosk_app(this),
        _Internal::running_kiosk_app(this).GetCachedSize(), target, stream);
  }

  // optional int32 sound_volume = 19;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(19, this->_internal_sound_volume(), target);
  }

  // optional .enterprise_management.TpmVersionInfo tpm_version_info = 21;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::tpm_version_info(this),
        _Internal::tpm_version_info(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.Channel channel = 22;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      22, this->_internal_channel(), target);
  }

  // optional .enterprise_management.TpmStatusInfo tpm_status_info = 23;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::tpm_status_info(this),
        _Internal::tpm_status_info(this).GetCachedSize(), target, stream);
  }

  // optional bool write_protect_switch = 24;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(24, this->_internal_write_protect_switch(), target);
  }

  // optional .enterprise_management.PowerStatus power_status = 25;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::power_status(this),
        _Internal::power_status(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.StorageStatus storage_status = 26;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(26, _Internal::storage_status(this),
        _Internal::storage_status(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.BoardStatus board_status = 27;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(27, _Internal::board_status(this),
        _Internal::board_status(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.SystemStatus system_status = 28;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(28, _Internal::system_status(this),
        _Internal::system_status(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.StatefulPartitionInfo stateful_partition_info = 29;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(29, _Internal::stateful_partition_info(this),
        _Internal::stateful_partition_info(this).GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.CpuUtilizationInfo cpu_utilization_infos = 30;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cpu_utilization_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_cpu_utilization_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(30, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.SystemFreeRamInfo system_ram_free_infos = 31;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_system_ram_free_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_system_ram_free_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(31, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.CpuInfo cpu_info = 32;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cpu_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_cpu_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(32, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.GraphicsStatus graphics_status = 33;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(33, _Internal::graphics_status(this),
        _Internal::graphics_status(this).GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.CrashReportInfo crash_report_infos = 34;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_crash_report_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_crash_report_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(34, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.TimezoneInfo timezone_info = 35;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(35, _Internal::timezone_info(this),
        _Internal::timezone_info(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.MemoryInfo memory_info = 36;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(36, _Internal::memory_info(this),
        _Internal::memory_info(this).GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.BacklightInfo backlight_info = 37;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_backlight_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_backlight_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(37, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.FanInfo fan_info = 38;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fan_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_fan_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(38, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.GlobalCpuInfo global_cpu_info = 39;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(39, _Internal::global_cpu_info(this),
        _Internal::global_cpu_info(this).GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.BluetoothAdapterInfo bluetooth_adapter_info = 40;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bluetooth_adapter_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_bluetooth_adapter_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(40, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.SmbiosInfo smbios_info = 41;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(41, _Internal::smbios_info(this),
        _Internal::smbios_info(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.KernelParameters kernel_parameters = 42;
  if (cached_has_bits & 0x00040000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(42, _Internal::kernel_parameters(this),
        _Internal::kernel_parameters(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.EFIVars efi_vars = 43;
  if (cached_has_bits & 0x00080000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(43, _Internal::efi_vars(this),
        _Internal::efi_vars(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.BootInfo boot_info = 44;
  if (cached_has_bits & 0x00100000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(44, _Internal::boot_info(this),
        _Internal::boot_info(this).GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.NetworkAdapterInfo network_adapter_info = 45;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_network_adapter_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_network_adapter_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(45, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.LaCrOsBrowserReport lacros_browser_report = 46;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_lacros_browser_report_size()); i < n; i++) {
    const auto& repfield = this->_internal_lacros_browser_report(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(46, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int64 root_device_total_storage_bytes = 47;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(47, this->_internal_root_device_total_storage_bytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceStatusReportRequest)
  return target;
}

size_t DeviceStatusReportRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceStatusReportRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.ActiveTimePeriod active_periods = 6;
  total_size += 1UL * this->_internal_active_periods_size();
  for (const auto& msg : this->_impl_.active_periods_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.NetworkInterface network_interfaces = 8;
  total_size += 1UL * this->_internal_network_interfaces_size();
  for (const auto& msg : this->_impl_.network_interfaces_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.DeviceUser users = 9;
  total_size += 1UL * this->_internal_users_size();
  for (const auto& msg : this->_impl_.users_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.VolumeInfo volume_infos = 10;
  total_size += 1UL * this->_internal_volume_infos_size();
  for (const auto& msg : this->_impl_.volume_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.NetworkState network_states = 11;
  total_size += 1UL * this->_internal_network_states_size();
  for (const auto& msg : this->_impl_.network_states_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 cpu_utilization_pct_samples = 12 [deprecated = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.cpu_utilization_pct_samples_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_cpu_utilization_pct_samples_size());
    total_size += data_size;
  }

  // repeated int64 system_ram_free_samples = 15 [deprecated = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.system_ram_free_samples_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_system_ram_free_samples_size());
    total_size += data_size;
  }

  // repeated .enterprise_management.CPUTempInfo cpu_temp_infos = 16;
  total_size += 2UL * this->_internal_cpu_temp_infos_size();
  for (const auto& msg : this->_impl_.cpu_temp_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.CpuUtilizationInfo cpu_utilization_infos = 30;
  total_size += 2UL * this->_internal_cpu_utilization_infos_size();
  for (const auto& msg : this->_impl_.cpu_utilization_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.SystemFreeRamInfo system_ram_free_infos = 31;
  total_size += 2UL * this->_internal_system_ram_free_infos_size();
  for (const auto& msg : this->_impl_.system_ram_free_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.CpuInfo cpu_info = 32;
  total_size += 2UL * this->_internal_cpu_info_size();
  for (const auto& msg : this->_impl_.cpu_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.CrashReportInfo crash_report_infos = 34;
  total_size += 2UL * this->_internal_crash_report_infos_size();
  for (const auto& msg : this->_impl_.crash_report_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.BacklightInfo backlight_info = 37;
  total_size += 2UL * this->_internal_backlight_info_size();
  for (const auto& msg : this->_impl_.backlight_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.FanInfo fan_info = 38;
  total_size += 2UL * this->_internal_fan_info_size();
  for (const auto& msg : this->_impl_.fan_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.BluetoothAdapterInfo bluetooth_adapter_info = 40;
  total_size += 2UL * this->_internal_bluetooth_adapter_info_size();
  for (const auto& msg : this->_impl_.bluetooth_adapter_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.NetworkAdapterInfo network_adapter_info = 45;
  total_size += 2UL * this->_internal_network_adapter_info_size();
  for (const auto& msg : this->_impl_.network_adapter_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.LaCrOsBrowserReport lacros_browser_report = 46;
  total_size += 2UL * this->_internal_lacros_browser_report_size();
  for (const auto& msg : this->_impl_.lacros_browser_report_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string os_version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_os_version());
    }

    // optional string firmware_version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_firmware_version());
    }

    // optional string boot_mode = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_boot_mode());
    }

    // optional string browser_version = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_browser_version());
    }

    // optional .enterprise_management.OsUpdateStatus os_update_status = 17;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.os_update_status_);
    }

    // optional .enterprise_management.AppStatus running_kiosk_app = 18;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.running_kiosk_app_);
    }

    // optional .enterprise_management.TpmVersionInfo tpm_version_info = 21;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tpm_version_info_);
    }

    // optional .enterprise_management.TpmStatusInfo tpm_status_info = 23;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tpm_status_info_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .enterprise_management.PowerStatus power_status = 25;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.power_status_);
    }

    // optional .enterprise_management.StorageStatus storage_status = 26;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_status_);
    }

    // optional .enterprise_management.BoardStatus board_status = 27;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.board_status_);
    }

    // optional .enterprise_management.SystemStatus system_status = 28;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.system_status_);
    }

    // optional .enterprise_management.StatefulPartitionInfo stateful_partition_info = 29;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stateful_partition_info_);
    }

    // optional .enterprise_management.GraphicsStatus graphics_status = 33;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.graphics_status_);
    }

    // optional .enterprise_management.TimezoneInfo timezone_info = 35;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timezone_info_);
    }

    // optional .enterprise_management.MemoryInfo memory_info = 36;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.memory_info_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .enterprise_management.GlobalCpuInfo global_cpu_info = 39;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.global_cpu_info_);
    }

    // optional .enterprise_management.SmbiosInfo smbios_info = 41;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.smbios_info_);
    }

    // optional .enterprise_management.KernelParameters kernel_parameters = 42;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kernel_parameters_);
    }

    // optional .enterprise_management.EFIVars efi_vars = 43;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.efi_vars_);
    }

    // optional .enterprise_management.BootInfo boot_info = 44;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.boot_info_);
    }

    // optional int64 system_ram_total = 14;
    if (cached_has_bits & 0x00200000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_system_ram_total());
    }

    // optional int32 sound_volume = 19;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_sound_volume());
    }

    // optional .enterprise_management.Channel channel = 22;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_channel());
    }

  }
  if (cached_has_bits & 0x03000000u) {
    // optional int64 root_device_total_storage_bytes = 47;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_root_device_total_storage_bytes());
    }

    // optional bool write_protect_switch = 24;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceStatusReportRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceStatusReportRequest*>(
      &from));
}

void DeviceStatusReportRequest::MergeFrom(const DeviceStatusReportRequest& from) {
  DeviceStatusReportRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceStatusReportRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.active_periods_.MergeFrom(from._impl_.active_periods_);
  _this->_impl_.network_interfaces_.MergeFrom(from._impl_.network_interfaces_);
  _this->_impl_.users_.MergeFrom(from._impl_.users_);
  _this->_impl_.volume_infos_.MergeFrom(from._impl_.volume_infos_);
  _this->_impl_.network_states_.MergeFrom(from._impl_.network_states_);
  _this->_impl_.cpu_utilization_pct_samples_.MergeFrom(from._impl_.cpu_utilization_pct_samples_);
  _this->_impl_.system_ram_free_samples_.MergeFrom(from._impl_.system_ram_free_samples_);
  _this->_impl_.cpu_temp_infos_.MergeFrom(from._impl_.cpu_temp_infos_);
  _this->_impl_.cpu_utilization_infos_.MergeFrom(from._impl_.cpu_utilization_infos_);
  _this->_impl_.system_ram_free_infos_.MergeFrom(from._impl_.system_ram_free_infos_);
  _this->_impl_.cpu_info_.MergeFrom(from._impl_.cpu_info_);
  _this->_impl_.crash_report_infos_.MergeFrom(from._impl_.crash_report_infos_);
  _this->_impl_.backlight_info_.MergeFrom(from._impl_.backlight_info_);
  _this->_impl_.fan_info_.MergeFrom(from._impl_.fan_info_);
  _this->_impl_.bluetooth_adapter_info_.MergeFrom(from._impl_.bluetooth_adapter_info_);
  _this->_impl_.network_adapter_info_.MergeFrom(from._impl_.network_adapter_info_);
  _this->_impl_.lacros_browser_report_.MergeFrom(from._impl_.lacros_browser_report_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_os_version(from._internal_os_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_firmware_version(from._internal_firmware_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_boot_mode(from._internal_boot_mode());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_browser_version(from._internal_browser_version());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_os_update_status()->::enterprise_management::OsUpdateStatus::MergeFrom(
          from._internal_os_update_status());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_running_kiosk_app()->::enterprise_management::AppStatus::MergeFrom(
          from._internal_running_kiosk_app());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_tpm_version_info()->::enterprise_management::TpmVersionInfo::MergeFrom(
          from._internal_tpm_version_info());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_tpm_status_info()->::enterprise_management::TpmStatusInfo::MergeFrom(
          from._internal_tpm_status_info());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_power_status()->::enterprise_management::PowerStatus::MergeFrom(
          from._internal_power_status());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_storage_status()->::enterprise_management::StorageStatus::MergeFrom(
          from._internal_storage_status());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_board_status()->::enterprise_management::BoardStatus::MergeFrom(
          from._internal_board_status());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_system_status()->::enterprise_management::SystemStatus::MergeFrom(
          from._internal_system_status());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_stateful_partition_info()->::enterprise_management::StatefulPartitionInfo::MergeFrom(
          from._internal_stateful_partition_info());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_graphics_status()->::enterprise_management::GraphicsStatus::MergeFrom(
          from._internal_graphics_status());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_timezone_info()->::enterprise_management::TimezoneInfo::MergeFrom(
          from._internal_timezone_info());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_memory_info()->::enterprise_management::MemoryInfo::MergeFrom(
          from._internal_memory_info());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_internal_mutable_global_cpu_info()->::enterprise_management::GlobalCpuInfo::MergeFrom(
          from._internal_global_cpu_info());
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_internal_mutable_smbios_info()->::enterprise_management::SmbiosInfo::MergeFrom(
          from._internal_smbios_info());
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_internal_mutable_kernel_parameters()->::enterprise_management::KernelParameters::MergeFrom(
          from._internal_kernel_parameters());
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_internal_mutable_efi_vars()->::enterprise_management::EFIVars::MergeFrom(
          from._internal_efi_vars());
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_internal_mutable_boot_info()->::enterprise_management::BootInfo::MergeFrom(
          from._internal_boot_info());
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.system_ram_total_ = from._impl_.system_ram_total_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.sound_volume_ = from._impl_.sound_volume_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.channel_ = from._impl_.channel_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x03000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.root_device_total_storage_bytes_ = from._impl_.root_device_total_storage_bytes_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.write_protect_switch_ = from._impl_.write_protect_switch_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceStatusReportRequest::CopyFrom(const DeviceStatusReportRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceStatusReportRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceStatusReportRequest::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.users_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.lacros_browser_report_))
    return false;
  return true;
}

void DeviceStatusReportRequest::InternalSwap(DeviceStatusReportRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.active_periods_.InternalSwap(&other->_impl_.active_periods_);
  _impl_.network_interfaces_.InternalSwap(&other->_impl_.network_interfaces_);
  _impl_.users_.InternalSwap(&other->_impl_.users_);
  _impl_.volume_infos_.InternalSwap(&other->_impl_.volume_infos_);
  _impl_.network_states_.InternalSwap(&other->_impl_.network_states_);
  _impl_.cpu_utilization_pct_samples_.InternalSwap(&other->_impl_.cpu_utilization_pct_samples_);
  _impl_.system_ram_free_samples_.InternalSwap(&other->_impl_.system_ram_free_samples_);
  _impl_.cpu_temp_infos_.InternalSwap(&other->_impl_.cpu_temp_infos_);
  _impl_.cpu_utilization_infos_.InternalSwap(&other->_impl_.cpu_utilization_infos_);
  _impl_.system_ram_free_infos_.InternalSwap(&other->_impl_.system_ram_free_infos_);
  _impl_.cpu_info_.InternalSwap(&other->_impl_.cpu_info_);
  _impl_.crash_report_infos_.InternalSwap(&other->_impl_.crash_report_infos_);
  _impl_.backlight_info_.InternalSwap(&other->_impl_.backlight_info_);
  _impl_.fan_info_.InternalSwap(&other->_impl_.fan_info_);
  _impl_.bluetooth_adapter_info_.InternalSwap(&other->_impl_.bluetooth_adapter_info_);
  _impl_.network_adapter_info_.InternalSwap(&other->_impl_.network_adapter_info_);
  _impl_.lacros_browser_report_.InternalSwap(&other->_impl_.lacros_browser_report_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.os_version_, lhs_arena,
      &other->_impl_.os_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.firmware_version_, lhs_arena,
      &other->_impl_.firmware_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.boot_mode_, lhs_arena,
      &other->_impl_.boot_mode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.browser_version_, lhs_arena,
      &other->_impl_.browser_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceStatusReportRequest, _impl_.write_protect_switch_)
      + sizeof(DeviceStatusReportRequest::_impl_.write_protect_switch_)
      - PROTOBUF_FIELD_OFFSET(DeviceStatusReportRequest, _impl_.os_update_status_)>(
          reinterpret_cast<char*>(&_impl_.os_update_status_),
          reinterpret_cast<char*>(&other->_impl_.os_update_status_));
}

std::string DeviceStatusReportRequest::GetTypeName() const {
  return "enterprise_management.DeviceStatusReportRequest";
}


// ===================================================================

class OsUpdateStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<OsUpdateStatus>()._impl_._has_bits_);
  static void set_has_update_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_new_platform_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_new_required_platform_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_last_checked_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_last_reboot_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

OsUpdateStatus::OsUpdateStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.OsUpdateStatus)
}
OsUpdateStatus::OsUpdateStatus(const OsUpdateStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OsUpdateStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_platform_version_){}
    , decltype(_impl_.new_required_platform_version_){}
    , decltype(_impl_.last_checked_timestamp_){}
    , decltype(_impl_.last_reboot_timestamp_){}
    , decltype(_impl_.update_status_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.new_platform_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_platform_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_new_platform_version()) {
    _this->_impl_.new_platform_version_.Set(from._internal_new_platform_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.new_required_platform_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_required_platform_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_new_required_platform_version()) {
    _this->_impl_.new_required_platform_version_.Set(from._internal_new_required_platform_version(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.last_checked_timestamp_, &from._impl_.last_checked_timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.update_status_) -
    reinterpret_cast<char*>(&_impl_.last_checked_timestamp_)) + sizeof(_impl_.update_status_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.OsUpdateStatus)
}

inline void OsUpdateStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_platform_version_){}
    , decltype(_impl_.new_required_platform_version_){}
    , decltype(_impl_.last_checked_timestamp_){int64_t{0}}
    , decltype(_impl_.last_reboot_timestamp_){int64_t{0}}
    , decltype(_impl_.update_status_){0}
  };
  _impl_.new_platform_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_platform_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.new_required_platform_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_required_platform_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OsUpdateStatus::~OsUpdateStatus() {
  // @@protoc_insertion_point(destructor:enterprise_management.OsUpdateStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OsUpdateStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.new_platform_version_.Destroy();
  _impl_.new_required_platform_version_.Destroy();
}

void OsUpdateStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OsUpdateStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.OsUpdateStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.new_platform_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.new_required_platform_version_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.last_checked_timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.update_status_) -
        reinterpret_cast<char*>(&_impl_.last_checked_timestamp_)) + sizeof(_impl_.update_status_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OsUpdateStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.OsUpdateStatus.UpdateStatus update_status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::OsUpdateStatus_UpdateStatus_IsValid(val))) {
            _internal_set_update_status(static_cast<::enterprise_management::OsUpdateStatus_UpdateStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string new_platform_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_new_platform_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string new_required_platform_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_new_required_platform_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 last_checked_timestamp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_last_checked_timestamp(&has_bits);
          _impl_.last_checked_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 last_reboot_timestamp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_last_reboot_timestamp(&has_bits);
          _impl_.last_reboot_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OsUpdateStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.OsUpdateStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.OsUpdateStatus.UpdateStatus update_status = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_update_status(), target);
  }

  // optional string new_platform_version = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_new_platform_version(), target);
  }

  // optional string new_required_platform_version = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_new_required_platform_version(), target);
  }

  // optional int64 last_checked_timestamp = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_last_checked_timestamp(), target);
  }

  // optional int64 last_reboot_timestamp = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_last_reboot_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.OsUpdateStatus)
  return target;
}

size_t OsUpdateStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.OsUpdateStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string new_platform_version = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_new_platform_version());
    }

    // optional string new_required_platform_version = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_new_required_platform_version());
    }

    // optional int64 last_checked_timestamp = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_checked_timestamp());
    }

    // optional int64 last_reboot_timestamp = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_reboot_timestamp());
    }

    // optional .enterprise_management.OsUpdateStatus.UpdateStatus update_status = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_update_status());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OsUpdateStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OsUpdateStatus*>(
      &from));
}

void OsUpdateStatus::MergeFrom(const OsUpdateStatus& from) {
  OsUpdateStatus* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.OsUpdateStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_new_platform_version(from._internal_new_platform_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_new_required_platform_version(from._internal_new_required_platform_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.last_checked_timestamp_ = from._impl_.last_checked_timestamp_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.last_reboot_timestamp_ = from._impl_.last_reboot_timestamp_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.update_status_ = from._impl_.update_status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OsUpdateStatus::CopyFrom(const OsUpdateStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.OsUpdateStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OsUpdateStatus::IsInitialized() const {
  return true;
}

void OsUpdateStatus::InternalSwap(OsUpdateStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_platform_version_, lhs_arena,
      &other->_impl_.new_platform_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_required_platform_version_, lhs_arena,
      &other->_impl_.new_required_platform_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OsUpdateStatus, _impl_.update_status_)
      + sizeof(OsUpdateStatus::_impl_.update_status_)
      - PROTOBUF_FIELD_OFFSET(OsUpdateStatus, _impl_.last_checked_timestamp_)>(
          reinterpret_cast<char*>(&_impl_.last_checked_timestamp_),
          reinterpret_cast<char*>(&other->_impl_.last_checked_timestamp_));
}

std::string OsUpdateStatus::GetTypeName() const {
  return "enterprise_management.OsUpdateStatus";
}


// ===================================================================

class AppStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<AppStatus>()._impl_._has_bits_);
  static void set_has_app_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_extension_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_required_platform_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

AppStatus::AppStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AppStatus)
}
AppStatus::AppStatus(const AppStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AppStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.app_id_){}
    , decltype(_impl_.extension_version_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.required_platform_version_){}
    , decltype(_impl_.error_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.app_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_app_id()) {
    _this->_impl_.app_id_.Set(from._internal_app_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.extension_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extension_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_extension_version()) {
    _this->_impl_.extension_version_.Set(from._internal_extension_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  _impl_.required_platform_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.required_platform_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_required_platform_version()) {
    _this->_impl_.required_platform_version_.Set(from._internal_required_platform_version(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.error_ = from._impl_.error_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AppStatus)
}

inline void AppStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.app_id_){}
    , decltype(_impl_.extension_version_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.required_platform_version_){}
    , decltype(_impl_.error_){false}
  };
  _impl_.app_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.extension_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extension_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.required_platform_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.required_platform_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AppStatus::~AppStatus() {
  // @@protoc_insertion_point(destructor:enterprise_management.AppStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AppStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.app_id_.Destroy();
  _impl_.extension_version_.Destroy();
  _impl_.status_.Destroy();
  _impl_.required_platform_version_.Destroy();
}

void AppStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AppStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AppStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.app_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.extension_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.status_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.required_platform_version_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.error_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AppStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string app_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_app_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string extension_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_extension_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_error(&has_bits);
          _impl_.error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string required_platform_version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_required_platform_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AppStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AppStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string app_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_app_id(), target);
  }

  // optional string extension_version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_extension_version(), target);
  }

  // optional string status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_status(), target);
  }

  // optional bool error = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_error(), target);
  }

  // optional string required_platform_version = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_required_platform_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AppStatus)
  return target;
}

size_t AppStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AppStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string app_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_app_id());
    }

    // optional string extension_version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_extension_version());
    }

    // optional string status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_status());
    }

    // optional string required_platform_version = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_required_platform_version());
    }

    // optional bool error = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AppStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AppStatus*>(
      &from));
}

void AppStatus::MergeFrom(const AppStatus& from) {
  AppStatus* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AppStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_app_id(from._internal_app_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_extension_version(from._internal_extension_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_status(from._internal_status());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_required_platform_version(from._internal_required_platform_version());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AppStatus::CopyFrom(const AppStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AppStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AppStatus::IsInitialized() const {
  return true;
}

void AppStatus::InternalSwap(AppStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.app_id_, lhs_arena,
      &other->_impl_.app_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.extension_version_, lhs_arena,
      &other->_impl_.extension_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.required_platform_version_, lhs_arena,
      &other->_impl_.required_platform_version_, rhs_arena
  );
  swap(_impl_.error_, other->_impl_.error_);
}

std::string AppStatus::GetTypeName() const {
  return "enterprise_management.AppStatus";
}


// ===================================================================

class AppInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<AppInfo>()._impl_._has_bits_);
  static void set_has_app_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_app_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_app_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_install_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

AppInfo::AppInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AppInfo)
}
AppInfo::AppInfo(const AppInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AppInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.active_time_periods_){from._impl_.active_time_periods_}
    , decltype(_impl_.app_id_){}
    , decltype(_impl_.app_name_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.app_type_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.install_time_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.app_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_app_id()) {
    _this->_impl_.app_id_.Set(from._internal_app_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.app_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_app_name()) {
    _this->_impl_.app_name_.Set(from._internal_app_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.app_type_, &from._impl_.app_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.install_time_) -
    reinterpret_cast<char*>(&_impl_.app_type_)) + sizeof(_impl_.install_time_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AppInfo)
}

inline void AppInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.active_time_periods_){arena}
    , decltype(_impl_.app_id_){}
    , decltype(_impl_.app_name_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.app_type_){0}
    , decltype(_impl_.status_){0}
    , decltype(_impl_.install_time_){int64_t{0}}
  };
  _impl_.app_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.app_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AppInfo::~AppInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.AppInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AppInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.active_time_periods_.~RepeatedPtrField();
  _impl_.app_id_.Destroy();
  _impl_.app_name_.Destroy();
  _impl_.version_.Destroy();
}

void AppInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AppInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AppInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.active_time_periods_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.app_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.app_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.version_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.app_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.install_time_) -
        reinterpret_cast<char*>(&_impl_.app_type_)) + sizeof(_impl_.install_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AppInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string app_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_app_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AppInfo.AppType app_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::AppInfo_AppType_IsValid(val))) {
            _internal_set_app_type(static_cast<::enterprise_management::AppInfo_AppType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string app_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_app_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AppInfo.Status status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::AppInfo_Status_IsValid(val))) {
            _internal_set_status(static_cast<::enterprise_management::AppInfo_Status>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 install_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_install_time(&has_bits);
          _impl_.install_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.TimePeriod active_time_periods = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_active_time_periods(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AppInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AppInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string app_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_app_id(), target);
  }

  // optional .enterprise_management.AppInfo.AppType app_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_app_type(), target);
  }

  // optional string app_name = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_app_name(), target);
  }

  // optional .enterprise_management.AppInfo.Status status = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_status(), target);
  }

  // optional int64 install_time = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_install_time(), target);
  }

  // optional string version = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_version(), target);
  }

  // repeated .enterprise_management.TimePeriod active_time_periods = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_active_time_periods_size()); i < n; i++) {
    const auto& repfield = this->_internal_active_time_periods(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AppInfo)
  return target;
}

size_t AppInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AppInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.TimePeriod active_time_periods = 8;
  total_size += 1UL * this->_internal_active_time_periods_size();
  for (const auto& msg : this->_impl_.active_time_periods_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string app_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_app_id());
    }

    // optional string app_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_app_name());
    }

    // optional string version = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional .enterprise_management.AppInfo.AppType app_type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_app_type());
    }

    // optional .enterprise_management.AppInfo.Status status = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

    // optional int64 install_time = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_install_time());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AppInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AppInfo*>(
      &from));
}

void AppInfo::MergeFrom(const AppInfo& from) {
  AppInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AppInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.active_time_periods_.MergeFrom(from._impl_.active_time_periods_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_app_id(from._internal_app_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_app_name(from._internal_app_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.app_type_ = from._impl_.app_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.install_time_ = from._impl_.install_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AppInfo::CopyFrom(const AppInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AppInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AppInfo::IsInitialized() const {
  return true;
}

void AppInfo::InternalSwap(AppInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.active_time_periods_.InternalSwap(&other->_impl_.active_time_periods_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.app_id_, lhs_arena,
      &other->_impl_.app_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.app_name_, lhs_arena,
      &other->_impl_.app_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AppInfo, _impl_.install_time_)
      + sizeof(AppInfo::_impl_.install_time_)
      - PROTOBUF_FIELD_OFFSET(AppInfo, _impl_.app_type_)>(
          reinterpret_cast<char*>(&_impl_.app_type_),
          reinterpret_cast<char*>(&other->_impl_.app_type_));
}

std::string AppInfo::GetTypeName() const {
  return "enterprise_management.AppInfo";
}


// ===================================================================

class AndroidAppPermission::_Internal {
 public:
  using HasBits = decltype(std::declval<AndroidAppPermission>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_granted(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_managed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

AndroidAppPermission::AndroidAppPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AndroidAppPermission)
}
AndroidAppPermission::AndroidAppPermission(const AndroidAppPermission& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AndroidAppPermission* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.granted_){}
    , decltype(_impl_.managed_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.granted_, &from._impl_.granted_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.managed_) -
    reinterpret_cast<char*>(&_impl_.granted_)) + sizeof(_impl_.managed_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AndroidAppPermission)
}

inline void AndroidAppPermission::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.granted_){false}
    , decltype(_impl_.managed_){false}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AndroidAppPermission::~AndroidAppPermission() {
  // @@protoc_insertion_point(destructor:enterprise_management.AndroidAppPermission)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AndroidAppPermission::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void AndroidAppPermission::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AndroidAppPermission::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AndroidAppPermission)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.granted_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.managed_) -
      reinterpret_cast<char*>(&_impl_.granted_)) + sizeof(_impl_.managed_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AndroidAppPermission::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool granted = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_granted(&has_bits);
          _impl_.granted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool managed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_managed(&has_bits);
          _impl_.managed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AndroidAppPermission::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AndroidAppPermission)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bool granted = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_granted(), target);
  }

  // optional bool managed = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_managed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AndroidAppPermission)
  return target;
}

size_t AndroidAppPermission::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AndroidAppPermission)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bool granted = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool managed = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AndroidAppPermission::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AndroidAppPermission*>(
      &from));
}

void AndroidAppPermission::MergeFrom(const AndroidAppPermission& from) {
  AndroidAppPermission* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AndroidAppPermission)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.granted_ = from._impl_.granted_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.managed_ = from._impl_.managed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AndroidAppPermission::CopyFrom(const AndroidAppPermission& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AndroidAppPermission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AndroidAppPermission::IsInitialized() const {
  return true;
}

void AndroidAppPermission::InternalSwap(AndroidAppPermission* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AndroidAppPermission, _impl_.managed_)
      + sizeof(AndroidAppPermission::_impl_.managed_)
      - PROTOBUF_FIELD_OFFSET(AndroidAppPermission, _impl_.granted_)>(
          reinterpret_cast<char*>(&_impl_.granted_),
          reinterpret_cast<char*>(&other->_impl_.granted_));
}

std::string AndroidAppPermission::GetTypeName() const {
  return "enterprise_management.AndroidAppPermission";
}


// ===================================================================

class AndroidAppInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<AndroidAppInfo>()._impl_._has_bits_);
  static void set_has_app_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_app_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_package_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_installed_source(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

AndroidAppInfo::AndroidAppInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AndroidAppInfo)
}
AndroidAppInfo::AndroidAppInfo(const AndroidAppInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AndroidAppInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.permissions_){from._impl_.permissions_}
    , decltype(_impl_.app_id_){}
    , decltype(_impl_.app_name_){}
    , decltype(_impl_.package_name_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.installed_source_){}
    , decltype(_impl_.version_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.app_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_app_id()) {
    _this->_impl_.app_id_.Set(from._internal_app_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.app_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_app_name()) {
    _this->_impl_.app_name_.Set(from._internal_app_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.package_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.package_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_package_name()) {
    _this->_impl_.package_name_.Set(from._internal_package_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.status_, &from._impl_.status_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.version_) -
    reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.version_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AndroidAppInfo)
}

inline void AndroidAppInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.permissions_){arena}
    , decltype(_impl_.app_id_){}
    , decltype(_impl_.app_name_){}
    , decltype(_impl_.package_name_){}
    , decltype(_impl_.status_){0}
    , decltype(_impl_.installed_source_){0}
    , decltype(_impl_.version_){0}
  };
  _impl_.app_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.app_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.package_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.package_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AndroidAppInfo::~AndroidAppInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.AndroidAppInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AndroidAppInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.permissions_.~RepeatedPtrField();
  _impl_.app_id_.Destroy();
  _impl_.app_name_.Destroy();
  _impl_.package_name_.Destroy();
}

void AndroidAppInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AndroidAppInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AndroidAppInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.permissions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.app_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.app_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.package_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.status_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.version_) -
        reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AndroidAppInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string app_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_app_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string app_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_app_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string package_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_package_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AndroidAppInfo.AndroidAppStatus status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::AndroidAppInfo_AndroidAppStatus_IsValid(val))) {
            _internal_set_status(static_cast<::enterprise_management::AndroidAppInfo_AndroidAppStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AndroidAppInfo.InstalledSource installed_source = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::AndroidAppInfo_InstalledSource_IsValid(val))) {
            _internal_set_installed_source(static_cast<::enterprise_management::AndroidAppInfo_InstalledSource>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.AndroidAppPermission permissions = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_permissions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AndroidAppInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AndroidAppInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string app_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_app_id(), target);
  }

  // optional string app_name = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_app_name(), target);
  }

  // optional string package_name = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_package_name(), target);
  }

  // optional .enterprise_management.AndroidAppInfo.AndroidAppStatus status = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_status(), target);
  }

  // optional .enterprise_management.AndroidAppInfo.InstalledSource installed_source = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_installed_source(), target);
  }

  // optional int32 version = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_version(), target);
  }

  // repeated .enterprise_management.AndroidAppPermission permissions = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_permissions_size()); i < n; i++) {
    const auto& repfield = this->_internal_permissions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AndroidAppInfo)
  return target;
}

size_t AndroidAppInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AndroidAppInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.AndroidAppPermission permissions = 7;
  total_size += 1UL * this->_internal_permissions_size();
  for (const auto& msg : this->_impl_.permissions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string app_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_app_id());
    }

    // optional string app_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_app_name());
    }

    // optional string package_name = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_package_name());
    }

    // optional .enterprise_management.AndroidAppInfo.AndroidAppStatus status = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

    // optional .enterprise_management.AndroidAppInfo.InstalledSource installed_source = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_installed_source());
    }

    // optional int32 version = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AndroidAppInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AndroidAppInfo*>(
      &from));
}

void AndroidAppInfo::MergeFrom(const AndroidAppInfo& from) {
  AndroidAppInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AndroidAppInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.permissions_.MergeFrom(from._impl_.permissions_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_app_id(from._internal_app_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_app_name(from._internal_app_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_package_name(from._internal_package_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.installed_source_ = from._impl_.installed_source_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AndroidAppInfo::CopyFrom(const AndroidAppInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AndroidAppInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AndroidAppInfo::IsInitialized() const {
  return true;
}

void AndroidAppInfo::InternalSwap(AndroidAppInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.permissions_.InternalSwap(&other->_impl_.permissions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.app_id_, lhs_arena,
      &other->_impl_.app_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.app_name_, lhs_arena,
      &other->_impl_.app_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.package_name_, lhs_arena,
      &other->_impl_.package_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AndroidAppInfo, _impl_.version_)
      + sizeof(AndroidAppInfo::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(AndroidAppInfo, _impl_.status_)>(
          reinterpret_cast<char*>(&_impl_.status_),
          reinterpret_cast<char*>(&other->_impl_.status_));
}

std::string AndroidAppInfo::GetTypeName() const {
  return "enterprise_management.AndroidAppInfo";
}


// ===================================================================

class ChromeUserProfileReport::_Internal {
 public:
  using HasBits = decltype(std::declval<ChromeUserProfileReport>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_chrome_signed_in_user(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_extension_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_plugins(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_policy_data(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_policy_fetched_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_safe_browsing_warnings(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_safe_browsing_warnings_click_through(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

ChromeUserProfileReport::ChromeUserProfileReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ChromeUserProfileReport)
}
ChromeUserProfileReport::ChromeUserProfileReport(const ChromeUserProfileReport& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ChromeUserProfileReport* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.extension_requests_){from._impl_.extension_requests_}
    , decltype(_impl_.id_){}
    , decltype(_impl_.chrome_signed_in_user_){}
    , decltype(_impl_.extension_data_){}
    , decltype(_impl_.plugins_){}
    , decltype(_impl_.policy_data_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.policy_fetched_timestamp_){}
    , decltype(_impl_.safe_browsing_warnings_){}
    , decltype(_impl_.safe_browsing_warnings_click_through_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.chrome_signed_in_user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chrome_signed_in_user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chrome_signed_in_user()) {
    _this->_impl_.chrome_signed_in_user_.Set(from._internal_chrome_signed_in_user(), 
      _this->GetArenaForAllocation());
  }
  _impl_.extension_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extension_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_extension_data()) {
    _this->_impl_.extension_data_.Set(from._internal_extension_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.plugins_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.plugins_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_plugins()) {
    _this->_impl_.plugins_.Set(from._internal_plugins(), 
      _this->GetArenaForAllocation());
  }
  _impl_.policy_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_policy_data()) {
    _this->_impl_.policy_data_.Set(from._internal_policy_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.policy_fetched_timestamp_, &from._impl_.policy_fetched_timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.safe_browsing_warnings_click_through_) -
    reinterpret_cast<char*>(&_impl_.policy_fetched_timestamp_)) + sizeof(_impl_.safe_browsing_warnings_click_through_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ChromeUserProfileReport)
}

inline void ChromeUserProfileReport::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.extension_requests_){arena}
    , decltype(_impl_.id_){}
    , decltype(_impl_.chrome_signed_in_user_){}
    , decltype(_impl_.extension_data_){}
    , decltype(_impl_.plugins_){}
    , decltype(_impl_.policy_data_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.policy_fetched_timestamp_){int64_t{0}}
    , decltype(_impl_.safe_browsing_warnings_){uint64_t{0u}}
    , decltype(_impl_.safe_browsing_warnings_click_through_){uint64_t{0u}}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.chrome_signed_in_user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chrome_signed_in_user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.extension_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extension_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.plugins_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.plugins_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.policy_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChromeUserProfileReport::~ChromeUserProfileReport() {
  // @@protoc_insertion_point(destructor:enterprise_management.ChromeUserProfileReport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChromeUserProfileReport::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.extension_requests_.~RepeatedPtrField();
  _impl_.id_.Destroy();
  _impl_.chrome_signed_in_user_.Destroy();
  _impl_.extension_data_.Destroy();
  _impl_.plugins_.Destroy();
  _impl_.policy_data_.Destroy();
  _impl_.name_.Destroy();
}

void ChromeUserProfileReport::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChromeUserProfileReport::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ChromeUserProfileReport)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_requests_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.chrome_signed_in_user_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.extension_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.plugins_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.policy_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.policy_fetched_timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.safe_browsing_warnings_) -
        reinterpret_cast<char*>(&_impl_.policy_fetched_timestamp_)) + sizeof(_impl_.safe_browsing_warnings_));
  }
  _impl_.safe_browsing_warnings_click_through_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChromeUserProfileReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string chrome_signed_in_user = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_chrome_signed_in_user();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string extension_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_extension_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string plugins = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_plugins();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string policy_data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_policy_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 policy_fetched_timestamp = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_policy_fetched_timestamp(&has_bits);
          _impl_.policy_fetched_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 safe_browsing_warnings = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_safe_browsing_warnings(&has_bits);
          _impl_.safe_browsing_warnings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 safe_browsing_warnings_click_through = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_safe_browsing_warnings_click_through(&has_bits);
          _impl_.safe_browsing_warnings_click_through_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.ExtensionRequest extension_requests = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_extension_requests(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChromeUserProfileReport::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ChromeUserProfileReport)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional string chrome_signed_in_user = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_chrome_signed_in_user(), target);
  }

  // optional string extension_data = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_extension_data(), target);
  }

  // optional string plugins = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_plugins(), target);
  }

  // optional string policy_data = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_policy_data(), target);
  }

  // optional int64 policy_fetched_timestamp = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_policy_fetched_timestamp(), target);
  }

  // optional uint64 safe_browsing_warnings = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_safe_browsing_warnings(), target);
  }

  // optional uint64 safe_browsing_warnings_click_through = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_safe_browsing_warnings_click_through(), target);
  }

  // optional string name = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_name(), target);
  }

  // repeated .enterprise_management.ExtensionRequest extension_requests = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_requests_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension_requests(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ChromeUserProfileReport)
  return target;
}

size_t ChromeUserProfileReport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ChromeUserProfileReport)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.ExtensionRequest extension_requests = 10;
  total_size += 1UL * this->_internal_extension_requests_size();
  for (const auto& msg : this->_impl_.extension_requests_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id());
    }

    // optional string chrome_signed_in_user = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_chrome_signed_in_user());
    }

    // optional string extension_data = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_extension_data());
    }

    // optional string plugins = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_plugins());
    }

    // optional string policy_data = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_policy_data());
    }

    // optional string name = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int64 policy_fetched_timestamp = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_policy_fetched_timestamp());
    }

    // optional uint64 safe_browsing_warnings = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_safe_browsing_warnings());
    }

  }
  // optional uint64 safe_browsing_warnings_click_through = 8;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_safe_browsing_warnings_click_through());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChromeUserProfileReport::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChromeUserProfileReport*>(
      &from));
}

void ChromeUserProfileReport::MergeFrom(const ChromeUserProfileReport& from) {
  ChromeUserProfileReport* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ChromeUserProfileReport)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.extension_requests_.MergeFrom(from._impl_.extension_requests_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_chrome_signed_in_user(from._internal_chrome_signed_in_user());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_extension_data(from._internal_extension_data());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_plugins(from._internal_plugins());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_policy_data(from._internal_policy_data());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.policy_fetched_timestamp_ = from._impl_.policy_fetched_timestamp_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.safe_browsing_warnings_ = from._impl_.safe_browsing_warnings_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_safe_browsing_warnings_click_through(from._internal_safe_browsing_warnings_click_through());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromeUserProfileReport::CopyFrom(const ChromeUserProfileReport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ChromeUserProfileReport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChromeUserProfileReport::IsInitialized() const {
  return true;
}

void ChromeUserProfileReport::InternalSwap(ChromeUserProfileReport* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extension_requests_.InternalSwap(&other->_impl_.extension_requests_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.chrome_signed_in_user_, lhs_arena,
      &other->_impl_.chrome_signed_in_user_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.extension_data_, lhs_arena,
      &other->_impl_.extension_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.plugins_, lhs_arena,
      &other->_impl_.plugins_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.policy_data_, lhs_arena,
      &other->_impl_.policy_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChromeUserProfileReport, _impl_.safe_browsing_warnings_click_through_)
      + sizeof(ChromeUserProfileReport::_impl_.safe_browsing_warnings_click_through_)
      - PROTOBUF_FIELD_OFFSET(ChromeUserProfileReport, _impl_.policy_fetched_timestamp_)>(
          reinterpret_cast<char*>(&_impl_.policy_fetched_timestamp_),
          reinterpret_cast<char*>(&other->_impl_.policy_fetched_timestamp_));
}

std::string ChromeUserProfileReport::GetTypeName() const {
  return "enterprise_management.ChromeUserProfileReport";
}


// ===================================================================

class ChromeSignedInUser::_Internal {
 public:
  using HasBits = decltype(std::declval<ChromeSignedInUser>()._impl_._has_bits_);
  static void set_has_email(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_obfuscated_gaia_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ChromeSignedInUser::ChromeSignedInUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ChromeSignedInUser)
}
ChromeSignedInUser::ChromeSignedInUser(const ChromeSignedInUser& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ChromeSignedInUser* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.email_){}
    , decltype(_impl_.obfuscated_gaia_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_email()) {
    _this->_impl_.email_.Set(from._internal_email(), 
      _this->GetArenaForAllocation());
  }
  _impl_.obfuscated_gaia_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obfuscated_gaia_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_obfuscated_gaia_id()) {
    _this->_impl_.obfuscated_gaia_id_.Set(from._internal_obfuscated_gaia_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ChromeSignedInUser)
}

inline void ChromeSignedInUser::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.email_){}
    , decltype(_impl_.obfuscated_gaia_id_){}
  };
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.obfuscated_gaia_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obfuscated_gaia_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChromeSignedInUser::~ChromeSignedInUser() {
  // @@protoc_insertion_point(destructor:enterprise_management.ChromeSignedInUser)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChromeSignedInUser::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.email_.Destroy();
  _impl_.obfuscated_gaia_id_.Destroy();
}

void ChromeSignedInUser::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChromeSignedInUser::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ChromeSignedInUser)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.email_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.obfuscated_gaia_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChromeSignedInUser::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string email = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_email();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string obfuscated_gaia_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_obfuscated_gaia_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChromeSignedInUser::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ChromeSignedInUser)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string email = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_email(), target);
  }

  // optional string obfuscated_gaia_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_obfuscated_gaia_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ChromeSignedInUser)
  return target;
}

size_t ChromeSignedInUser::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ChromeSignedInUser)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string email = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_email());
    }

    // optional string obfuscated_gaia_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_obfuscated_gaia_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChromeSignedInUser::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChromeSignedInUser*>(
      &from));
}

void ChromeSignedInUser::MergeFrom(const ChromeSignedInUser& from) {
  ChromeSignedInUser* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ChromeSignedInUser)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_email(from._internal_email());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_obfuscated_gaia_id(from._internal_obfuscated_gaia_id());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromeSignedInUser::CopyFrom(const ChromeSignedInUser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ChromeSignedInUser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChromeSignedInUser::IsInitialized() const {
  return true;
}

void ChromeSignedInUser::InternalSwap(ChromeSignedInUser* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.email_, lhs_arena,
      &other->_impl_.email_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.obfuscated_gaia_id_, lhs_arena,
      &other->_impl_.obfuscated_gaia_id_, rhs_arena
  );
}

std::string ChromeSignedInUser::GetTypeName() const {
  return "enterprise_management.ChromeSignedInUser";
}


// ===================================================================

class ExtensionRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ExtensionRequest>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_justification(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ExtensionRequest::ExtensionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ExtensionRequest)
}
ExtensionRequest::ExtensionRequest(const ExtensionRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ExtensionRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.justification_){}
    , decltype(_impl_.request_timestamp_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.justification_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.justification_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_justification()) {
    _this->_impl_.justification_.Set(from._internal_justification(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.request_timestamp_ = from._impl_.request_timestamp_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ExtensionRequest)
}

inline void ExtensionRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.justification_){}
    , decltype(_impl_.request_timestamp_){int64_t{0}}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.justification_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.justification_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExtensionRequest::~ExtensionRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.ExtensionRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExtensionRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  _impl_.justification_.Destroy();
}

void ExtensionRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExtensionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ExtensionRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.justification_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.request_timestamp_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ExtensionRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 request_timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_request_timestamp(&has_bits);
          _impl_.request_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string justification = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_justification();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExtensionRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ExtensionRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional int64 request_timestamp = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_request_timestamp(), target);
  }

  // optional string justification = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_justification(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ExtensionRequest)
  return target;
}

size_t ExtensionRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ExtensionRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id());
    }

    // optional string justification = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_justification());
    }

    // optional int64 request_timestamp = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_request_timestamp());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExtensionRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ExtensionRequest*>(
      &from));
}

void ExtensionRequest::MergeFrom(const ExtensionRequest& from) {
  ExtensionRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ExtensionRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_justification(from._internal_justification());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.request_timestamp_ = from._impl_.request_timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionRequest::CopyFrom(const ExtensionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ExtensionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExtensionRequest::IsInitialized() const {
  return true;
}

void ExtensionRequest::InternalSwap(ExtensionRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.justification_, lhs_arena,
      &other->_impl_.justification_, rhs_arena
  );
  swap(_impl_.request_timestamp_, other->_impl_.request_timestamp_);
}

std::string ExtensionRequest::GetTypeName() const {
  return "enterprise_management.ExtensionRequest";
}


// ===================================================================

class Extension::_Internal {
 public:
  using HasBits = decltype(std::declval<Extension>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_app_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_homepage_url(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_install_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_from_webstore(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_manifest_version(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Extension::Extension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.Extension)
}
Extension::Extension(const Extension& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Extension* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.permissions_){from._impl_.permissions_}
    , decltype(_impl_.host_permissions_){from._impl_.host_permissions_}
    , decltype(_impl_.id_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.homepage_url_){}
    , decltype(_impl_.app_type_){}
    , decltype(_impl_.install_type_){}
    , decltype(_impl_.enabled_){}
    , decltype(_impl_.from_webstore_){}
    , decltype(_impl_.manifest_version_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.homepage_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.homepage_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_homepage_url()) {
    _this->_impl_.homepage_url_.Set(from._internal_homepage_url(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.app_type_, &from._impl_.app_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.manifest_version_) -
    reinterpret_cast<char*>(&_impl_.app_type_)) + sizeof(_impl_.manifest_version_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.Extension)
}

inline void Extension::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.permissions_){arena}
    , decltype(_impl_.host_permissions_){arena}
    , decltype(_impl_.id_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.homepage_url_){}
    , decltype(_impl_.app_type_){0}
    , decltype(_impl_.install_type_){0}
    , decltype(_impl_.enabled_){false}
    , decltype(_impl_.from_webstore_){false}
    , decltype(_impl_.manifest_version_){0}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.homepage_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.homepage_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Extension::~Extension() {
  // @@protoc_insertion_point(destructor:enterprise_management.Extension)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Extension::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.permissions_.~RepeatedPtrField();
  _impl_.host_permissions_.~RepeatedPtrField();
  _impl_.id_.Destroy();
  _impl_.version_.Destroy();
  _impl_.name_.Destroy();
  _impl_.description_.Destroy();
  _impl_.homepage_url_.Destroy();
}

void Extension::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Extension::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.Extension)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.permissions_.Clear();
  _impl_.host_permissions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.homepage_url_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.app_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.enabled_) -
        reinterpret_cast<char*>(&_impl_.app_type_)) + sizeof(_impl_.enabled_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.from_webstore_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.manifest_version_) -
        reinterpret_cast<char*>(&_impl_.from_webstore_)) + sizeof(_impl_.manifest_version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Extension::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.Extension.ExtensionType app_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::Extension_ExtensionType_IsValid(val))) {
            _internal_set_app_type(static_cast<::enterprise_management::Extension_ExtensionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string homepage_url = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_homepage_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.Extension.InstallType install_type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::Extension_InstallType_IsValid(val))) {
            _internal_set_install_type(static_cast<::enterprise_management::Extension_InstallType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool enabled = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string permissions = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_permissions();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string host_permissions = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_host_permissions();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool from_webstore = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_from_webstore(&has_bits);
          _impl_.from_webstore_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 manifest_version = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_manifest_version(&has_bits);
          _impl_.manifest_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Extension::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.Extension)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional string version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_version(), target);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional string description = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_description(), target);
  }

  // optional .enterprise_management.Extension.ExtensionType app_type = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_app_type(), target);
  }

  // optional string homepage_url = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_homepage_url(), target);
  }

  // optional .enterprise_management.Extension.InstallType install_type = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_install_type(), target);
  }

  // optional bool enabled = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_enabled(), target);
  }

  // repeated string permissions = 10;
  for (int i = 0, n = this->_internal_permissions_size(); i < n; i++) {
    const auto& s = this->_internal_permissions(i);
    target = stream->WriteString(10, s, target);
  }

  // repeated string host_permissions = 11;
  for (int i = 0, n = this->_internal_host_permissions_size(); i < n; i++) {
    const auto& s = this->_internal_host_permissions(i);
    target = stream->WriteString(11, s, target);
  }

  // optional bool from_webstore = 13;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_from_webstore(), target);
  }

  // optional int32 manifest_version = 14;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_manifest_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.Extension)
  return target;
}

size_t Extension::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.Extension)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string permissions = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.permissions_.size());
  for (int i = 0, n = _impl_.permissions_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.permissions_.Get(i));
  }

  // repeated string host_permissions = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.host_permissions_.size());
  for (int i = 0, n = _impl_.host_permissions_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.host_permissions_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id());
    }

    // optional string version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional string name = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string description = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional string homepage_url = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_homepage_url());
    }

    // optional .enterprise_management.Extension.ExtensionType app_type = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_app_type());
    }

    // optional .enterprise_management.Extension.InstallType install_type = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_install_type());
    }

    // optional bool enabled = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool from_webstore = 13;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional int32 manifest_version = 14;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_manifest_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Extension::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Extension*>(
      &from));
}

void Extension::MergeFrom(const Extension& from) {
  Extension* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.Extension)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.permissions_.MergeFrom(from._impl_.permissions_);
  _this->_impl_.host_permissions_.MergeFrom(from._impl_.host_permissions_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_homepage_url(from._internal_homepage_url());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.app_type_ = from._impl_.app_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.install_type_ = from._impl_.install_type_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.enabled_ = from._impl_.enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.from_webstore_ = from._impl_.from_webstore_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.manifest_version_ = from._impl_.manifest_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Extension::CopyFrom(const Extension& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.Extension)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Extension::IsInitialized() const {
  return true;
}

void Extension::InternalSwap(Extension* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.permissions_.InternalSwap(&other->_impl_.permissions_);
  _impl_.host_permissions_.InternalSwap(&other->_impl_.host_permissions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.homepage_url_, lhs_arena,
      &other->_impl_.homepage_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Extension, _impl_.manifest_version_)
      + sizeof(Extension::_impl_.manifest_version_)
      - PROTOBUF_FIELD_OFFSET(Extension, _impl_.app_type_)>(
          reinterpret_cast<char*>(&_impl_.app_type_),
          reinterpret_cast<char*>(&other->_impl_.app_type_));
}

std::string Extension::GetTypeName() const {
  return "enterprise_management.Extension";
}


// ===================================================================

class Plugin::_Internal {
 public:
  using HasBits = decltype(std::declval<Plugin>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Plugin::Plugin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.Plugin)
}
Plugin::Plugin(const Plugin& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Plugin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.description_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    _this->_impl_.filename_.Set(from._internal_filename(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.Plugin)
}

inline void Plugin::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.description_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Plugin::~Plugin() {
  // @@protoc_insertion_point(destructor:enterprise_management.Plugin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Plugin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.version_.Destroy();
  _impl_.filename_.Destroy();
  _impl_.description_.Destroy();
}

void Plugin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Plugin::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.Plugin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.filename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.description_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Plugin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string filename = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Plugin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.Plugin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_version(), target);
  }

  // optional string filename = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_filename(), target);
  }

  // optional string description = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.Plugin)
  return target;
}

size_t Plugin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.Plugin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional string filename = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filename());
    }

    // optional string description = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Plugin::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Plugin*>(
      &from));
}

void Plugin::MergeFrom(const Plugin& from) {
  Plugin* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.Plugin)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_description(from._internal_description());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Plugin::CopyFrom(const Plugin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.Plugin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Plugin::IsInitialized() const {
  return true;
}

void Plugin::InternalSwap(Plugin* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filename_, lhs_arena,
      &other->_impl_.filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
}

std::string Plugin::GetTypeName() const {
  return "enterprise_management.Plugin";
}


// ===================================================================

class Policy::_Internal {
 public:
  using HasBits = decltype(std::declval<Policy>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_scope(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Policy::Policy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.Policy)
}
Policy::Policy(const Policy& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Policy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.scope_){}
    , decltype(_impl_.source_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error()) {
    _this->_impl_.error_.Set(from._internal_error(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.level_, &from._impl_.level_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.source_) -
    reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.source_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.Policy)
}

inline void Policy::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.level_){0}
    , decltype(_impl_.scope_){0}
    , decltype(_impl_.source_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Policy::~Policy() {
  // @@protoc_insertion_point(destructor:enterprise_management.Policy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Policy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
  _impl_.error_.Destroy();
}

void Policy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Policy::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.Policy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.error_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.level_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.source_) -
        reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.source_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Policy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.Policy.PolicyLevel level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::Policy_PolicyLevel_IsValid(val))) {
            _internal_set_level(static_cast<::enterprise_management::Policy_PolicyLevel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.Policy.PolicyScope scope = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::Policy_PolicyScope_IsValid(val))) {
            _internal_set_scope(static_cast<::enterprise_management::Policy_PolicyScope>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.Policy.PolicySource source = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::Policy_PolicySource_IsValid(val))) {
            _internal_set_source(static_cast<::enterprise_management::Policy_PolicySource>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string error = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_error();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Policy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.Policy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional .enterprise_management.Policy.PolicyLevel level = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_level(), target);
  }

  // optional .enterprise_management.Policy.PolicyScope scope = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_scope(), target);
  }

  // optional .enterprise_management.Policy.PolicySource source = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_source(), target);
  }

  // optional string value = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_value(), target);
  }

  // optional string error = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.Policy)
  return target;
}

size_t Policy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.Policy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string value = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

    // optional string error = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error());
    }

    // optional .enterprise_management.Policy.PolicyLevel level = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
    }

    // optional .enterprise_management.Policy.PolicyScope scope = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_scope());
    }

    // optional .enterprise_management.Policy.PolicySource source = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_source());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Policy::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Policy*>(
      &from));
}

void Policy::MergeFrom(const Policy& from) {
  Policy* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.Policy)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_error(from._internal_error());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.scope_ = from._impl_.scope_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.source_ = from._impl_.source_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Policy::CopyFrom(const Policy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.Policy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Policy::IsInitialized() const {
  return true;
}

void Policy::InternalSwap(Policy* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_, lhs_arena,
      &other->_impl_.error_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Policy, _impl_.source_)
      + sizeof(Policy::_impl_.source_)
      - PROTOBUF_FIELD_OFFSET(Policy, _impl_.level_)>(
          reinterpret_cast<char*>(&_impl_.level_),
          reinterpret_cast<char*>(&other->_impl_.level_));
}

std::string Policy::GetTypeName() const {
  return "enterprise_management.Policy";
}


// ===================================================================

class ExtensionPolicy::_Internal {
 public:
  using HasBits = decltype(std::declval<ExtensionPolicy>()._impl_._has_bits_);
  static void set_has_extension_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ExtensionPolicy::ExtensionPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ExtensionPolicy)
}
ExtensionPolicy::ExtensionPolicy(const ExtensionPolicy& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ExtensionPolicy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.policies_){from._impl_.policies_}
    , decltype(_impl_.extension_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.extension_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extension_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_extension_id()) {
    _this->_impl_.extension_id_.Set(from._internal_extension_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ExtensionPolicy)
}

inline void ExtensionPolicy::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.policies_){arena}
    , decltype(_impl_.extension_id_){}
  };
  _impl_.extension_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extension_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExtensionPolicy::~ExtensionPolicy() {
  // @@protoc_insertion_point(destructor:enterprise_management.ExtensionPolicy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExtensionPolicy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.policies_.~RepeatedPtrField();
  _impl_.extension_id_.Destroy();
}

void ExtensionPolicy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExtensionPolicy::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ExtensionPolicy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.policies_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.extension_id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ExtensionPolicy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string extension_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_extension_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.Policy policies = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_policies(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExtensionPolicy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ExtensionPolicy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string extension_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_extension_id(), target);
  }

  // repeated .enterprise_management.Policy policies = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_policies_size()); i < n; i++) {
    const auto& repfield = this->_internal_policies(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ExtensionPolicy)
  return target;
}

size_t ExtensionPolicy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ExtensionPolicy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.Policy policies = 2;
  total_size += 1UL * this->_internal_policies_size();
  for (const auto& msg : this->_impl_.policies_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string extension_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_extension_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExtensionPolicy::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ExtensionPolicy*>(
      &from));
}

void ExtensionPolicy::MergeFrom(const ExtensionPolicy& from) {
  ExtensionPolicy* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ExtensionPolicy)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.policies_.MergeFrom(from._impl_.policies_);
  if (from._internal_has_extension_id()) {
    _this->_internal_set_extension_id(from._internal_extension_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionPolicy::CopyFrom(const ExtensionPolicy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ExtensionPolicy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExtensionPolicy::IsInitialized() const {
  return true;
}

void ExtensionPolicy::InternalSwap(ExtensionPolicy* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.policies_.InternalSwap(&other->_impl_.policies_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.extension_id_, lhs_arena,
      &other->_impl_.extension_id_, rhs_arena
  );
}

std::string ExtensionPolicy::GetTypeName() const {
  return "enterprise_management.ExtensionPolicy";
}


// ===================================================================

class PolicyFetchTimestamp::_Internal {
 public:
  using HasBits = decltype(std::declval<PolicyFetchTimestamp>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PolicyFetchTimestamp::PolicyFetchTimestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PolicyFetchTimestamp)
}
PolicyFetchTimestamp::PolicyFetchTimestamp(const PolicyFetchTimestamp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PolicyFetchTimestamp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.timestamp_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.timestamp_ = from._impl_.timestamp_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PolicyFetchTimestamp)
}

inline void PolicyFetchTimestamp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.timestamp_){int64_t{0}}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PolicyFetchTimestamp::~PolicyFetchTimestamp() {
  // @@protoc_insertion_point(destructor:enterprise_management.PolicyFetchTimestamp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PolicyFetchTimestamp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.type_.Destroy();
}

void PolicyFetchTimestamp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PolicyFetchTimestamp::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PolicyFetchTimestamp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.type_.ClearNonDefaultToEmpty();
  }
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PolicyFetchTimestamp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PolicyFetchTimestamp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PolicyFetchTimestamp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type(), target);
  }

  // optional int64 timestamp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PolicyFetchTimestamp)
  return target;
}

size_t PolicyFetchTimestamp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PolicyFetchTimestamp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

    // optional int64 timestamp = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PolicyFetchTimestamp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PolicyFetchTimestamp*>(
      &from));
}

void PolicyFetchTimestamp::MergeFrom(const PolicyFetchTimestamp& from) {
  PolicyFetchTimestamp* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PolicyFetchTimestamp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PolicyFetchTimestamp::CopyFrom(const PolicyFetchTimestamp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PolicyFetchTimestamp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PolicyFetchTimestamp::IsInitialized() const {
  return true;
}

void PolicyFetchTimestamp::InternalSwap(PolicyFetchTimestamp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  swap(_impl_.timestamp_, other->_impl_.timestamp_);
}

std::string PolicyFetchTimestamp::GetTypeName() const {
  return "enterprise_management.PolicyFetchTimestamp";
}


// ===================================================================

class ChromeUserProfileInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ChromeUserProfileInfo>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_detail_available(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::enterprise_management::ChromeSignedInUser& chrome_signed_in_user(const ChromeUserProfileInfo* msg);
  static void set_has_chrome_signed_in_user(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::enterprise_management::ChromeSignedInUser&
ChromeUserProfileInfo::_Internal::chrome_signed_in_user(const ChromeUserProfileInfo* msg) {
  return *msg->_impl_.chrome_signed_in_user_;
}
ChromeUserProfileInfo::ChromeUserProfileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ChromeUserProfileInfo)
}
ChromeUserProfileInfo::ChromeUserProfileInfo(const ChromeUserProfileInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ChromeUserProfileInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.extensions_){from._impl_.extensions_}
    , decltype(_impl_.chrome_policies_){from._impl_.chrome_policies_}
    , decltype(_impl_.extension_policies_){from._impl_.extension_policies_}
    , decltype(_impl_.policy_fetched_timestamps_){from._impl_.policy_fetched_timestamps_}
    , decltype(_impl_.extension_requests_){from._impl_.extension_requests_}
    , decltype(_impl_.id_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.chrome_signed_in_user_){nullptr}
    , decltype(_impl_.is_detail_available_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_chrome_signed_in_user()) {
    _this->_impl_.chrome_signed_in_user_ = new ::enterprise_management::ChromeSignedInUser(*from._impl_.chrome_signed_in_user_);
  }
  _this->_impl_.is_detail_available_ = from._impl_.is_detail_available_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ChromeUserProfileInfo)
}

inline void ChromeUserProfileInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.extensions_){arena}
    , decltype(_impl_.chrome_policies_){arena}
    , decltype(_impl_.extension_policies_){arena}
    , decltype(_impl_.policy_fetched_timestamps_){arena}
    , decltype(_impl_.extension_requests_){arena}
    , decltype(_impl_.id_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.chrome_signed_in_user_){nullptr}
    , decltype(_impl_.is_detail_available_){false}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChromeUserProfileInfo::~ChromeUserProfileInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.ChromeUserProfileInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChromeUserProfileInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.extensions_.~RepeatedPtrField();
  _impl_.chrome_policies_.~RepeatedPtrField();
  _impl_.extension_policies_.~RepeatedPtrField();
  _impl_.policy_fetched_timestamps_.~RepeatedPtrField();
  _impl_.extension_requests_.~RepeatedPtrField();
  _impl_.id_.Destroy();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.chrome_signed_in_user_;
}

void ChromeUserProfileInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChromeUserProfileInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ChromeUserProfileInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extensions_.Clear();
  _impl_.chrome_policies_.Clear();
  _impl_.extension_policies_.Clear();
  _impl_.policy_fetched_timestamps_.Clear();
  _impl_.extension_requests_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.chrome_signed_in_user_ != nullptr);
      _impl_.chrome_signed_in_user_->Clear();
    }
  }
  _impl_.is_detail_available_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChromeUserProfileInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_detail_available = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_detail_available(&has_bits);
          _impl_.is_detail_available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ChromeSignedInUser chrome_signed_in_user = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_chrome_signed_in_user(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.Extension extensions = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_extensions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.Policy chrome_policies = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_chrome_policies(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.ExtensionPolicy extension_policies = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_extension_policies(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.PolicyFetchTimestamp policy_fetched_timestamps = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_policy_fetched_timestamps(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.ExtensionRequest extension_requests = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_extension_requests(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChromeUserProfileInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ChromeUserProfileInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional bool is_detail_available = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_detail_available(), target);
  }

  // optional .enterprise_management.ChromeSignedInUser chrome_signed_in_user = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::chrome_signed_in_user(this),
        _Internal::chrome_signed_in_user(this).GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.Extension extensions = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extensions_size()); i < n; i++) {
    const auto& repfield = this->_internal_extensions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.Policy chrome_policies = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_chrome_policies_size()); i < n; i++) {
    const auto& repfield = this->_internal_chrome_policies(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.ExtensionPolicy extension_policies = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_policies_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension_policies(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.PolicyFetchTimestamp policy_fetched_timestamps = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_policy_fetched_timestamps_size()); i < n; i++) {
    const auto& repfield = this->_internal_policy_fetched_timestamps(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.ExtensionRequest extension_requests = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_requests_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension_requests(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ChromeUserProfileInfo)
  return target;
}

size_t ChromeUserProfileInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ChromeUserProfileInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.Extension extensions = 5;
  total_size += 1UL * this->_internal_extensions_size();
  for (const auto& msg : this->_impl_.extensions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.Policy chrome_policies = 7;
  total_size += 1UL * this->_internal_chrome_policies_size();
  for (const auto& msg : this->_impl_.chrome_policies_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.ExtensionPolicy extension_policies = 8;
  total_size += 1UL * this->_internal_extension_policies_size();
  for (const auto& msg : this->_impl_.extension_policies_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.PolicyFetchTimestamp policy_fetched_timestamps = 9;
  total_size += 1UL * this->_internal_policy_fetched_timestamps_size();
  for (const auto& msg : this->_impl_.policy_fetched_timestamps_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.ExtensionRequest extension_requests = 10;
  total_size += 1UL * this->_internal_extension_requests_size();
  for (const auto& msg : this->_impl_.extension_requests_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id());
    }

    // optional string name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .enterprise_management.ChromeSignedInUser chrome_signed_in_user = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chrome_signed_in_user_);
    }

    // optional bool is_detail_available = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChromeUserProfileInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChromeUserProfileInfo*>(
      &from));
}

void ChromeUserProfileInfo::MergeFrom(const ChromeUserProfileInfo& from) {
  ChromeUserProfileInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ChromeUserProfileInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.extensions_.MergeFrom(from._impl_.extensions_);
  _this->_impl_.chrome_policies_.MergeFrom(from._impl_.chrome_policies_);
  _this->_impl_.extension_policies_.MergeFrom(from._impl_.extension_policies_);
  _this->_impl_.policy_fetched_timestamps_.MergeFrom(from._impl_.policy_fetched_timestamps_);
  _this->_impl_.extension_requests_.MergeFrom(from._impl_.extension_requests_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_chrome_signed_in_user()->::enterprise_management::ChromeSignedInUser::MergeFrom(
          from._internal_chrome_signed_in_user());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_detail_available_ = from._impl_.is_detail_available_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromeUserProfileInfo::CopyFrom(const ChromeUserProfileInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ChromeUserProfileInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChromeUserProfileInfo::IsInitialized() const {
  return true;
}

void ChromeUserProfileInfo::InternalSwap(ChromeUserProfileInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extensions_.InternalSwap(&other->_impl_.extensions_);
  _impl_.chrome_policies_.InternalSwap(&other->_impl_.chrome_policies_);
  _impl_.extension_policies_.InternalSwap(&other->_impl_.extension_policies_);
  _impl_.policy_fetched_timestamps_.InternalSwap(&other->_impl_.policy_fetched_timestamps_);
  _impl_.extension_requests_.InternalSwap(&other->_impl_.extension_requests_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChromeUserProfileInfo, _impl_.is_detail_available_)
      + sizeof(ChromeUserProfileInfo::_impl_.is_detail_available_)
      - PROTOBUF_FIELD_OFFSET(ChromeUserProfileInfo, _impl_.chrome_signed_in_user_)>(
          reinterpret_cast<char*>(&_impl_.chrome_signed_in_user_),
          reinterpret_cast<char*>(&other->_impl_.chrome_signed_in_user_));
}

std::string ChromeUserProfileInfo::GetTypeName() const {
  return "enterprise_management.ChromeUserProfileInfo";
}


// ===================================================================

class BrowserReport::_Internal {
 public:
  using HasBits = decltype(std::declval<BrowserReport>()._impl_._has_bits_);
  static void set_has_browser_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_executable_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_installed_browser_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_extended_stable_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

BrowserReport::BrowserReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.BrowserReport)
}
BrowserReport::BrowserReport(const BrowserReport& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BrowserReport* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chrome_user_profile_reports_){from._impl_.chrome_user_profile_reports_}
    , decltype(_impl_.chrome_user_profile_infos_){from._impl_.chrome_user_profile_infos_}
    , decltype(_impl_.plugins_){from._impl_.plugins_}
    , decltype(_impl_.browser_version_){}
    , decltype(_impl_.executable_path_){}
    , decltype(_impl_.installed_browser_version_){}
    , decltype(_impl_.channel_){}
    , decltype(_impl_.is_extended_stable_channel_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.browser_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_browser_version()) {
    _this->_impl_.browser_version_.Set(from._internal_browser_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.executable_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.executable_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_executable_path()) {
    _this->_impl_.executable_path_.Set(from._internal_executable_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.installed_browser_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.installed_browser_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_installed_browser_version()) {
    _this->_impl_.installed_browser_version_.Set(from._internal_installed_browser_version(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.channel_, &from._impl_.channel_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_extended_stable_channel_) -
    reinterpret_cast<char*>(&_impl_.channel_)) + sizeof(_impl_.is_extended_stable_channel_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.BrowserReport)
}

inline void BrowserReport::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chrome_user_profile_reports_){arena}
    , decltype(_impl_.chrome_user_profile_infos_){arena}
    , decltype(_impl_.plugins_){arena}
    , decltype(_impl_.browser_version_){}
    , decltype(_impl_.executable_path_){}
    , decltype(_impl_.installed_browser_version_){}
    , decltype(_impl_.channel_){0}
    , decltype(_impl_.is_extended_stable_channel_){false}
  };
  _impl_.browser_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.executable_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.executable_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.installed_browser_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.installed_browser_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BrowserReport::~BrowserReport() {
  // @@protoc_insertion_point(destructor:enterprise_management.BrowserReport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BrowserReport::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.chrome_user_profile_reports_.~RepeatedPtrField();
  _impl_.chrome_user_profile_infos_.~RepeatedPtrField();
  _impl_.plugins_.~RepeatedPtrField();
  _impl_.browser_version_.Destroy();
  _impl_.executable_path_.Destroy();
  _impl_.installed_browser_version_.Destroy();
}

void BrowserReport::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BrowserReport::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.BrowserReport)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.chrome_user_profile_reports_.Clear();
  _impl_.chrome_user_profile_infos_.Clear();
  _impl_.plugins_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.browser_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.executable_path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.installed_browser_version_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.channel_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_extended_stable_channel_) -
        reinterpret_cast<char*>(&_impl_.channel_)) + sizeof(_impl_.is_extended_stable_channel_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BrowserReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string browser_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_browser_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.Channel channel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::Channel_IsValid(val))) {
            _internal_set_channel(static_cast<::enterprise_management::Channel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string executable_path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_executable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.ChromeUserProfileReport chrome_user_profile_reports = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_chrome_user_profile_reports(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.ChromeUserProfileInfo chrome_user_profile_infos = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_chrome_user_profile_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.Plugin plugins = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_plugins(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string installed_browser_version = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_installed_browser_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_extended_stable_channel = 9 [default = false];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_is_extended_stable_channel(&has_bits);
          _impl_.is_extended_stable_channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BrowserReport::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.BrowserReport)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string browser_version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_browser_version(), target);
  }

  // optional .enterprise_management.Channel channel = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_channel(), target);
  }

  // optional string executable_path = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_executable_path(), target);
  }

  // repeated .enterprise_management.ChromeUserProfileReport chrome_user_profile_reports = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_chrome_user_profile_reports_size()); i < n; i++) {
    const auto& repfield = this->_internal_chrome_user_profile_reports(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.ChromeUserProfileInfo chrome_user_profile_infos = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_chrome_user_profile_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_chrome_user_profile_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.Plugin plugins = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_plugins_size()); i < n; i++) {
    const auto& repfield = this->_internal_plugins(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string installed_browser_version = 8;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_installed_browser_version(), target);
  }

  // optional bool is_extended_stable_channel = 9 [default = false];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_is_extended_stable_channel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.BrowserReport)
  return target;
}

size_t BrowserReport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.BrowserReport)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.ChromeUserProfileReport chrome_user_profile_reports = 4;
  total_size += 1UL * this->_internal_chrome_user_profile_reports_size();
  for (const auto& msg : this->_impl_.chrome_user_profile_reports_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.ChromeUserProfileInfo chrome_user_profile_infos = 6;
  total_size += 1UL * this->_internal_chrome_user_profile_infos_size();
  for (const auto& msg : this->_impl_.chrome_user_profile_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.Plugin plugins = 7;
  total_size += 1UL * this->_internal_plugins_size();
  for (const auto& msg : this->_impl_.plugins_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string browser_version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_browser_version());
    }

    // optional string executable_path = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_executable_path());
    }

    // optional string installed_browser_version = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_installed_browser_version());
    }

    // optional .enterprise_management.Channel channel = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_channel());
    }

    // optional bool is_extended_stable_channel = 9 [default = false];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BrowserReport::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BrowserReport*>(
      &from));
}

void BrowserReport::MergeFrom(const BrowserReport& from) {
  BrowserReport* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.BrowserReport)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.chrome_user_profile_reports_.MergeFrom(from._impl_.chrome_user_profile_reports_);
  _this->_impl_.chrome_user_profile_infos_.MergeFrom(from._impl_.chrome_user_profile_infos_);
  _this->_impl_.plugins_.MergeFrom(from._impl_.plugins_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_browser_version(from._internal_browser_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_executable_path(from._internal_executable_path());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_installed_browser_version(from._internal_installed_browser_version());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.channel_ = from._impl_.channel_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.is_extended_stable_channel_ = from._impl_.is_extended_stable_channel_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BrowserReport::CopyFrom(const BrowserReport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.BrowserReport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BrowserReport::IsInitialized() const {
  return true;
}

void BrowserReport::InternalSwap(BrowserReport* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.chrome_user_profile_reports_.InternalSwap(&other->_impl_.chrome_user_profile_reports_);
  _impl_.chrome_user_profile_infos_.InternalSwap(&other->_impl_.chrome_user_profile_infos_);
  _impl_.plugins_.InternalSwap(&other->_impl_.plugins_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.browser_version_, lhs_arena,
      &other->_impl_.browser_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.executable_path_, lhs_arena,
      &other->_impl_.executable_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.installed_browser_version_, lhs_arena,
      &other->_impl_.installed_browser_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BrowserReport, _impl_.is_extended_stable_channel_)
      + sizeof(BrowserReport::_impl_.is_extended_stable_channel_)
      - PROTOBUF_FIELD_OFFSET(BrowserReport, _impl_.channel_)>(
          reinterpret_cast<char*>(&_impl_.channel_),
          reinterpret_cast<char*>(&other->_impl_.channel_));
}

std::string BrowserReport::GetTypeName() const {
  return "enterprise_management.BrowserReport";
}


// ===================================================================

class OSReport::_Internal {
 public:
  using HasBits = decltype(std::declval<OSReport>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_arch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_version_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

OSReport::OSReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.OSReport)
}
OSReport::OSReport(const OSReport& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OSReport* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.arch_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.version_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.arch_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.arch_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_arch()) {
    _this->_impl_.arch_.Set(from._internal_arch(), 
      _this->GetArenaForAllocation());
  }
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.version_type_ = from._impl_.version_type_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.OSReport)
}

inline void OSReport::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.arch_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.version_type_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.arch_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.arch_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OSReport::~OSReport() {
  // @@protoc_insertion_point(destructor:enterprise_management.OSReport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OSReport::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.arch_.Destroy();
  _impl_.version_.Destroy();
}

void OSReport::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OSReport::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.OSReport)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.arch_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.version_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.version_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OSReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string arch = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_arch();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.OSReport.VersionType version_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::OSReport_VersionType_IsValid(val))) {
            _internal_set_version_type(static_cast<::enterprise_management::OSReport_VersionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OSReport::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.OSReport)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string arch = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_arch(), target);
  }

  // optional string version = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_version(), target);
  }

  // optional .enterprise_management.OSReport.VersionType version_type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_version_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.OSReport)
  return target;
}

size_t OSReport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.OSReport)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string arch = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_arch());
    }

    // optional string version = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional .enterprise_management.OSReport.VersionType version_type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_version_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OSReport::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OSReport*>(
      &from));
}

void OSReport::MergeFrom(const OSReport& from) {
  OSReport* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.OSReport)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_arch(from._internal_arch());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.version_type_ = from._impl_.version_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OSReport::CopyFrom(const OSReport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.OSReport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OSReport::IsInitialized() const {
  return true;
}

void OSReport::InternalSwap(OSReport* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.arch_, lhs_arena,
      &other->_impl_.arch_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  swap(_impl_.version_type_, other->_impl_.version_type_);
}

std::string OSReport::GetTypeName() const {
  return "enterprise_management.OSReport";
}


// ===================================================================

class ChromeDesktopReportRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ChromeDesktopReportRequest>()._impl_._has_bits_);
  static void set_has_machine_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_os_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_os_user(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::enterprise_management::BrowserReport& browser_report(const ChromeDesktopReportRequest* msg);
  static void set_has_browser_report(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_serial_number(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_computer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::enterprise_management::OSReport& os_report(const ChromeDesktopReportRequest* msg);
  static void set_has_os_report(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_os_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::enterprise_management::BrowserDeviceIdentifier& browser_device_identifier(const ChromeDesktopReportRequest* msg);
  static void set_has_browser_device_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_machine_attestation_key(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_device_model(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_brand_name(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::enterprise_management::BrowserReport&
ChromeDesktopReportRequest::_Internal::browser_report(const ChromeDesktopReportRequest* msg) {
  return *msg->_impl_.browser_report_;
}
const ::enterprise_management::OSReport&
ChromeDesktopReportRequest::_Internal::os_report(const ChromeDesktopReportRequest* msg) {
  return *msg->_impl_.os_report_;
}
const ::enterprise_management::BrowserDeviceIdentifier&
ChromeDesktopReportRequest::_Internal::browser_device_identifier(const ChromeDesktopReportRequest* msg) {
  return *msg->_impl_.browser_device_identifier_;
}
ChromeDesktopReportRequest::ChromeDesktopReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ChromeDesktopReportRequest)
}
ChromeDesktopReportRequest::ChromeDesktopReportRequest(const ChromeDesktopReportRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ChromeDesktopReportRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.partial_report_types_){from._impl_.partial_report_types_}
    , decltype(_impl_.machine_name_){}
    , decltype(_impl_.os_info_){}
    , decltype(_impl_.os_user_){}
    , decltype(_impl_.serial_number_){}
    , decltype(_impl_.computer_name_){}
    , decltype(_impl_.os_user_name_){}
    , decltype(_impl_.machine_attestation_key_){}
    , decltype(_impl_.device_model_){}
    , decltype(_impl_.brand_name_){}
    , decltype(_impl_.browser_report_){nullptr}
    , decltype(_impl_.os_report_){nullptr}
    , decltype(_impl_.browser_device_identifier_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.machine_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_machine_name()) {
    _this->_impl_.machine_name_.Set(from._internal_machine_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.os_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_os_info()) {
    _this->_impl_.os_info_.Set(from._internal_os_info(), 
      _this->GetArenaForAllocation());
  }
  _impl_.os_user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_os_user()) {
    _this->_impl_.os_user_.Set(from._internal_os_user(), 
      _this->GetArenaForAllocation());
  }
  _impl_.serial_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serial_number()) {
    _this->_impl_.serial_number_.Set(from._internal_serial_number(), 
      _this->GetArenaForAllocation());
  }
  _impl_.computer_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.computer_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_computer_name()) {
    _this->_impl_.computer_name_.Set(from._internal_computer_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.os_user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_os_user_name()) {
    _this->_impl_.os_user_name_.Set(from._internal_os_user_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.machine_attestation_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_attestation_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_machine_attestation_key()) {
    _this->_impl_.machine_attestation_key_.Set(from._internal_machine_attestation_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.device_model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_model()) {
    _this->_impl_.device_model_.Set(from._internal_device_model(), 
      _this->GetArenaForAllocation());
  }
  _impl_.brand_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.brand_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_brand_name()) {
    _this->_impl_.brand_name_.Set(from._internal_brand_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_browser_report()) {
    _this->_impl_.browser_report_ = new ::enterprise_management::BrowserReport(*from._impl_.browser_report_);
  }
  if (from._internal_has_os_report()) {
    _this->_impl_.os_report_ = new ::enterprise_management::OSReport(*from._impl_.os_report_);
  }
  if (from._internal_has_browser_device_identifier()) {
    _this->_impl_.browser_device_identifier_ = new ::enterprise_management::BrowserDeviceIdentifier(*from._impl_.browser_device_identifier_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ChromeDesktopReportRequest)
}

inline void ChromeDesktopReportRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.partial_report_types_){arena}
    , decltype(_impl_.machine_name_){}
    , decltype(_impl_.os_info_){}
    , decltype(_impl_.os_user_){}
    , decltype(_impl_.serial_number_){}
    , decltype(_impl_.computer_name_){}
    , decltype(_impl_.os_user_name_){}
    , decltype(_impl_.machine_attestation_key_){}
    , decltype(_impl_.device_model_){}
    , decltype(_impl_.brand_name_){}
    , decltype(_impl_.browser_report_){nullptr}
    , decltype(_impl_.os_report_){nullptr}
    , decltype(_impl_.browser_device_identifier_){nullptr}
  };
  _impl_.machine_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.os_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.os_user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.serial_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.computer_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.computer_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.os_user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.machine_attestation_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_attestation_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.device_model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.brand_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.brand_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChromeDesktopReportRequest::~ChromeDesktopReportRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.ChromeDesktopReportRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChromeDesktopReportRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.partial_report_types_.~RepeatedField();
  _impl_.machine_name_.Destroy();
  _impl_.os_info_.Destroy();
  _impl_.os_user_.Destroy();
  _impl_.serial_number_.Destroy();
  _impl_.computer_name_.Destroy();
  _impl_.os_user_name_.Destroy();
  _impl_.machine_attestation_key_.Destroy();
  _impl_.device_model_.Destroy();
  _impl_.brand_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.browser_report_;
  if (this != internal_default_instance()) delete _impl_.os_report_;
  if (this != internal_default_instance()) delete _impl_.browser_device_identifier_;
}

void ChromeDesktopReportRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChromeDesktopReportRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ChromeDesktopReportRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.partial_report_types_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.machine_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.os_info_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.os_user_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.serial_number_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.computer_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.os_user_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.machine_attestation_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.device_model_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _impl_.brand_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.browser_report_ != nullptr);
      _impl_.browser_report_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.os_report_ != nullptr);
      _impl_.os_report_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.browser_device_identifier_ != nullptr);
      _impl_.browser_device_identifier_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChromeDesktopReportRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string machine_name = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_machine_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string os_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_os_info();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string os_user = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_os_user();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BrowserReport browser_report = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_browser_report(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string serial_number = 5 [deprecated = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_serial_number();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string computer_name = 6 [deprecated = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_computer_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.OSReport os_report = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_os_report(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string os_user_name = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_os_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BrowserDeviceIdentifier browser_device_identifier = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_browser_device_identifier(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.PartialReportType partial_report_types = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::enterprise_management::PartialReportType_IsValid(val))) {
              _internal_add_partial_report_types(static_cast<::enterprise_management::PartialReportType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<80>(ptr));
        } else if (static_cast<uint8_t>(tag) == 82) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_partial_report_types(), ptr, ctx, ::enterprise_management::PartialReportType_IsValid, &_internal_metadata_, 10);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string machine_attestation_key = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_machine_attestation_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string device_model = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_device_model();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string brand_name = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_brand_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChromeDesktopReportRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ChromeDesktopReportRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string machine_name = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_machine_name(), target);
  }

  // optional string os_info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_os_info(), target);
  }

  // optional string os_user = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_os_user(), target);
  }

  // optional .enterprise_management.BrowserReport browser_report = 4;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::browser_report(this),
        _Internal::browser_report(this).GetCachedSize(), target, stream);
  }

  // optional string serial_number = 5 [deprecated = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_serial_number(), target);
  }

  // optional string computer_name = 6 [deprecated = true];
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_computer_name(), target);
  }

  // optional .enterprise_management.OSReport os_report = 7;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::os_report(this),
        _Internal::os_report(this).GetCachedSize(), target, stream);
  }

  // optional string os_user_name = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_os_user_name(), target);
  }

  // optional .enterprise_management.BrowserDeviceIdentifier browser_device_identifier = 9;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::browser_device_identifier(this),
        _Internal::browser_device_identifier(this).GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.PartialReportType partial_report_types = 10;
  for (int i = 0, n = this->_internal_partial_report_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        10, this->_internal_partial_report_types(i), target);
  }

  // optional string machine_attestation_key = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_machine_attestation_key(), target);
  }

  // optional string device_model = 12;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_device_model(), target);
  }

  // optional string brand_name = 13;
  if (cached_has_bits & 0x00000100u) {
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_brand_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ChromeDesktopReportRequest)
  return target;
}

size_t ChromeDesktopReportRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ChromeDesktopReportRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.PartialReportType partial_report_types = 10;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_partial_report_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_partial_report_types(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string machine_name = 1 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_machine_name());
    }

    // optional string os_info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_os_info());
    }

    // optional string os_user = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_os_user());
    }

    // optional string serial_number = 5 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_serial_number());
    }

    // optional string computer_name = 6 [deprecated = true];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_computer_name());
    }

    // optional string os_user_name = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_os_user_name());
    }

    // optional string machine_attestation_key = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_machine_attestation_key());
    }

    // optional string device_model = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_model());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional string brand_name = 13;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_brand_name());
    }

    // optional .enterprise_management.BrowserReport browser_report = 4;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.browser_report_);
    }

    // optional .enterprise_management.OSReport os_report = 7;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.os_report_);
    }

    // optional .enterprise_management.BrowserDeviceIdentifier browser_device_identifier = 9;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.browser_device_identifier_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChromeDesktopReportRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChromeDesktopReportRequest*>(
      &from));
}

void ChromeDesktopReportRequest::MergeFrom(const ChromeDesktopReportRequest& from) {
  ChromeDesktopReportRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ChromeDesktopReportRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.partial_report_types_.MergeFrom(from._impl_.partial_report_types_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_machine_name(from._internal_machine_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_os_info(from._internal_os_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_os_user(from._internal_os_user());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_serial_number(from._internal_serial_number());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_computer_name(from._internal_computer_name());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_os_user_name(from._internal_os_user_name());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_machine_attestation_key(from._internal_machine_attestation_key());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_device_model(from._internal_device_model());
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_set_brand_name(from._internal_brand_name());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_browser_report()->::enterprise_management::BrowserReport::MergeFrom(
          from._internal_browser_report());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_os_report()->::enterprise_management::OSReport::MergeFrom(
          from._internal_os_report());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_browser_device_identifier()->::enterprise_management::BrowserDeviceIdentifier::MergeFrom(
          from._internal_browser_device_identifier());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromeDesktopReportRequest::CopyFrom(const ChromeDesktopReportRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ChromeDesktopReportRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChromeDesktopReportRequest::IsInitialized() const {
  return true;
}

void ChromeDesktopReportRequest::InternalSwap(ChromeDesktopReportRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.partial_report_types_.InternalSwap(&other->_impl_.partial_report_types_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_name_, lhs_arena,
      &other->_impl_.machine_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.os_info_, lhs_arena,
      &other->_impl_.os_info_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.os_user_, lhs_arena,
      &other->_impl_.os_user_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.serial_number_, lhs_arena,
      &other->_impl_.serial_number_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.computer_name_, lhs_arena,
      &other->_impl_.computer_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.os_user_name_, lhs_arena,
      &other->_impl_.os_user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_attestation_key_, lhs_arena,
      &other->_impl_.machine_attestation_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_model_, lhs_arena,
      &other->_impl_.device_model_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.brand_name_, lhs_arena,
      &other->_impl_.brand_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChromeDesktopReportRequest, _impl_.browser_device_identifier_)
      + sizeof(ChromeDesktopReportRequest::_impl_.browser_device_identifier_)
      - PROTOBUF_FIELD_OFFSET(ChromeDesktopReportRequest, _impl_.browser_report_)>(
          reinterpret_cast<char*>(&_impl_.browser_report_),
          reinterpret_cast<char*>(&other->_impl_.browser_report_));
}

std::string ChromeDesktopReportRequest::GetTypeName() const {
  return "enterprise_management.ChromeDesktopReportRequest";
}


// ===================================================================

class ChromeOsUserReportRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ChromeOsUserReportRequest>()._impl_._has_bits_);
  static const ::enterprise_management::BrowserReport& browser_report(const ChromeOsUserReportRequest* msg);
  static void set_has_browser_report(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::enterprise_management::BrowserReport&
ChromeOsUserReportRequest::_Internal::browser_report(const ChromeOsUserReportRequest* msg) {
  return *msg->_impl_.browser_report_;
}
ChromeOsUserReportRequest::ChromeOsUserReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ChromeOsUserReportRequest)
}
ChromeOsUserReportRequest::ChromeOsUserReportRequest(const ChromeOsUserReportRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ChromeOsUserReportRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.android_app_infos_){from._impl_.android_app_infos_}
    , decltype(_impl_.partial_report_types_){from._impl_.partial_report_types_}
    , decltype(_impl_.browser_report_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_browser_report()) {
    _this->_impl_.browser_report_ = new ::enterprise_management::BrowserReport(*from._impl_.browser_report_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ChromeOsUserReportRequest)
}

inline void ChromeOsUserReportRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.android_app_infos_){arena}
    , decltype(_impl_.partial_report_types_){arena}
    , decltype(_impl_.browser_report_){nullptr}
  };
}

ChromeOsUserReportRequest::~ChromeOsUserReportRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.ChromeOsUserReportRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChromeOsUserReportRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.android_app_infos_.~RepeatedPtrField();
  _impl_.partial_report_types_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.browser_report_;
}

void ChromeOsUserReportRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChromeOsUserReportRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ChromeOsUserReportRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.android_app_infos_.Clear();
  _impl_.partial_report_types_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.browser_report_ != nullptr);
    _impl_.browser_report_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChromeOsUserReportRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.BrowserReport browser_report = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_browser_report(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.AndroidAppInfo android_app_infos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_android_app_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.PartialReportType partial_report_types = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::enterprise_management::PartialReportType_IsValid(val))) {
              _internal_add_partial_report_types(static_cast<::enterprise_management::PartialReportType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_partial_report_types(), ptr, ctx, ::enterprise_management::PartialReportType_IsValid, &_internal_metadata_, 3);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChromeOsUserReportRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ChromeOsUserReportRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.BrowserReport browser_report = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::browser_report(this),
        _Internal::browser_report(this).GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.AndroidAppInfo android_app_infos = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_android_app_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_android_app_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.PartialReportType partial_report_types = 3;
  for (int i = 0, n = this->_internal_partial_report_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_partial_report_types(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ChromeOsUserReportRequest)
  return target;
}

size_t ChromeOsUserReportRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ChromeOsUserReportRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.AndroidAppInfo android_app_infos = 2;
  total_size += 1UL * this->_internal_android_app_infos_size();
  for (const auto& msg : this->_impl_.android_app_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.PartialReportType partial_report_types = 3;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_partial_report_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_partial_report_types(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // optional .enterprise_management.BrowserReport browser_report = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.browser_report_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChromeOsUserReportRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChromeOsUserReportRequest*>(
      &from));
}

void ChromeOsUserReportRequest::MergeFrom(const ChromeOsUserReportRequest& from) {
  ChromeOsUserReportRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ChromeOsUserReportRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.android_app_infos_.MergeFrom(from._impl_.android_app_infos_);
  _this->_impl_.partial_report_types_.MergeFrom(from._impl_.partial_report_types_);
  if (from._internal_has_browser_report()) {
    _this->_internal_mutable_browser_report()->::enterprise_management::BrowserReport::MergeFrom(
        from._internal_browser_report());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromeOsUserReportRequest::CopyFrom(const ChromeOsUserReportRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ChromeOsUserReportRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChromeOsUserReportRequest::IsInitialized() const {
  return true;
}

void ChromeOsUserReportRequest::InternalSwap(ChromeOsUserReportRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.android_app_infos_.InternalSwap(&other->_impl_.android_app_infos_);
  _impl_.partial_report_types_.InternalSwap(&other->_impl_.partial_report_types_);
  swap(_impl_.browser_report_, other->_impl_.browser_report_);
}

std::string ChromeOsUserReportRequest::GetTypeName() const {
  return "enterprise_management.ChromeOsUserReportRequest";
}


// ===================================================================

class ChromeProfileReportRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ChromeProfileReportRequest>()._impl_._has_bits_);
  static const ::enterprise_management::BrowserReport& browser_report(const ChromeProfileReportRequest* msg);
  static void set_has_browser_report(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::enterprise_management::OSReport& os_report(const ChromeProfileReportRequest* msg);
  static void set_has_os_report(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::enterprise_management::BrowserReport&
ChromeProfileReportRequest::_Internal::browser_report(const ChromeProfileReportRequest* msg) {
  return *msg->_impl_.browser_report_;
}
const ::enterprise_management::OSReport&
ChromeProfileReportRequest::_Internal::os_report(const ChromeProfileReportRequest* msg) {
  return *msg->_impl_.os_report_;
}
ChromeProfileReportRequest::ChromeProfileReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ChromeProfileReportRequest)
}
ChromeProfileReportRequest::ChromeProfileReportRequest(const ChromeProfileReportRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ChromeProfileReportRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.browser_report_){nullptr}
    , decltype(_impl_.os_report_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_browser_report()) {
    _this->_impl_.browser_report_ = new ::enterprise_management::BrowserReport(*from._impl_.browser_report_);
  }
  if (from._internal_has_os_report()) {
    _this->_impl_.os_report_ = new ::enterprise_management::OSReport(*from._impl_.os_report_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ChromeProfileReportRequest)
}

inline void ChromeProfileReportRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.browser_report_){nullptr}
    , decltype(_impl_.os_report_){nullptr}
  };
}

ChromeProfileReportRequest::~ChromeProfileReportRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.ChromeProfileReportRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChromeProfileReportRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.browser_report_;
  if (this != internal_default_instance()) delete _impl_.os_report_;
}

void ChromeProfileReportRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChromeProfileReportRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ChromeProfileReportRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.browser_report_ != nullptr);
      _impl_.browser_report_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.os_report_ != nullptr);
      _impl_.os_report_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChromeProfileReportRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.BrowserReport browser_report = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_browser_report(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.OSReport os_report = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_os_report(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChromeProfileReportRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ChromeProfileReportRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.BrowserReport browser_report = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::browser_report(this),
        _Internal::browser_report(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.OSReport os_report = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::os_report(this),
        _Internal::os_report(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ChromeProfileReportRequest)
  return target;
}

size_t ChromeProfileReportRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ChromeProfileReportRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .enterprise_management.BrowserReport browser_report = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.browser_report_);
    }

    // optional .enterprise_management.OSReport os_report = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.os_report_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChromeProfileReportRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChromeProfileReportRequest*>(
      &from));
}

void ChromeProfileReportRequest::MergeFrom(const ChromeProfileReportRequest& from) {
  ChromeProfileReportRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ChromeProfileReportRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_browser_report()->::enterprise_management::BrowserReport::MergeFrom(
          from._internal_browser_report());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_os_report()->::enterprise_management::OSReport::MergeFrom(
          from._internal_os_report());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromeProfileReportRequest::CopyFrom(const ChromeProfileReportRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ChromeProfileReportRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChromeProfileReportRequest::IsInitialized() const {
  return true;
}

void ChromeProfileReportRequest::InternalSwap(ChromeProfileReportRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChromeProfileReportRequest, _impl_.os_report_)
      + sizeof(ChromeProfileReportRequest::_impl_.os_report_)
      - PROTOBUF_FIELD_OFFSET(ChromeProfileReportRequest, _impl_.browser_report_)>(
          reinterpret_cast<char*>(&_impl_.browser_report_),
          reinterpret_cast<char*>(&other->_impl_.browser_report_));
}

std::string ChromeProfileReportRequest::GetTypeName() const {
  return "enterprise_management.ChromeProfileReportRequest";
}


// ===================================================================

class PolicyValueValidationIssue::_Internal {
 public:
  using HasBits = decltype(std::declval<PolicyValueValidationIssue>()._impl_._has_bits_);
  static void set_has_policy_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_severity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_debug_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PolicyValueValidationIssue::PolicyValueValidationIssue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PolicyValueValidationIssue)
}
PolicyValueValidationIssue::PolicyValueValidationIssue(const PolicyValueValidationIssue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PolicyValueValidationIssue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.policy_name_){}
    , decltype(_impl_.debug_message_){}
    , decltype(_impl_.severity_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.policy_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_policy_name()) {
    _this->_impl_.policy_name_.Set(from._internal_policy_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.debug_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.debug_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_debug_message()) {
    _this->_impl_.debug_message_.Set(from._internal_debug_message(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.severity_ = from._impl_.severity_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PolicyValueValidationIssue)
}

inline void PolicyValueValidationIssue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.policy_name_){}
    , decltype(_impl_.debug_message_){}
    , decltype(_impl_.severity_){0}
  };
  _impl_.policy_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.debug_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.debug_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PolicyValueValidationIssue::~PolicyValueValidationIssue() {
  // @@protoc_insertion_point(destructor:enterprise_management.PolicyValueValidationIssue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PolicyValueValidationIssue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.policy_name_.Destroy();
  _impl_.debug_message_.Destroy();
}

void PolicyValueValidationIssue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PolicyValueValidationIssue::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PolicyValueValidationIssue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.policy_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.debug_message_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.severity_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PolicyValueValidationIssue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string policy_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_policy_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyValueValidationIssue.ValueValidationIssueSeverity severity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity_IsValid(val))) {
            _internal_set_severity(static_cast<::enterprise_management::PolicyValueValidationIssue_ValueValidationIssueSeverity>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string debug_message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_debug_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PolicyValueValidationIssue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PolicyValueValidationIssue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string policy_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_policy_name(), target);
  }

  // optional .enterprise_management.PolicyValueValidationIssue.ValueValidationIssueSeverity severity = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_severity(), target);
  }

  // optional string debug_message = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_debug_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PolicyValueValidationIssue)
  return target;
}

size_t PolicyValueValidationIssue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PolicyValueValidationIssue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string policy_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_policy_name());
    }

    // optional string debug_message = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_debug_message());
    }

    // optional .enterprise_management.PolicyValueValidationIssue.ValueValidationIssueSeverity severity = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_severity());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PolicyValueValidationIssue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PolicyValueValidationIssue*>(
      &from));
}

void PolicyValueValidationIssue::MergeFrom(const PolicyValueValidationIssue& from) {
  PolicyValueValidationIssue* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PolicyValueValidationIssue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_policy_name(from._internal_policy_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_debug_message(from._internal_debug_message());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.severity_ = from._impl_.severity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PolicyValueValidationIssue::CopyFrom(const PolicyValueValidationIssue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PolicyValueValidationIssue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PolicyValueValidationIssue::IsInitialized() const {
  return true;
}

void PolicyValueValidationIssue::InternalSwap(PolicyValueValidationIssue* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.policy_name_, lhs_arena,
      &other->_impl_.policy_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.debug_message_, lhs_arena,
      &other->_impl_.debug_message_, rhs_arena
  );
  swap(_impl_.severity_, other->_impl_.severity_);
}

std::string PolicyValueValidationIssue::GetTypeName() const {
  return "enterprise_management.PolicyValueValidationIssue";
}


// ===================================================================

class PolicyValidationReportRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<PolicyValidationReportRequest>()._impl_._has_bits_);
  static void set_has_policy_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_policy_token(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_validation_result_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

PolicyValidationReportRequest::PolicyValidationReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PolicyValidationReportRequest)
}
PolicyValidationReportRequest::PolicyValidationReportRequest(const PolicyValidationReportRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PolicyValidationReportRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.policy_value_validation_issues_){from._impl_.policy_value_validation_issues_}
    , decltype(_impl_.policy_type_){}
    , decltype(_impl_.policy_token_){}
    , decltype(_impl_.validation_result_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.policy_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_policy_type()) {
    _this->_impl_.policy_type_.Set(from._internal_policy_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.policy_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_policy_token()) {
    _this->_impl_.policy_token_.Set(from._internal_policy_token(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.validation_result_type_ = from._impl_.validation_result_type_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PolicyValidationReportRequest)
}

inline void PolicyValidationReportRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.policy_value_validation_issues_){arena}
    , decltype(_impl_.policy_type_){}
    , decltype(_impl_.policy_token_){}
    , decltype(_impl_.validation_result_type_){0}
  };
  _impl_.policy_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.policy_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PolicyValidationReportRequest::~PolicyValidationReportRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.PolicyValidationReportRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PolicyValidationReportRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.policy_value_validation_issues_.~RepeatedPtrField();
  _impl_.policy_type_.Destroy();
  _impl_.policy_token_.Destroy();
}

void PolicyValidationReportRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PolicyValidationReportRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PolicyValidationReportRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.policy_value_validation_issues_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.policy_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.policy_token_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.validation_result_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PolicyValidationReportRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string policy_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_policy_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string policy_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_policy_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyValidationReportRequest.ValidationResultType validation_result_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::PolicyValidationReportRequest_ValidationResultType_IsValid(val))) {
            _internal_set_validation_result_type(static_cast<::enterprise_management::PolicyValidationReportRequest_ValidationResultType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.PolicyValueValidationIssue policy_value_validation_issues = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_policy_value_validation_issues(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PolicyValidationReportRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PolicyValidationReportRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string policy_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_policy_type(), target);
  }

  // optional string policy_token = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_policy_token(), target);
  }

  // optional .enterprise_management.PolicyValidationReportRequest.ValidationResultType validation_result_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_validation_result_type(), target);
  }

  // repeated .enterprise_management.PolicyValueValidationIssue policy_value_validation_issues = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_policy_value_validation_issues_size()); i < n; i++) {
    const auto& repfield = this->_internal_policy_value_validation_issues(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PolicyValidationReportRequest)
  return target;
}

size_t PolicyValidationReportRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PolicyValidationReportRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.PolicyValueValidationIssue policy_value_validation_issues = 4;
  total_size += 1UL * this->_internal_policy_value_validation_issues_size();
  for (const auto& msg : this->_impl_.policy_value_validation_issues_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string policy_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_policy_type());
    }

    // optional string policy_token = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_policy_token());
    }

    // optional .enterprise_management.PolicyValidationReportRequest.ValidationResultType validation_result_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_validation_result_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PolicyValidationReportRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PolicyValidationReportRequest*>(
      &from));
}

void PolicyValidationReportRequest::MergeFrom(const PolicyValidationReportRequest& from) {
  PolicyValidationReportRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PolicyValidationReportRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.policy_value_validation_issues_.MergeFrom(from._impl_.policy_value_validation_issues_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_policy_type(from._internal_policy_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_policy_token(from._internal_policy_token());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.validation_result_type_ = from._impl_.validation_result_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PolicyValidationReportRequest::CopyFrom(const PolicyValidationReportRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PolicyValidationReportRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PolicyValidationReportRequest::IsInitialized() const {
  return true;
}

void PolicyValidationReportRequest::InternalSwap(PolicyValidationReportRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.policy_value_validation_issues_.InternalSwap(&other->_impl_.policy_value_validation_issues_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.policy_type_, lhs_arena,
      &other->_impl_.policy_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.policy_token_, lhs_arena,
      &other->_impl_.policy_token_, rhs_arena
  );
  swap(_impl_.validation_result_type_, other->_impl_.validation_result_type_);
}

std::string PolicyValidationReportRequest::GetTypeName() const {
  return "enterprise_management.PolicyValidationReportRequest";
}


// ===================================================================

class PolicyValidationReportResponse::_Internal {
 public:
};

PolicyValidationReportResponse::PolicyValidationReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PolicyValidationReportResponse)
}
PolicyValidationReportResponse::PolicyValidationReportResponse(const PolicyValidationReportResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PolicyValidationReportResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PolicyValidationReportResponse)
}

inline void PolicyValidationReportResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

PolicyValidationReportResponse::~PolicyValidationReportResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.PolicyValidationReportResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PolicyValidationReportResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PolicyValidationReportResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PolicyValidationReportResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PolicyValidationReportResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* PolicyValidationReportResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PolicyValidationReportResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PolicyValidationReportResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PolicyValidationReportResponse)
  return target;
}

size_t PolicyValidationReportResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PolicyValidationReportResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PolicyValidationReportResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PolicyValidationReportResponse*>(
      &from));
}

void PolicyValidationReportResponse::MergeFrom(const PolicyValidationReportResponse& from) {
  PolicyValidationReportResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PolicyValidationReportResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PolicyValidationReportResponse::CopyFrom(const PolicyValidationReportResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PolicyValidationReportResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PolicyValidationReportResponse::IsInitialized() const {
  return true;
}

void PolicyValidationReportResponse::InternalSwap(PolicyValidationReportResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string PolicyValidationReportResponse::GetTypeName() const {
  return "enterprise_management.PolicyValidationReportResponse";
}


// ===================================================================

class AndroidStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<AndroidStatus>()._impl_._has_bits_);
  static void set_has_status_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_droid_guard_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AndroidStatus::AndroidStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AndroidStatus)
}
AndroidStatus::AndroidStatus(const AndroidStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AndroidStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_payload_){}
    , decltype(_impl_.droid_guard_info_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.status_payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status_payload()) {
    _this->_impl_.status_payload_.Set(from._internal_status_payload(), 
      _this->GetArenaForAllocation());
  }
  _impl_.droid_guard_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.droid_guard_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_droid_guard_info()) {
    _this->_impl_.droid_guard_info_.Set(from._internal_droid_guard_info(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AndroidStatus)
}

inline void AndroidStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_payload_){}
    , decltype(_impl_.droid_guard_info_){}
  };
  _impl_.status_payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.droid_guard_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.droid_guard_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AndroidStatus::~AndroidStatus() {
  // @@protoc_insertion_point(destructor:enterprise_management.AndroidStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AndroidStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.status_payload_.Destroy();
  _impl_.droid_guard_info_.Destroy();
}

void AndroidStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AndroidStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AndroidStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.status_payload_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.droid_guard_info_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AndroidStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string status_payload = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_status_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string droid_guard_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_droid_guard_info();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AndroidStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AndroidStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string status_payload = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_status_payload(), target);
  }

  // optional string droid_guard_info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_droid_guard_info(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AndroidStatus)
  return target;
}

size_t AndroidStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AndroidStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string status_payload = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_status_payload());
    }

    // optional string droid_guard_info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_droid_guard_info());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AndroidStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AndroidStatus*>(
      &from));
}

void AndroidStatus::MergeFrom(const AndroidStatus& from) {
  AndroidStatus* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AndroidStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_status_payload(from._internal_status_payload());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_droid_guard_info(from._internal_droid_guard_info());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AndroidStatus::CopyFrom(const AndroidStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AndroidStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AndroidStatus::IsInitialized() const {
  return true;
}

void AndroidStatus::InternalSwap(AndroidStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_payload_, lhs_arena,
      &other->_impl_.status_payload_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.droid_guard_info_, lhs_arena,
      &other->_impl_.droid_guard_info_, rhs_arena
  );
}

std::string AndroidStatus::GetTypeName() const {
  return "enterprise_management.AndroidStatus";
}


// ===================================================================

class CrostiniApp::_Internal {
 public:
  using HasBits = decltype(std::declval<CrostiniApp>()._impl_._has_bits_);
  static void set_has_app_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_app_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_last_launch_time_window_start_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_package_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_package_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_package_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CrostiniApp::CrostiniApp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CrostiniApp)
}
CrostiniApp::CrostiniApp(const CrostiniApp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CrostiniApp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.app_name_){}
    , decltype(_impl_.package_name_){}
    , decltype(_impl_.package_version_){}
    , decltype(_impl_.package_hash_){}
    , decltype(_impl_.last_launch_time_window_start_timestamp_){}
    , decltype(_impl_.app_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.app_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_app_name()) {
    _this->_impl_.app_name_.Set(from._internal_app_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.package_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.package_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_package_name()) {
    _this->_impl_.package_name_.Set(from._internal_package_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.package_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.package_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_package_version()) {
    _this->_impl_.package_version_.Set(from._internal_package_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.package_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.package_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_package_hash()) {
    _this->_impl_.package_hash_.Set(from._internal_package_hash(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.last_launch_time_window_start_timestamp_, &from._impl_.last_launch_time_window_start_timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.app_type_) -
    reinterpret_cast<char*>(&_impl_.last_launch_time_window_start_timestamp_)) + sizeof(_impl_.app_type_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CrostiniApp)
}

inline void CrostiniApp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.app_name_){}
    , decltype(_impl_.package_name_){}
    , decltype(_impl_.package_version_){}
    , decltype(_impl_.package_hash_){}
    , decltype(_impl_.last_launch_time_window_start_timestamp_){int64_t{0}}
    , decltype(_impl_.app_type_){0}
  };
  _impl_.app_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.package_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.package_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.package_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.package_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.package_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.package_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CrostiniApp::~CrostiniApp() {
  // @@protoc_insertion_point(destructor:enterprise_management.CrostiniApp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CrostiniApp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.app_name_.Destroy();
  _impl_.package_name_.Destroy();
  _impl_.package_version_.Destroy();
  _impl_.package_hash_.Destroy();
}

void CrostiniApp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CrostiniApp::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CrostiniApp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.app_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.package_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.package_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.package_hash_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&_impl_.last_launch_time_window_start_timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.app_type_) -
        reinterpret_cast<char*>(&_impl_.last_launch_time_window_start_timestamp_)) + sizeof(_impl_.app_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CrostiniApp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string app_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_app_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.CrostiniAppType app_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::CrostiniAppType_IsValid(val))) {
            _internal_set_app_type(static_cast<::enterprise_management::CrostiniAppType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 last_launch_time_window_start_timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_last_launch_time_window_start_timestamp(&has_bits);
          _impl_.last_launch_time_window_start_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string package_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_package_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string package_version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_package_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string package_hash = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_package_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CrostiniApp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CrostiniApp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string app_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_app_name(), target);
  }

  // optional .enterprise_management.CrostiniAppType app_type = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_app_type(), target);
  }

  // optional int64 last_launch_time_window_start_timestamp = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_last_launch_time_window_start_timestamp(), target);
  }

  // optional string package_name = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_package_name(), target);
  }

  // optional string package_version = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_package_version(), target);
  }

  // optional string package_hash = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_package_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CrostiniApp)
  return target;
}

size_t CrostiniApp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CrostiniApp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string app_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_app_name());
    }

    // optional string package_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_package_name());
    }

    // optional string package_version = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_package_version());
    }

    // optional string package_hash = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_package_hash());
    }

    // optional int64 last_launch_time_window_start_timestamp = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_launch_time_window_start_timestamp());
    }

    // optional .enterprise_management.CrostiniAppType app_type = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_app_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CrostiniApp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CrostiniApp*>(
      &from));
}

void CrostiniApp::MergeFrom(const CrostiniApp& from) {
  CrostiniApp* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CrostiniApp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_app_name(from._internal_app_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_package_name(from._internal_package_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_package_version(from._internal_package_version());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_package_hash(from._internal_package_hash());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.last_launch_time_window_start_timestamp_ = from._impl_.last_launch_time_window_start_timestamp_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.app_type_ = from._impl_.app_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CrostiniApp::CopyFrom(const CrostiniApp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CrostiniApp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CrostiniApp::IsInitialized() const {
  return true;
}

void CrostiniApp::InternalSwap(CrostiniApp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.app_name_, lhs_arena,
      &other->_impl_.app_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.package_name_, lhs_arena,
      &other->_impl_.package_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.package_version_, lhs_arena,
      &other->_impl_.package_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.package_hash_, lhs_arena,
      &other->_impl_.package_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CrostiniApp, _impl_.app_type_)
      + sizeof(CrostiniApp::_impl_.app_type_)
      - PROTOBUF_FIELD_OFFSET(CrostiniApp, _impl_.last_launch_time_window_start_timestamp_)>(
          reinterpret_cast<char*>(&_impl_.last_launch_time_window_start_timestamp_),
          reinterpret_cast<char*>(&other->_impl_.last_launch_time_window_start_timestamp_));
}

std::string CrostiniApp::GetTypeName() const {
  return "enterprise_management.CrostiniApp";
}


// ===================================================================

class CrostiniStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CrostiniStatus>()._impl_._has_bits_);
  static void set_has_last_launch_time_window_start_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_last_launch_vm_image_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_last_launch_vm_kernel_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CrostiniStatus::CrostiniStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CrostiniStatus)
}
CrostiniStatus::CrostiniStatus(const CrostiniStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CrostiniStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.installed_apps_){from._impl_.installed_apps_}
    , decltype(_impl_.last_launch_vm_image_version_){}
    , decltype(_impl_.last_launch_vm_kernel_version_){}
    , decltype(_impl_.last_launch_time_window_start_timestamp_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.last_launch_vm_image_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_launch_vm_image_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_last_launch_vm_image_version()) {
    _this->_impl_.last_launch_vm_image_version_.Set(from._internal_last_launch_vm_image_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.last_launch_vm_kernel_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_launch_vm_kernel_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_last_launch_vm_kernel_version()) {
    _this->_impl_.last_launch_vm_kernel_version_.Set(from._internal_last_launch_vm_kernel_version(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.last_launch_time_window_start_timestamp_ = from._impl_.last_launch_time_window_start_timestamp_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CrostiniStatus)
}

inline void CrostiniStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.installed_apps_){arena}
    , decltype(_impl_.last_launch_vm_image_version_){}
    , decltype(_impl_.last_launch_vm_kernel_version_){}
    , decltype(_impl_.last_launch_time_window_start_timestamp_){int64_t{0}}
  };
  _impl_.last_launch_vm_image_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_launch_vm_image_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.last_launch_vm_kernel_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_launch_vm_kernel_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CrostiniStatus::~CrostiniStatus() {
  // @@protoc_insertion_point(destructor:enterprise_management.CrostiniStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CrostiniStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.installed_apps_.~RepeatedPtrField();
  _impl_.last_launch_vm_image_version_.Destroy();
  _impl_.last_launch_vm_kernel_version_.Destroy();
}

void CrostiniStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CrostiniStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CrostiniStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.installed_apps_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.last_launch_vm_image_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.last_launch_vm_kernel_version_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.last_launch_time_window_start_timestamp_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CrostiniStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 last_launch_time_window_start_timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_last_launch_time_window_start_timestamp(&has_bits);
          _impl_.last_launch_time_window_start_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string last_launch_vm_image_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_last_launch_vm_image_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string last_launch_vm_kernel_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_last_launch_vm_kernel_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.CrostiniApp installed_apps = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_installed_apps(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CrostiniStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CrostiniStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 last_launch_time_window_start_timestamp = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_last_launch_time_window_start_timestamp(), target);
  }

  // optional string last_launch_vm_image_version = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_last_launch_vm_image_version(), target);
  }

  // optional string last_launch_vm_kernel_version = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_last_launch_vm_kernel_version(), target);
  }

  // repeated .enterprise_management.CrostiniApp installed_apps = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_installed_apps_size()); i < n; i++) {
    const auto& repfield = this->_internal_installed_apps(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CrostiniStatus)
  return target;
}

size_t CrostiniStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CrostiniStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.CrostiniApp installed_apps = 4;
  total_size += 1UL * this->_internal_installed_apps_size();
  for (const auto& msg : this->_impl_.installed_apps_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string last_launch_vm_image_version = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_last_launch_vm_image_version());
    }

    // optional string last_launch_vm_kernel_version = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_last_launch_vm_kernel_version());
    }

    // optional int64 last_launch_time_window_start_timestamp = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_launch_time_window_start_timestamp());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CrostiniStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CrostiniStatus*>(
      &from));
}

void CrostiniStatus::MergeFrom(const CrostiniStatus& from) {
  CrostiniStatus* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CrostiniStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.installed_apps_.MergeFrom(from._impl_.installed_apps_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_last_launch_vm_image_version(from._internal_last_launch_vm_image_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_last_launch_vm_kernel_version(from._internal_last_launch_vm_kernel_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.last_launch_time_window_start_timestamp_ = from._impl_.last_launch_time_window_start_timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CrostiniStatus::CopyFrom(const CrostiniStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CrostiniStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CrostiniStatus::IsInitialized() const {
  return true;
}

void CrostiniStatus::InternalSwap(CrostiniStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.installed_apps_.InternalSwap(&other->_impl_.installed_apps_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.last_launch_vm_image_version_, lhs_arena,
      &other->_impl_.last_launch_vm_image_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.last_launch_vm_kernel_version_, lhs_arena,
      &other->_impl_.last_launch_vm_kernel_version_, rhs_arena
  );
  swap(_impl_.last_launch_time_window_start_timestamp_, other->_impl_.last_launch_time_window_start_timestamp_);
}

std::string CrostiniStatus::GetTypeName() const {
  return "enterprise_management.CrostiniStatus";
}


// ===================================================================

class SessionStatusReportRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SessionStatusReportRequest>()._impl_._has_bits_);
  static void set_has_device_local_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::enterprise_management::AndroidStatus& android_status(const SessionStatusReportRequest* msg);
  static void set_has_android_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_user_dm_token(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_time_zone(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::enterprise_management::CrostiniStatus& crostini_status(const SessionStatusReportRequest* msg);
  static void set_has_crostini_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::enterprise_management::AndroidStatus&
SessionStatusReportRequest::_Internal::android_status(const SessionStatusReportRequest* msg) {
  return *msg->_impl_.android_status_;
}
const ::enterprise_management::CrostiniStatus&
SessionStatusReportRequest::_Internal::crostini_status(const SessionStatusReportRequest* msg) {
  return *msg->_impl_.crostini_status_;
}
SessionStatusReportRequest::SessionStatusReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.SessionStatusReportRequest)
}
SessionStatusReportRequest::SessionStatusReportRequest(const SessionStatusReportRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SessionStatusReportRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.installed_apps_){from._impl_.installed_apps_}
    , decltype(_impl_.app_infos_){from._impl_.app_infos_}
    , decltype(_impl_.device_local_account_id_){}
    , decltype(_impl_.user_dm_token_){}
    , decltype(_impl_.time_zone_){}
    , decltype(_impl_.android_status_){nullptr}
    , decltype(_impl_.crostini_status_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.device_local_account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_local_account_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_local_account_id()) {
    _this->_impl_.device_local_account_id_.Set(from._internal_device_local_account_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_dm_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_dm_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_dm_token()) {
    _this->_impl_.user_dm_token_.Set(from._internal_user_dm_token(), 
      _this->GetArenaForAllocation());
  }
  _impl_.time_zone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.time_zone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_time_zone()) {
    _this->_impl_.time_zone_.Set(from._internal_time_zone(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_android_status()) {
    _this->_impl_.android_status_ = new ::enterprise_management::AndroidStatus(*from._impl_.android_status_);
  }
  if (from._internal_has_crostini_status()) {
    _this->_impl_.crostini_status_ = new ::enterprise_management::CrostiniStatus(*from._impl_.crostini_status_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.SessionStatusReportRequest)
}

inline void SessionStatusReportRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.installed_apps_){arena}
    , decltype(_impl_.app_infos_){arena}
    , decltype(_impl_.device_local_account_id_){}
    , decltype(_impl_.user_dm_token_){}
    , decltype(_impl_.time_zone_){}
    , decltype(_impl_.android_status_){nullptr}
    , decltype(_impl_.crostini_status_){nullptr}
  };
  _impl_.device_local_account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_local_account_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_dm_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_dm_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.time_zone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.time_zone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SessionStatusReportRequest::~SessionStatusReportRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.SessionStatusReportRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SessionStatusReportRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.installed_apps_.~RepeatedPtrField();
  _impl_.app_infos_.~RepeatedPtrField();
  _impl_.device_local_account_id_.Destroy();
  _impl_.user_dm_token_.Destroy();
  _impl_.time_zone_.Destroy();
  if (this != internal_default_instance()) delete _impl_.android_status_;
  if (this != internal_default_instance()) delete _impl_.crostini_status_;
}

void SessionStatusReportRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SessionStatusReportRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.SessionStatusReportRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.installed_apps_.Clear();
  _impl_.app_infos_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.device_local_account_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.user_dm_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.time_zone_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.android_status_ != nullptr);
      _impl_.android_status_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.crostini_status_ != nullptr);
      _impl_.crostini_status_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SessionStatusReportRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device_local_account_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_device_local_account_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.AppStatus installed_apps = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_installed_apps(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AndroidStatus android_status = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_android_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string user_dm_token = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_user_dm_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string time_zone = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_time_zone();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.CrostiniStatus crostini_status = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_crostini_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.AppInfo app_infos = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_app_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SessionStatusReportRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.SessionStatusReportRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string device_local_account_id = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_device_local_account_id(), target);
  }

  // repeated .enterprise_management.AppStatus installed_apps = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_installed_apps_size()); i < n; i++) {
    const auto& repfield = this->_internal_installed_apps(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.AndroidStatus android_status = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::android_status(this),
        _Internal::android_status(this).GetCachedSize(), target, stream);
  }

  // optional string user_dm_token = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_user_dm_token(), target);
  }

  // optional string time_zone = 9;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_time_zone(), target);
  }

  // optional .enterprise_management.CrostiniStatus crostini_status = 10;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::crostini_status(this),
        _Internal::crostini_status(this).GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.AppInfo app_infos = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_app_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_app_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.SessionStatusReportRequest)
  return target;
}

size_t SessionStatusReportRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.SessionStatusReportRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.AppStatus installed_apps = 5;
  total_size += 1UL * this->_internal_installed_apps_size();
  for (const auto& msg : this->_impl_.installed_apps_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.AppInfo app_infos = 11;
  total_size += 1UL * this->_internal_app_infos_size();
  for (const auto& msg : this->_impl_.app_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string device_local_account_id = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_local_account_id());
    }

    // optional string user_dm_token = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_dm_token());
    }

    // optional string time_zone = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_time_zone());
    }

    // optional .enterprise_management.AndroidStatus android_status = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.android_status_);
    }

    // optional .enterprise_management.CrostiniStatus crostini_status = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.crostini_status_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SessionStatusReportRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SessionStatusReportRequest*>(
      &from));
}

void SessionStatusReportRequest::MergeFrom(const SessionStatusReportRequest& from) {
  SessionStatusReportRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.SessionStatusReportRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.installed_apps_.MergeFrom(from._impl_.installed_apps_);
  _this->_impl_.app_infos_.MergeFrom(from._impl_.app_infos_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_device_local_account_id(from._internal_device_local_account_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_user_dm_token(from._internal_user_dm_token());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_time_zone(from._internal_time_zone());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_android_status()->::enterprise_management::AndroidStatus::MergeFrom(
          from._internal_android_status());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_crostini_status()->::enterprise_management::CrostiniStatus::MergeFrom(
          from._internal_crostini_status());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SessionStatusReportRequest::CopyFrom(const SessionStatusReportRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.SessionStatusReportRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionStatusReportRequest::IsInitialized() const {
  return true;
}

void SessionStatusReportRequest::InternalSwap(SessionStatusReportRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.installed_apps_.InternalSwap(&other->_impl_.installed_apps_);
  _impl_.app_infos_.InternalSwap(&other->_impl_.app_infos_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_local_account_id_, lhs_arena,
      &other->_impl_.device_local_account_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_dm_token_, lhs_arena,
      &other->_impl_.user_dm_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.time_zone_, lhs_arena,
      &other->_impl_.time_zone_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SessionStatusReportRequest, _impl_.crostini_status_)
      + sizeof(SessionStatusReportRequest::_impl_.crostini_status_)
      - PROTOBUF_FIELD_OFFSET(SessionStatusReportRequest, _impl_.android_status_)>(
          reinterpret_cast<char*>(&_impl_.android_status_),
          reinterpret_cast<char*>(&other->_impl_.android_status_));
}

std::string SessionStatusReportRequest::GetTypeName() const {
  return "enterprise_management.SessionStatusReportRequest";
}


// ===================================================================

class DeviceStatusReportResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceStatusReportResponse>()._impl_._has_bits_);
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceStatusReportResponse::DeviceStatusReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceStatusReportResponse)
}
DeviceStatusReportResponse::DeviceStatusReportResponse(const DeviceStatusReportResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceStatusReportResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.error_code_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error_message()) {
    _this->_impl_.error_message_.Set(from._internal_error_message(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.error_code_ = from._impl_.error_code_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceStatusReportResponse)
}

inline void DeviceStatusReportResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.error_code_){0}
  };
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceStatusReportResponse::~DeviceStatusReportResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceStatusReportResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceStatusReportResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_message_.Destroy();
}

void DeviceStatusReportResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceStatusReportResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceStatusReportResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.error_message_.ClearNonDefaultToEmpty();
  }
  _impl_.error_code_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceStatusReportResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 error_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_error_code(&has_bits);
          _impl_.error_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string error_message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_error_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceStatusReportResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceStatusReportResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 error_code = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_error_code(), target);
  }

  // optional string error_message = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_error_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceStatusReportResponse)
  return target;
}

size_t DeviceStatusReportResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceStatusReportResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string error_message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error_message());
    }

    // optional int32 error_code = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_error_code());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceStatusReportResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceStatusReportResponse*>(
      &from));
}

void DeviceStatusReportResponse::MergeFrom(const DeviceStatusReportResponse& from) {
  DeviceStatusReportResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceStatusReportResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.error_code_ = from._impl_.error_code_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceStatusReportResponse::CopyFrom(const DeviceStatusReportResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceStatusReportResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceStatusReportResponse::IsInitialized() const {
  return true;
}

void DeviceStatusReportResponse::InternalSwap(DeviceStatusReportResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_message_, lhs_arena,
      &other->_impl_.error_message_, rhs_arena
  );
  swap(_impl_.error_code_, other->_impl_.error_code_);
}

std::string DeviceStatusReportResponse::GetTypeName() const {
  return "enterprise_management.DeviceStatusReportResponse";
}


// ===================================================================

class ChromeDesktopReportResponse::_Internal {
 public:
};

ChromeDesktopReportResponse::ChromeDesktopReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ChromeDesktopReportResponse)
}
ChromeDesktopReportResponse::ChromeDesktopReportResponse(const ChromeDesktopReportResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ChromeDesktopReportResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ChromeDesktopReportResponse)
}

inline void ChromeDesktopReportResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

ChromeDesktopReportResponse::~ChromeDesktopReportResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.ChromeDesktopReportResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChromeDesktopReportResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ChromeDesktopReportResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChromeDesktopReportResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ChromeDesktopReportResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ChromeDesktopReportResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChromeDesktopReportResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ChromeDesktopReportResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ChromeDesktopReportResponse)
  return target;
}

size_t ChromeDesktopReportResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ChromeDesktopReportResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChromeDesktopReportResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChromeDesktopReportResponse*>(
      &from));
}

void ChromeDesktopReportResponse::MergeFrom(const ChromeDesktopReportResponse& from) {
  ChromeDesktopReportResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ChromeDesktopReportResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromeDesktopReportResponse::CopyFrom(const ChromeDesktopReportResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ChromeDesktopReportResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChromeDesktopReportResponse::IsInitialized() const {
  return true;
}

void ChromeDesktopReportResponse::InternalSwap(ChromeDesktopReportResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ChromeDesktopReportResponse::GetTypeName() const {
  return "enterprise_management.ChromeDesktopReportResponse";
}


// ===================================================================

class ChromeOsUserReportResponse::_Internal {
 public:
};

ChromeOsUserReportResponse::ChromeOsUserReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ChromeOsUserReportResponse)
}
ChromeOsUserReportResponse::ChromeOsUserReportResponse(const ChromeOsUserReportResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ChromeOsUserReportResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ChromeOsUserReportResponse)
}

inline void ChromeOsUserReportResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

ChromeOsUserReportResponse::~ChromeOsUserReportResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.ChromeOsUserReportResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChromeOsUserReportResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ChromeOsUserReportResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChromeOsUserReportResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ChromeOsUserReportResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ChromeOsUserReportResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChromeOsUserReportResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ChromeOsUserReportResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ChromeOsUserReportResponse)
  return target;
}

size_t ChromeOsUserReportResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ChromeOsUserReportResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChromeOsUserReportResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChromeOsUserReportResponse*>(
      &from));
}

void ChromeOsUserReportResponse::MergeFrom(const ChromeOsUserReportResponse& from) {
  ChromeOsUserReportResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ChromeOsUserReportResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromeOsUserReportResponse::CopyFrom(const ChromeOsUserReportResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ChromeOsUserReportResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChromeOsUserReportResponse::IsInitialized() const {
  return true;
}

void ChromeOsUserReportResponse::InternalSwap(ChromeOsUserReportResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ChromeOsUserReportResponse::GetTypeName() const {
  return "enterprise_management.ChromeOsUserReportResponse";
}


// ===================================================================

class ChromeProfileReportResponse::_Internal {
 public:
};

ChromeProfileReportResponse::ChromeProfileReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ChromeProfileReportResponse)
}
ChromeProfileReportResponse::ChromeProfileReportResponse(const ChromeProfileReportResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ChromeProfileReportResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ChromeProfileReportResponse)
}

inline void ChromeProfileReportResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

ChromeProfileReportResponse::~ChromeProfileReportResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.ChromeProfileReportResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChromeProfileReportResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ChromeProfileReportResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChromeProfileReportResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ChromeProfileReportResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ChromeProfileReportResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChromeProfileReportResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ChromeProfileReportResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ChromeProfileReportResponse)
  return target;
}

size_t ChromeProfileReportResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ChromeProfileReportResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChromeProfileReportResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChromeProfileReportResponse*>(
      &from));
}

void ChromeProfileReportResponse::MergeFrom(const ChromeProfileReportResponse& from) {
  ChromeProfileReportResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ChromeProfileReportResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromeProfileReportResponse::CopyFrom(const ChromeProfileReportResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ChromeProfileReportResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChromeProfileReportResponse::IsInitialized() const {
  return true;
}

void ChromeProfileReportResponse::InternalSwap(ChromeProfileReportResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ChromeProfileReportResponse::GetTypeName() const {
  return "enterprise_management.ChromeProfileReportResponse";
}


// ===================================================================

class SessionStatusReportResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<SessionStatusReportResponse>()._impl_._has_bits_);
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SessionStatusReportResponse::SessionStatusReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.SessionStatusReportResponse)
}
SessionStatusReportResponse::SessionStatusReportResponse(const SessionStatusReportResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SessionStatusReportResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.error_code_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error_message()) {
    _this->_impl_.error_message_.Set(from._internal_error_message(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.error_code_ = from._impl_.error_code_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.SessionStatusReportResponse)
}

inline void SessionStatusReportResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.error_code_){0}
  };
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SessionStatusReportResponse::~SessionStatusReportResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.SessionStatusReportResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SessionStatusReportResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_message_.Destroy();
}

void SessionStatusReportResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SessionStatusReportResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.SessionStatusReportResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.error_message_.ClearNonDefaultToEmpty();
  }
  _impl_.error_code_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SessionStatusReportResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 error_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_error_code(&has_bits);
          _impl_.error_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string error_message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_error_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SessionStatusReportResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.SessionStatusReportResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 error_code = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_error_code(), target);
  }

  // optional string error_message = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_error_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.SessionStatusReportResponse)
  return target;
}

size_t SessionStatusReportResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.SessionStatusReportResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string error_message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error_message());
    }

    // optional int32 error_code = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_error_code());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SessionStatusReportResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SessionStatusReportResponse*>(
      &from));
}

void SessionStatusReportResponse::MergeFrom(const SessionStatusReportResponse& from) {
  SessionStatusReportResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.SessionStatusReportResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.error_code_ = from._impl_.error_code_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SessionStatusReportResponse::CopyFrom(const SessionStatusReportResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.SessionStatusReportResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionStatusReportResponse::IsInitialized() const {
  return true;
}

void SessionStatusReportResponse::InternalSwap(SessionStatusReportResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_message_, lhs_arena,
      &other->_impl_.error_message_, rhs_arena
  );
  swap(_impl_.error_code_, other->_impl_.error_code_);
}

std::string SessionStatusReportResponse::GetTypeName() const {
  return "enterprise_management.SessionStatusReportResponse";
}


// ===================================================================

class PrivateSetMembershipRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<PrivateSetMembershipRequest>()._impl_._has_bits_);
  static const ::enterprise_management::PrivateSetMembershipRlweRequest& rlwe_request(const PrivateSetMembershipRequest* msg);
  static void set_has_rlwe_request(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::enterprise_management::PrivateSetMembershipRlweRequest&
PrivateSetMembershipRequest::_Internal::rlwe_request(const PrivateSetMembershipRequest* msg) {
  return *msg->_impl_.rlwe_request_;
}
PrivateSetMembershipRequest::PrivateSetMembershipRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PrivateSetMembershipRequest)
}
PrivateSetMembershipRequest::PrivateSetMembershipRequest(const PrivateSetMembershipRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PrivateSetMembershipRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rlwe_request_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_rlwe_request()) {
    _this->_impl_.rlwe_request_ = new ::enterprise_management::PrivateSetMembershipRlweRequest(*from._impl_.rlwe_request_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PrivateSetMembershipRequest)
}

inline void PrivateSetMembershipRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rlwe_request_){nullptr}
  };
}

PrivateSetMembershipRequest::~PrivateSetMembershipRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.PrivateSetMembershipRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PrivateSetMembershipRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.rlwe_request_;
}

void PrivateSetMembershipRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PrivateSetMembershipRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PrivateSetMembershipRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.rlwe_request_ != nullptr);
    _impl_.rlwe_request_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PrivateSetMembershipRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.PrivateSetMembershipRlweRequest rlwe_request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_rlwe_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PrivateSetMembershipRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PrivateSetMembershipRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.PrivateSetMembershipRlweRequest rlwe_request = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::rlwe_request(this),
        _Internal::rlwe_request(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PrivateSetMembershipRequest)
  return target;
}

size_t PrivateSetMembershipRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PrivateSetMembershipRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.PrivateSetMembershipRlweRequest rlwe_request = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rlwe_request_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PrivateSetMembershipRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PrivateSetMembershipRequest*>(
      &from));
}

void PrivateSetMembershipRequest::MergeFrom(const PrivateSetMembershipRequest& from) {
  PrivateSetMembershipRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PrivateSetMembershipRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_rlwe_request()) {
    _this->_internal_mutable_rlwe_request()->::enterprise_management::PrivateSetMembershipRlweRequest::MergeFrom(
        from._internal_rlwe_request());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PrivateSetMembershipRequest::CopyFrom(const PrivateSetMembershipRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PrivateSetMembershipRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrivateSetMembershipRequest::IsInitialized() const {
  return true;
}

void PrivateSetMembershipRequest::InternalSwap(PrivateSetMembershipRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.rlwe_request_, other->_impl_.rlwe_request_);
}

std::string PrivateSetMembershipRequest::GetTypeName() const {
  return "enterprise_management.PrivateSetMembershipRequest";
}


// ===================================================================

class PrivateSetMembershipResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<PrivateSetMembershipResponse>()._impl_._has_bits_);
  static const ::enterprise_management::PrivateSetMembershipRlweResponse& rlwe_response(const PrivateSetMembershipResponse* msg);
  static void set_has_rlwe_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::enterprise_management::PrivateSetMembershipRlweResponse&
PrivateSetMembershipResponse::_Internal::rlwe_response(const PrivateSetMembershipResponse* msg) {
  return *msg->_impl_.rlwe_response_;
}
PrivateSetMembershipResponse::PrivateSetMembershipResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PrivateSetMembershipResponse)
}
PrivateSetMembershipResponse::PrivateSetMembershipResponse(const PrivateSetMembershipResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PrivateSetMembershipResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rlwe_response_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_rlwe_response()) {
    _this->_impl_.rlwe_response_ = new ::enterprise_management::PrivateSetMembershipRlweResponse(*from._impl_.rlwe_response_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PrivateSetMembershipResponse)
}

inline void PrivateSetMembershipResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rlwe_response_){nullptr}
  };
}

PrivateSetMembershipResponse::~PrivateSetMembershipResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.PrivateSetMembershipResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PrivateSetMembershipResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.rlwe_response_;
}

void PrivateSetMembershipResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PrivateSetMembershipResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PrivateSetMembershipResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.rlwe_response_ != nullptr);
    _impl_.rlwe_response_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PrivateSetMembershipResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.PrivateSetMembershipRlweResponse rlwe_response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_rlwe_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PrivateSetMembershipResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PrivateSetMembershipResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.PrivateSetMembershipRlweResponse rlwe_response = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::rlwe_response(this),
        _Internal::rlwe_response(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PrivateSetMembershipResponse)
  return target;
}

size_t PrivateSetMembershipResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PrivateSetMembershipResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.PrivateSetMembershipRlweResponse rlwe_response = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rlwe_response_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PrivateSetMembershipResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PrivateSetMembershipResponse*>(
      &from));
}

void PrivateSetMembershipResponse::MergeFrom(const PrivateSetMembershipResponse& from) {
  PrivateSetMembershipResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PrivateSetMembershipResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_rlwe_response()) {
    _this->_internal_mutable_rlwe_response()->::enterprise_management::PrivateSetMembershipRlweResponse::MergeFrom(
        from._internal_rlwe_response());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PrivateSetMembershipResponse::CopyFrom(const PrivateSetMembershipResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PrivateSetMembershipResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrivateSetMembershipResponse::IsInitialized() const {
  return true;
}

void PrivateSetMembershipResponse::InternalSwap(PrivateSetMembershipResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.rlwe_response_, other->_impl_.rlwe_response_);
}

std::string PrivateSetMembershipResponse::GetTypeName() const {
  return "enterprise_management.PrivateSetMembershipResponse";
}


// ===================================================================

class PrivateSetMembershipRlweRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<PrivateSetMembershipRlweRequest>()._impl_._has_bits_);
  static const ::private_membership::rlwe::PrivateMembershipRlweOprfRequest& oprf_request(const PrivateSetMembershipRlweRequest* msg);
  static void set_has_oprf_request(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::private_membership::rlwe::PrivateMembershipRlweQueryRequest& query_request(const PrivateSetMembershipRlweRequest* msg);
  static void set_has_query_request(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::private_membership::rlwe::PrivateMembershipRlweOprfRequest&
PrivateSetMembershipRlweRequest::_Internal::oprf_request(const PrivateSetMembershipRlweRequest* msg) {
  return *msg->_impl_.oprf_request_;
}
const ::private_membership::rlwe::PrivateMembershipRlweQueryRequest&
PrivateSetMembershipRlweRequest::_Internal::query_request(const PrivateSetMembershipRlweRequest* msg) {
  return *msg->_impl_.query_request_;
}
void PrivateSetMembershipRlweRequest::clear_oprf_request() {
  if (_impl_.oprf_request_ != nullptr) _impl_.oprf_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void PrivateSetMembershipRlweRequest::clear_query_request() {
  if (_impl_.query_request_ != nullptr) _impl_.query_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
PrivateSetMembershipRlweRequest::PrivateSetMembershipRlweRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PrivateSetMembershipRlweRequest)
}
PrivateSetMembershipRlweRequest::PrivateSetMembershipRlweRequest(const PrivateSetMembershipRlweRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PrivateSetMembershipRlweRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.oprf_request_){nullptr}
    , decltype(_impl_.query_request_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_oprf_request()) {
    _this->_impl_.oprf_request_ = new ::private_membership::rlwe::PrivateMembershipRlweOprfRequest(*from._impl_.oprf_request_);
  }
  if (from._internal_has_query_request()) {
    _this->_impl_.query_request_ = new ::private_membership::rlwe::PrivateMembershipRlweQueryRequest(*from._impl_.query_request_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PrivateSetMembershipRlweRequest)
}

inline void PrivateSetMembershipRlweRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.oprf_request_){nullptr}
    , decltype(_impl_.query_request_){nullptr}
  };
}

PrivateSetMembershipRlweRequest::~PrivateSetMembershipRlweRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.PrivateSetMembershipRlweRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PrivateSetMembershipRlweRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.oprf_request_;
  if (this != internal_default_instance()) delete _impl_.query_request_;
}

void PrivateSetMembershipRlweRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PrivateSetMembershipRlweRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PrivateSetMembershipRlweRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.oprf_request_ != nullptr);
      _impl_.oprf_request_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.query_request_ != nullptr);
      _impl_.query_request_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PrivateSetMembershipRlweRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .private_membership.rlwe.PrivateMembershipRlweOprfRequest oprf_request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_oprf_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .private_membership.rlwe.PrivateMembershipRlweQueryRequest query_request = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_query_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PrivateSetMembershipRlweRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PrivateSetMembershipRlweRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .private_membership.rlwe.PrivateMembershipRlweOprfRequest oprf_request = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::oprf_request(this),
        _Internal::oprf_request(this).GetCachedSize(), target, stream);
  }

  // optional .private_membership.rlwe.PrivateMembershipRlweQueryRequest query_request = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::query_request(this),
        _Internal::query_request(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PrivateSetMembershipRlweRequest)
  return target;
}

size_t PrivateSetMembershipRlweRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PrivateSetMembershipRlweRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .private_membership.rlwe.PrivateMembershipRlweOprfRequest oprf_request = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oprf_request_);
    }

    // optional .private_membership.rlwe.PrivateMembershipRlweQueryRequest query_request = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.query_request_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PrivateSetMembershipRlweRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PrivateSetMembershipRlweRequest*>(
      &from));
}

void PrivateSetMembershipRlweRequest::MergeFrom(const PrivateSetMembershipRlweRequest& from) {
  PrivateSetMembershipRlweRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PrivateSetMembershipRlweRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_oprf_request()->::private_membership::rlwe::PrivateMembershipRlweOprfRequest::MergeFrom(
          from._internal_oprf_request());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_query_request()->::private_membership::rlwe::PrivateMembershipRlweQueryRequest::MergeFrom(
          from._internal_query_request());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PrivateSetMembershipRlweRequest::CopyFrom(const PrivateSetMembershipRlweRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PrivateSetMembershipRlweRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrivateSetMembershipRlweRequest::IsInitialized() const {
  return true;
}

void PrivateSetMembershipRlweRequest::InternalSwap(PrivateSetMembershipRlweRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PrivateSetMembershipRlweRequest, _impl_.query_request_)
      + sizeof(PrivateSetMembershipRlweRequest::_impl_.query_request_)
      - PROTOBUF_FIELD_OFFSET(PrivateSetMembershipRlweRequest, _impl_.oprf_request_)>(
          reinterpret_cast<char*>(&_impl_.oprf_request_),
          reinterpret_cast<char*>(&other->_impl_.oprf_request_));
}

std::string PrivateSetMembershipRlweRequest::GetTypeName() const {
  return "enterprise_management.PrivateSetMembershipRlweRequest";
}


// ===================================================================

class PrivateSetMembershipRlweResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<PrivateSetMembershipRlweResponse>()._impl_._has_bits_);
  static const ::private_membership::rlwe::PrivateMembershipRlweOprfResponse& oprf_response(const PrivateSetMembershipRlweResponse* msg);
  static void set_has_oprf_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::private_membership::rlwe::PrivateMembershipRlweQueryResponse& query_response(const PrivateSetMembershipRlweResponse* msg);
  static void set_has_query_response(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::private_membership::rlwe::PrivateMembershipRlweOprfResponse&
PrivateSetMembershipRlweResponse::_Internal::oprf_response(const PrivateSetMembershipRlweResponse* msg) {
  return *msg->_impl_.oprf_response_;
}
const ::private_membership::rlwe::PrivateMembershipRlweQueryResponse&
PrivateSetMembershipRlweResponse::_Internal::query_response(const PrivateSetMembershipRlweResponse* msg) {
  return *msg->_impl_.query_response_;
}
void PrivateSetMembershipRlweResponse::clear_oprf_response() {
  if (_impl_.oprf_response_ != nullptr) _impl_.oprf_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void PrivateSetMembershipRlweResponse::clear_query_response() {
  if (_impl_.query_response_ != nullptr) _impl_.query_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
PrivateSetMembershipRlweResponse::PrivateSetMembershipRlweResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PrivateSetMembershipRlweResponse)
}
PrivateSetMembershipRlweResponse::PrivateSetMembershipRlweResponse(const PrivateSetMembershipRlweResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PrivateSetMembershipRlweResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.oprf_response_){nullptr}
    , decltype(_impl_.query_response_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_oprf_response()) {
    _this->_impl_.oprf_response_ = new ::private_membership::rlwe::PrivateMembershipRlweOprfResponse(*from._impl_.oprf_response_);
  }
  if (from._internal_has_query_response()) {
    _this->_impl_.query_response_ = new ::private_membership::rlwe::PrivateMembershipRlweQueryResponse(*from._impl_.query_response_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PrivateSetMembershipRlweResponse)
}

inline void PrivateSetMembershipRlweResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.oprf_response_){nullptr}
    , decltype(_impl_.query_response_){nullptr}
  };
}

PrivateSetMembershipRlweResponse::~PrivateSetMembershipRlweResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.PrivateSetMembershipRlweResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PrivateSetMembershipRlweResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.oprf_response_;
  if (this != internal_default_instance()) delete _impl_.query_response_;
}

void PrivateSetMembershipRlweResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PrivateSetMembershipRlweResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PrivateSetMembershipRlweResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.oprf_response_ != nullptr);
      _impl_.oprf_response_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.query_response_ != nullptr);
      _impl_.query_response_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PrivateSetMembershipRlweResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .private_membership.rlwe.PrivateMembershipRlweOprfResponse oprf_response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_oprf_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .private_membership.rlwe.PrivateMembershipRlweQueryResponse query_response = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_query_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PrivateSetMembershipRlweResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PrivateSetMembershipRlweResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .private_membership.rlwe.PrivateMembershipRlweOprfResponse oprf_response = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::oprf_response(this),
        _Internal::oprf_response(this).GetCachedSize(), target, stream);
  }

  // optional .private_membership.rlwe.PrivateMembershipRlweQueryResponse query_response = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::query_response(this),
        _Internal::query_response(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PrivateSetMembershipRlweResponse)
  return target;
}

size_t PrivateSetMembershipRlweResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PrivateSetMembershipRlweResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .private_membership.rlwe.PrivateMembershipRlweOprfResponse oprf_response = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oprf_response_);
    }

    // optional .private_membership.rlwe.PrivateMembershipRlweQueryResponse query_response = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.query_response_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PrivateSetMembershipRlweResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PrivateSetMembershipRlweResponse*>(
      &from));
}

void PrivateSetMembershipRlweResponse::MergeFrom(const PrivateSetMembershipRlweResponse& from) {
  PrivateSetMembershipRlweResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PrivateSetMembershipRlweResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_oprf_response()->::private_membership::rlwe::PrivateMembershipRlweOprfResponse::MergeFrom(
          from._internal_oprf_response());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_query_response()->::private_membership::rlwe::PrivateMembershipRlweQueryResponse::MergeFrom(
          from._internal_query_response());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PrivateSetMembershipRlweResponse::CopyFrom(const PrivateSetMembershipRlweResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PrivateSetMembershipRlweResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrivateSetMembershipRlweResponse::IsInitialized() const {
  return true;
}

void PrivateSetMembershipRlweResponse::InternalSwap(PrivateSetMembershipRlweResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PrivateSetMembershipRlweResponse, _impl_.query_response_)
      + sizeof(PrivateSetMembershipRlweResponse::_impl_.query_response_)
      - PROTOBUF_FIELD_OFFSET(PrivateSetMembershipRlweResponse, _impl_.oprf_response_)>(
          reinterpret_cast<char*>(&_impl_.oprf_response_),
          reinterpret_cast<char*>(&other->_impl_.oprf_response_));
}

std::string PrivateSetMembershipRlweResponse::GetTypeName() const {
  return "enterprise_management.PrivateSetMembershipRlweResponse";
}


// ===================================================================

class DeviceAutoEnrollmentRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceAutoEnrollmentRequest>()._impl_._has_bits_);
  static void set_has_remainder(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_modulus(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_enrollment_check_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

DeviceAutoEnrollmentRequest::DeviceAutoEnrollmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceAutoEnrollmentRequest)
}
DeviceAutoEnrollmentRequest::DeviceAutoEnrollmentRequest(const DeviceAutoEnrollmentRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceAutoEnrollmentRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.remainder_){}
    , decltype(_impl_.modulus_){}
    , decltype(_impl_.enrollment_check_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.remainder_, &from._impl_.remainder_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.enrollment_check_type_) -
    reinterpret_cast<char*>(&_impl_.remainder_)) + sizeof(_impl_.enrollment_check_type_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceAutoEnrollmentRequest)
}

inline void DeviceAutoEnrollmentRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.remainder_){int64_t{0}}
    , decltype(_impl_.modulus_){int64_t{0}}
    , decltype(_impl_.enrollment_check_type_){1}
  };
}

DeviceAutoEnrollmentRequest::~DeviceAutoEnrollmentRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceAutoEnrollmentRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceAutoEnrollmentRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceAutoEnrollmentRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceAutoEnrollmentRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceAutoEnrollmentRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.remainder_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.modulus_) -
        reinterpret_cast<char*>(&_impl_.remainder_)) + sizeof(_impl_.modulus_));
    _impl_.enrollment_check_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceAutoEnrollmentRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 remainder = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_remainder(&has_bits);
          _impl_.remainder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 modulus = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_modulus(&has_bits);
          _impl_.modulus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceAutoEnrollmentRequest.EnrollmentCheckType enrollment_check_type = 3 [default = ENROLLMENT_CHECK_TYPE_FRE];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType_IsValid(val))) {
            _internal_set_enrollment_check_type(static_cast<::enterprise_management::DeviceAutoEnrollmentRequest_EnrollmentCheckType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceAutoEnrollmentRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceAutoEnrollmentRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 remainder = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_remainder(), target);
  }

  // optional int64 modulus = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_modulus(), target);
  }

  // optional .enterprise_management.DeviceAutoEnrollmentRequest.EnrollmentCheckType enrollment_check_type = 3 [default = ENROLLMENT_CHECK_TYPE_FRE];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_enrollment_check_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceAutoEnrollmentRequest)
  return target;
}

size_t DeviceAutoEnrollmentRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceAutoEnrollmentRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 remainder = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_remainder());
    }

    // optional int64 modulus = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_modulus());
    }

    // optional .enterprise_management.DeviceAutoEnrollmentRequest.EnrollmentCheckType enrollment_check_type = 3 [default = ENROLLMENT_CHECK_TYPE_FRE];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_enrollment_check_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceAutoEnrollmentRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceAutoEnrollmentRequest*>(
      &from));
}

void DeviceAutoEnrollmentRequest::MergeFrom(const DeviceAutoEnrollmentRequest& from) {
  DeviceAutoEnrollmentRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceAutoEnrollmentRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.remainder_ = from._impl_.remainder_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.modulus_ = from._impl_.modulus_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.enrollment_check_type_ = from._impl_.enrollment_check_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceAutoEnrollmentRequest::CopyFrom(const DeviceAutoEnrollmentRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceAutoEnrollmentRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceAutoEnrollmentRequest::IsInitialized() const {
  return true;
}

void DeviceAutoEnrollmentRequest::InternalSwap(DeviceAutoEnrollmentRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceAutoEnrollmentRequest, _impl_.modulus_)
      + sizeof(DeviceAutoEnrollmentRequest::_impl_.modulus_)
      - PROTOBUF_FIELD_OFFSET(DeviceAutoEnrollmentRequest, _impl_.remainder_)>(
          reinterpret_cast<char*>(&_impl_.remainder_),
          reinterpret_cast<char*>(&other->_impl_.remainder_));
  swap(_impl_.enrollment_check_type_, other->_impl_.enrollment_check_type_);
}

std::string DeviceAutoEnrollmentRequest::GetTypeName() const {
  return "enterprise_management.DeviceAutoEnrollmentRequest";
}


// ===================================================================

class DeviceAutoEnrollmentResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceAutoEnrollmentResponse>()._impl_._has_bits_);
  static void set_has_expected_modulus(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceAutoEnrollmentResponse::DeviceAutoEnrollmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceAutoEnrollmentResponse)
}
DeviceAutoEnrollmentResponse::DeviceAutoEnrollmentResponse(const DeviceAutoEnrollmentResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceAutoEnrollmentResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hashes_){from._impl_.hashes_}
    , decltype(_impl_.expected_modulus_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.expected_modulus_ = from._impl_.expected_modulus_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceAutoEnrollmentResponse)
}

inline void DeviceAutoEnrollmentResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hashes_){arena}
    , decltype(_impl_.expected_modulus_){int64_t{0}}
  };
}

DeviceAutoEnrollmentResponse::~DeviceAutoEnrollmentResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceAutoEnrollmentResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceAutoEnrollmentResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hashes_.~RepeatedPtrField();
}

void DeviceAutoEnrollmentResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceAutoEnrollmentResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceAutoEnrollmentResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hashes_.Clear();
  _impl_.expected_modulus_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceAutoEnrollmentResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 expected_modulus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_expected_modulus(&has_bits);
          _impl_.expected_modulus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes hashes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_hashes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceAutoEnrollmentResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceAutoEnrollmentResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 expected_modulus = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_expected_modulus(), target);
  }

  // repeated bytes hashes = 2;
  for (int i = 0, n = this->_internal_hashes_size(); i < n; i++) {
    const auto& s = this->_internal_hashes(i);
    target = stream->WriteBytes(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceAutoEnrollmentResponse)
  return target;
}

size_t DeviceAutoEnrollmentResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceAutoEnrollmentResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes hashes = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.hashes_.size());
  for (int i = 0, n = _impl_.hashes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.hashes_.Get(i));
  }

  // optional int64 expected_modulus = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_expected_modulus());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceAutoEnrollmentResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceAutoEnrollmentResponse*>(
      &from));
}

void DeviceAutoEnrollmentResponse::MergeFrom(const DeviceAutoEnrollmentResponse& from) {
  DeviceAutoEnrollmentResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceAutoEnrollmentResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.hashes_.MergeFrom(from._impl_.hashes_);
  if (from._internal_has_expected_modulus()) {
    _this->_internal_set_expected_modulus(from._internal_expected_modulus());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceAutoEnrollmentResponse::CopyFrom(const DeviceAutoEnrollmentResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceAutoEnrollmentResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceAutoEnrollmentResponse::IsInitialized() const {
  return true;
}

void DeviceAutoEnrollmentResponse::InternalSwap(DeviceAutoEnrollmentResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.hashes_.InternalSwap(&other->_impl_.hashes_);
  swap(_impl_.expected_modulus_, other->_impl_.expected_modulus_);
}

std::string DeviceAutoEnrollmentResponse::GetTypeName() const {
  return "enterprise_management.DeviceAutoEnrollmentResponse";
}


// ===================================================================

class DeviceStateRetrievalRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceStateRetrievalRequest>()._impl_._has_bits_);
  static void set_has_server_backed_state_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceStateRetrievalRequest::DeviceStateRetrievalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceStateRetrievalRequest)
}
DeviceStateRetrievalRequest::DeviceStateRetrievalRequest(const DeviceStateRetrievalRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceStateRetrievalRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.server_backed_state_key_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.server_backed_state_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_backed_state_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_server_backed_state_key()) {
    _this->_impl_.server_backed_state_key_.Set(from._internal_server_backed_state_key(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceStateRetrievalRequest)
}

inline void DeviceStateRetrievalRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.server_backed_state_key_){}
  };
  _impl_.server_backed_state_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_backed_state_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceStateRetrievalRequest::~DeviceStateRetrievalRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceStateRetrievalRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceStateRetrievalRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.server_backed_state_key_.Destroy();
}

void DeviceStateRetrievalRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceStateRetrievalRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceStateRetrievalRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.server_backed_state_key_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceStateRetrievalRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes server_backed_state_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_server_backed_state_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceStateRetrievalRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceStateRetrievalRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes server_backed_state_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_server_backed_state_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceStateRetrievalRequest)
  return target;
}

size_t DeviceStateRetrievalRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceStateRetrievalRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes server_backed_state_key = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_server_backed_state_key());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceStateRetrievalRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceStateRetrievalRequest*>(
      &from));
}

void DeviceStateRetrievalRequest::MergeFrom(const DeviceStateRetrievalRequest& from) {
  DeviceStateRetrievalRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceStateRetrievalRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_server_backed_state_key()) {
    _this->_internal_set_server_backed_state_key(from._internal_server_backed_state_key());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceStateRetrievalRequest::CopyFrom(const DeviceStateRetrievalRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceStateRetrievalRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceStateRetrievalRequest::IsInitialized() const {
  return true;
}

void DeviceStateRetrievalRequest::InternalSwap(DeviceStateRetrievalRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.server_backed_state_key_, lhs_arena,
      &other->_impl_.server_backed_state_key_, rhs_arena
  );
}

std::string DeviceStateRetrievalRequest::GetTypeName() const {
  return "enterprise_management.DeviceStateRetrievalRequest";
}


// ===================================================================

class DeviceStateKeyUpdateRequest::_Internal {
 public:
};

DeviceStateKeyUpdateRequest::DeviceStateKeyUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceStateKeyUpdateRequest)
}
DeviceStateKeyUpdateRequest::DeviceStateKeyUpdateRequest(const DeviceStateKeyUpdateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceStateKeyUpdateRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.server_backed_state_keys_){from._impl_.server_backed_state_keys_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceStateKeyUpdateRequest)
}

inline void DeviceStateKeyUpdateRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.server_backed_state_keys_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DeviceStateKeyUpdateRequest::~DeviceStateKeyUpdateRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceStateKeyUpdateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceStateKeyUpdateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.server_backed_state_keys_.~RepeatedPtrField();
}

void DeviceStateKeyUpdateRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceStateKeyUpdateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceStateKeyUpdateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.server_backed_state_keys_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceStateKeyUpdateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes server_backed_state_keys = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_server_backed_state_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceStateKeyUpdateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceStateKeyUpdateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes server_backed_state_keys = 1;
  for (int i = 0, n = this->_internal_server_backed_state_keys_size(); i < n; i++) {
    const auto& s = this->_internal_server_backed_state_keys(i);
    target = stream->WriteBytes(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceStateKeyUpdateRequest)
  return target;
}

size_t DeviceStateKeyUpdateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceStateKeyUpdateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes server_backed_state_keys = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.server_backed_state_keys_.size());
  for (int i = 0, n = _impl_.server_backed_state_keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.server_backed_state_keys_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceStateKeyUpdateRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceStateKeyUpdateRequest*>(
      &from));
}

void DeviceStateKeyUpdateRequest::MergeFrom(const DeviceStateKeyUpdateRequest& from) {
  DeviceStateKeyUpdateRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceStateKeyUpdateRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.server_backed_state_keys_.MergeFrom(from._impl_.server_backed_state_keys_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceStateKeyUpdateRequest::CopyFrom(const DeviceStateKeyUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceStateKeyUpdateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceStateKeyUpdateRequest::IsInitialized() const {
  return true;
}

void DeviceStateKeyUpdateRequest::InternalSwap(DeviceStateKeyUpdateRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.server_backed_state_keys_.InternalSwap(&other->_impl_.server_backed_state_keys_);
}

std::string DeviceStateKeyUpdateRequest::GetTypeName() const {
  return "enterprise_management.DeviceStateKeyUpdateRequest";
}


// ===================================================================

class DeviceStateRetrievalResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceStateRetrievalResponse>()._impl_._has_bits_);
  static void set_has_restore_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_management_domain(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::enterprise_management::DisabledState& disabled_state(const DeviceStateRetrievalResponse* msg);
  static void set_has_disabled_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::enterprise_management::DeviceInitialEnrollmentStateResponse& initial_state_response(const DeviceStateRetrievalResponse* msg);
  static void set_has_initial_state_response(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::enterprise_management::LicenseType& license_type(const DeviceStateRetrievalResponse* msg);
  static void set_has_license_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::enterprise_management::DisabledState&
DeviceStateRetrievalResponse::_Internal::disabled_state(const DeviceStateRetrievalResponse* msg) {
  return *msg->_impl_.disabled_state_;
}
const ::enterprise_management::DeviceInitialEnrollmentStateResponse&
DeviceStateRetrievalResponse::_Internal::initial_state_response(const DeviceStateRetrievalResponse* msg) {
  return *msg->_impl_.initial_state_response_;
}
const ::enterprise_management::LicenseType&
DeviceStateRetrievalResponse::_Internal::license_type(const DeviceStateRetrievalResponse* msg) {
  return *msg->_impl_.license_type_;
}
DeviceStateRetrievalResponse::DeviceStateRetrievalResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceStateRetrievalResponse)
}
DeviceStateRetrievalResponse::DeviceStateRetrievalResponse(const DeviceStateRetrievalResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceStateRetrievalResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.management_domain_){}
    , decltype(_impl_.disabled_state_){nullptr}
    , decltype(_impl_.initial_state_response_){nullptr}
    , decltype(_impl_.license_type_){nullptr}
    , decltype(_impl_.restore_mode_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.management_domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.management_domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_management_domain()) {
    _this->_impl_.management_domain_.Set(from._internal_management_domain(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_disabled_state()) {
    _this->_impl_.disabled_state_ = new ::enterprise_management::DisabledState(*from._impl_.disabled_state_);
  }
  if (from._internal_has_initial_state_response()) {
    _this->_impl_.initial_state_response_ = new ::enterprise_management::DeviceInitialEnrollmentStateResponse(*from._impl_.initial_state_response_);
  }
  if (from._internal_has_license_type()) {
    _this->_impl_.license_type_ = new ::enterprise_management::LicenseType(*from._impl_.license_type_);
  }
  _this->_impl_.restore_mode_ = from._impl_.restore_mode_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceStateRetrievalResponse)
}

inline void DeviceStateRetrievalResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.management_domain_){}
    , decltype(_impl_.disabled_state_){nullptr}
    , decltype(_impl_.initial_state_response_){nullptr}
    , decltype(_impl_.license_type_){nullptr}
    , decltype(_impl_.restore_mode_){0}
  };
  _impl_.management_domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.management_domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceStateRetrievalResponse::~DeviceStateRetrievalResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceStateRetrievalResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceStateRetrievalResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.management_domain_.Destroy();
  if (this != internal_default_instance()) delete _impl_.disabled_state_;
  if (this != internal_default_instance()) delete _impl_.initial_state_response_;
  if (this != internal_default_instance()) delete _impl_.license_type_;
}

void DeviceStateRetrievalResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceStateRetrievalResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceStateRetrievalResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.management_domain_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.disabled_state_ != nullptr);
      _impl_.disabled_state_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.initial_state_response_ != nullptr);
      _impl_.initial_state_response_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.license_type_ != nullptr);
      _impl_.license_type_->Clear();
    }
  }
  _impl_.restore_mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceStateRetrievalResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DeviceStateRetrievalResponse.RestoreMode restore_mode = 1 [default = RESTORE_MODE_NONE];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceStateRetrievalResponse_RestoreMode_IsValid(val))) {
            _internal_set_restore_mode(static_cast<::enterprise_management::DeviceStateRetrievalResponse_RestoreMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string management_domain = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_management_domain();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DisabledState disabled_state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_disabled_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceInitialEnrollmentStateResponse initial_state_response = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_initial_state_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.LicenseType license_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_license_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceStateRetrievalResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceStateRetrievalResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DeviceStateRetrievalResponse.RestoreMode restore_mode = 1 [default = RESTORE_MODE_NONE];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_restore_mode(), target);
  }

  // optional string management_domain = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_management_domain(), target);
  }

  // optional .enterprise_management.DisabledState disabled_state = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::disabled_state(this),
        _Internal::disabled_state(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceInitialEnrollmentStateResponse initial_state_response = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::initial_state_response(this),
        _Internal::initial_state_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.LicenseType license_type = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::license_type(this),
        _Internal::license_type(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceStateRetrievalResponse)
  return target;
}

size_t DeviceStateRetrievalResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceStateRetrievalResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string management_domain = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_management_domain());
    }

    // optional .enterprise_management.DisabledState disabled_state = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.disabled_state_);
    }

    // optional .enterprise_management.DeviceInitialEnrollmentStateResponse initial_state_response = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.initial_state_response_);
    }

    // optional .enterprise_management.LicenseType license_type = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.license_type_);
    }

    // optional .enterprise_management.DeviceStateRetrievalResponse.RestoreMode restore_mode = 1 [default = RESTORE_MODE_NONE];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_restore_mode());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceStateRetrievalResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceStateRetrievalResponse*>(
      &from));
}

void DeviceStateRetrievalResponse::MergeFrom(const DeviceStateRetrievalResponse& from) {
  DeviceStateRetrievalResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceStateRetrievalResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_management_domain(from._internal_management_domain());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_disabled_state()->::enterprise_management::DisabledState::MergeFrom(
          from._internal_disabled_state());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_initial_state_response()->::enterprise_management::DeviceInitialEnrollmentStateResponse::MergeFrom(
          from._internal_initial_state_response());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_license_type()->::enterprise_management::LicenseType::MergeFrom(
          from._internal_license_type());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.restore_mode_ = from._impl_.restore_mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceStateRetrievalResponse::CopyFrom(const DeviceStateRetrievalResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceStateRetrievalResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceStateRetrievalResponse::IsInitialized() const {
  return true;
}

void DeviceStateRetrievalResponse::InternalSwap(DeviceStateRetrievalResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.management_domain_, lhs_arena,
      &other->_impl_.management_domain_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceStateRetrievalResponse, _impl_.restore_mode_)
      + sizeof(DeviceStateRetrievalResponse::_impl_.restore_mode_)
      - PROTOBUF_FIELD_OFFSET(DeviceStateRetrievalResponse, _impl_.disabled_state_)>(
          reinterpret_cast<char*>(&_impl_.disabled_state_),
          reinterpret_cast<char*>(&other->_impl_.disabled_state_));
}

std::string DeviceStateRetrievalResponse::GetTypeName() const {
  return "enterprise_management.DeviceStateRetrievalResponse";
}


// ===================================================================

class DeviceInitialEnrollmentStateRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceInitialEnrollmentStateRequest>()._impl_._has_bits_);
  static void set_has_serial_number(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_brand_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DeviceInitialEnrollmentStateRequest::DeviceInitialEnrollmentStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceInitialEnrollmentStateRequest)
}
DeviceInitialEnrollmentStateRequest::DeviceInitialEnrollmentStateRequest(const DeviceInitialEnrollmentStateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceInitialEnrollmentStateRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.serial_number_){}
    , decltype(_impl_.brand_code_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.serial_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serial_number()) {
    _this->_impl_.serial_number_.Set(from._internal_serial_number(), 
      _this->GetArenaForAllocation());
  }
  _impl_.brand_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.brand_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_brand_code()) {
    _this->_impl_.brand_code_.Set(from._internal_brand_code(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceInitialEnrollmentStateRequest)
}

inline void DeviceInitialEnrollmentStateRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.serial_number_){}
    , decltype(_impl_.brand_code_){}
  };
  _impl_.serial_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.brand_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.brand_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceInitialEnrollmentStateRequest::~DeviceInitialEnrollmentStateRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceInitialEnrollmentStateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceInitialEnrollmentStateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.serial_number_.Destroy();
  _impl_.brand_code_.Destroy();
}

void DeviceInitialEnrollmentStateRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceInitialEnrollmentStateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceInitialEnrollmentStateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.serial_number_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.brand_code_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceInitialEnrollmentStateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string serial_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_serial_number();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string brand_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_brand_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceInitialEnrollmentStateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceInitialEnrollmentStateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string serial_number = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_serial_number(), target);
  }

  // optional string brand_code = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_brand_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceInitialEnrollmentStateRequest)
  return target;
}

size_t DeviceInitialEnrollmentStateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceInitialEnrollmentStateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string serial_number = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_serial_number());
    }

    // optional string brand_code = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_brand_code());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceInitialEnrollmentStateRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceInitialEnrollmentStateRequest*>(
      &from));
}

void DeviceInitialEnrollmentStateRequest::MergeFrom(const DeviceInitialEnrollmentStateRequest& from) {
  DeviceInitialEnrollmentStateRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceInitialEnrollmentStateRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_serial_number(from._internal_serial_number());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_brand_code(from._internal_brand_code());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceInitialEnrollmentStateRequest::CopyFrom(const DeviceInitialEnrollmentStateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceInitialEnrollmentStateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceInitialEnrollmentStateRequest::IsInitialized() const {
  return true;
}

void DeviceInitialEnrollmentStateRequest::InternalSwap(DeviceInitialEnrollmentStateRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.serial_number_, lhs_arena,
      &other->_impl_.serial_number_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.brand_code_, lhs_arena,
      &other->_impl_.brand_code_, rhs_arena
  );
}

std::string DeviceInitialEnrollmentStateRequest::GetTypeName() const {
  return "enterprise_management.DeviceInitialEnrollmentStateRequest";
}


// ===================================================================

class DeviceInitialEnrollmentStateResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceInitialEnrollmentStateResponse>()._impl_._has_bits_);
  static void set_has_initial_enrollment_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_management_domain(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_license_packaged_with_device(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::enterprise_management::DisabledState& disabled_state(const DeviceInitialEnrollmentStateResponse* msg);
  static void set_has_disabled_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_license_packaging_sku(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_assigned_upgrade_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::enterprise_management::DisabledState&
DeviceInitialEnrollmentStateResponse::_Internal::disabled_state(const DeviceInitialEnrollmentStateResponse* msg) {
  return *msg->_impl_.disabled_state_;
}
DeviceInitialEnrollmentStateResponse::DeviceInitialEnrollmentStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceInitialEnrollmentStateResponse)
}
DeviceInitialEnrollmentStateResponse::DeviceInitialEnrollmentStateResponse(const DeviceInitialEnrollmentStateResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceInitialEnrollmentStateResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.management_domain_){}
    , decltype(_impl_.disabled_state_){nullptr}
    , decltype(_impl_.initial_enrollment_mode_){}
    , decltype(_impl_.is_license_packaged_with_device_){}
    , decltype(_impl_.license_packaging_sku_){}
    , decltype(_impl_.assigned_upgrade_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.management_domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.management_domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_management_domain()) {
    _this->_impl_.management_domain_.Set(from._internal_management_domain(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_disabled_state()) {
    _this->_impl_.disabled_state_ = new ::enterprise_management::DisabledState(*from._impl_.disabled_state_);
  }
  ::memcpy(&_impl_.initial_enrollment_mode_, &from._impl_.initial_enrollment_mode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.assigned_upgrade_type_) -
    reinterpret_cast<char*>(&_impl_.initial_enrollment_mode_)) + sizeof(_impl_.assigned_upgrade_type_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceInitialEnrollmentStateResponse)
}

inline void DeviceInitialEnrollmentStateResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.management_domain_){}
    , decltype(_impl_.disabled_state_){nullptr}
    , decltype(_impl_.initial_enrollment_mode_){0}
    , decltype(_impl_.is_license_packaged_with_device_){false}
    , decltype(_impl_.license_packaging_sku_){0}
    , decltype(_impl_.assigned_upgrade_type_){0}
  };
  _impl_.management_domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.management_domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceInitialEnrollmentStateResponse::~DeviceInitialEnrollmentStateResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceInitialEnrollmentStateResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceInitialEnrollmentStateResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.management_domain_.Destroy();
  if (this != internal_default_instance()) delete _impl_.disabled_state_;
}

void DeviceInitialEnrollmentStateResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceInitialEnrollmentStateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceInitialEnrollmentStateResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.management_domain_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.disabled_state_ != nullptr);
      _impl_.disabled_state_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.initial_enrollment_mode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.assigned_upgrade_type_) -
        reinterpret_cast<char*>(&_impl_.initial_enrollment_mode_)) + sizeof(_impl_.assigned_upgrade_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceInitialEnrollmentStateResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DeviceInitialEnrollmentStateResponse.InitialEnrollmentMode initial_enrollment_mode = 1 [default = INITIAL_ENROLLMENT_MODE_NONE];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode_IsValid(val))) {
            _internal_set_initial_enrollment_mode(static_cast<::enterprise_management::DeviceInitialEnrollmentStateResponse_InitialEnrollmentMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string management_domain = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_management_domain();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_license_packaged_with_device = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_license_packaged_with_device(&has_bits);
          _impl_.is_license_packaged_with_device_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DisabledState disabled_state = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_disabled_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceInitialEnrollmentStateResponse.LicensePackagingSKU license_packaging_sku = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceInitialEnrollmentStateResponse_LicensePackagingSKU_IsValid(val))) {
            _internal_set_license_packaging_sku(static_cast<::enterprise_management::DeviceInitialEnrollmentStateResponse_LicensePackagingSKU>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceInitialEnrollmentStateResponse.AssignedUpgradeType assigned_upgrade_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceInitialEnrollmentStateResponse_AssignedUpgradeType_IsValid(val))) {
            _internal_set_assigned_upgrade_type(static_cast<::enterprise_management::DeviceInitialEnrollmentStateResponse_AssignedUpgradeType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceInitialEnrollmentStateResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceInitialEnrollmentStateResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DeviceInitialEnrollmentStateResponse.InitialEnrollmentMode initial_enrollment_mode = 1 [default = INITIAL_ENROLLMENT_MODE_NONE];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_initial_enrollment_mode(), target);
  }

  // optional string management_domain = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_management_domain(), target);
  }

  // optional bool is_license_packaged_with_device = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_license_packaged_with_device(), target);
  }

  // optional .enterprise_management.DisabledState disabled_state = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::disabled_state(this),
        _Internal::disabled_state(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceInitialEnrollmentStateResponse.LicensePackagingSKU license_packaging_sku = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_license_packaging_sku(), target);
  }

  // optional .enterprise_management.DeviceInitialEnrollmentStateResponse.AssignedUpgradeType assigned_upgrade_type = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_assigned_upgrade_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceInitialEnrollmentStateResponse)
  return target;
}

size_t DeviceInitialEnrollmentStateResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceInitialEnrollmentStateResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string management_domain = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_management_domain());
    }

    // optional .enterprise_management.DisabledState disabled_state = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.disabled_state_);
    }

    // optional .enterprise_management.DeviceInitialEnrollmentStateResponse.InitialEnrollmentMode initial_enrollment_mode = 1 [default = INITIAL_ENROLLMENT_MODE_NONE];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_initial_enrollment_mode());
    }

    // optional bool is_license_packaged_with_device = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional .enterprise_management.DeviceInitialEnrollmentStateResponse.LicensePackagingSKU license_packaging_sku = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_license_packaging_sku());
    }

    // optional .enterprise_management.DeviceInitialEnrollmentStateResponse.AssignedUpgradeType assigned_upgrade_type = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_assigned_upgrade_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceInitialEnrollmentStateResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceInitialEnrollmentStateResponse*>(
      &from));
}

void DeviceInitialEnrollmentStateResponse::MergeFrom(const DeviceInitialEnrollmentStateResponse& from) {
  DeviceInitialEnrollmentStateResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceInitialEnrollmentStateResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_management_domain(from._internal_management_domain());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_disabled_state()->::enterprise_management::DisabledState::MergeFrom(
          from._internal_disabled_state());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.initial_enrollment_mode_ = from._impl_.initial_enrollment_mode_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_license_packaged_with_device_ = from._impl_.is_license_packaged_with_device_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.license_packaging_sku_ = from._impl_.license_packaging_sku_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.assigned_upgrade_type_ = from._impl_.assigned_upgrade_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceInitialEnrollmentStateResponse::CopyFrom(const DeviceInitialEnrollmentStateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceInitialEnrollmentStateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceInitialEnrollmentStateResponse::IsInitialized() const {
  return true;
}

void DeviceInitialEnrollmentStateResponse::InternalSwap(DeviceInitialEnrollmentStateResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.management_domain_, lhs_arena,
      &other->_impl_.management_domain_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceInitialEnrollmentStateResponse, _impl_.assigned_upgrade_type_)
      + sizeof(DeviceInitialEnrollmentStateResponse::_impl_.assigned_upgrade_type_)
      - PROTOBUF_FIELD_OFFSET(DeviceInitialEnrollmentStateResponse, _impl_.disabled_state_)>(
          reinterpret_cast<char*>(&_impl_.disabled_state_),
          reinterpret_cast<char*>(&other->_impl_.disabled_state_));
}

std::string DeviceInitialEnrollmentStateResponse::GetTypeName() const {
  return "enterprise_management.DeviceInitialEnrollmentStateResponse";
}


// ===================================================================

class DevicePairingRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<DevicePairingRequest>()._impl_._has_bits_);
  static void set_has_host_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_controller_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DevicePairingRequest::DevicePairingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DevicePairingRequest)
}
DevicePairingRequest::DevicePairingRequest(const DevicePairingRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DevicePairingRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.host_device_id_){}
    , decltype(_impl_.controller_device_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.host_device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_host_device_id()) {
    _this->_impl_.host_device_id_.Set(from._internal_host_device_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.controller_device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.controller_device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_controller_device_id()) {
    _this->_impl_.controller_device_id_.Set(from._internal_controller_device_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DevicePairingRequest)
}

inline void DevicePairingRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.host_device_id_){}
    , decltype(_impl_.controller_device_id_){}
  };
  _impl_.host_device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.controller_device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.controller_device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DevicePairingRequest::~DevicePairingRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.DevicePairingRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DevicePairingRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.host_device_id_.Destroy();
  _impl_.controller_device_id_.Destroy();
}

void DevicePairingRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DevicePairingRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DevicePairingRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.host_device_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.controller_device_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DevicePairingRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string host_device_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_host_device_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string controller_device_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_controller_device_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DevicePairingRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DevicePairingRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string host_device_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_host_device_id(), target);
  }

  // optional string controller_device_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_controller_device_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DevicePairingRequest)
  return target;
}

size_t DevicePairingRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DevicePairingRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string host_device_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_host_device_id());
    }

    // optional string controller_device_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_controller_device_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DevicePairingRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DevicePairingRequest*>(
      &from));
}

void DevicePairingRequest::MergeFrom(const DevicePairingRequest& from) {
  DevicePairingRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DevicePairingRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_host_device_id(from._internal_host_device_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_controller_device_id(from._internal_controller_device_id());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DevicePairingRequest::CopyFrom(const DevicePairingRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DevicePairingRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DevicePairingRequest::IsInitialized() const {
  return true;
}

void DevicePairingRequest::InternalSwap(DevicePairingRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.host_device_id_, lhs_arena,
      &other->_impl_.host_device_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.controller_device_id_, lhs_arena,
      &other->_impl_.controller_device_id_, rhs_arena
  );
}

std::string DevicePairingRequest::GetTypeName() const {
  return "enterprise_management.DevicePairingRequest";
}


// ===================================================================

class DevicePairingResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<DevicePairingResponse>()._impl_._has_bits_);
  static void set_has_status_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DevicePairingResponse::DevicePairingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DevicePairingResponse)
}
DevicePairingResponse::DevicePairingResponse(const DevicePairingResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DevicePairingResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_code_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.status_code_ = from._impl_.status_code_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DevicePairingResponse)
}

inline void DevicePairingResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_code_){1}
  };
}

DevicePairingResponse::~DevicePairingResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.DevicePairingResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DevicePairingResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DevicePairingResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DevicePairingResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DevicePairingResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.status_code_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DevicePairingResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DevicePairingResponse.StatusCode status_code = 1 [default = FAILED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DevicePairingResponse_StatusCode_IsValid(val))) {
            _internal_set_status_code(static_cast<::enterprise_management::DevicePairingResponse_StatusCode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DevicePairingResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DevicePairingResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DevicePairingResponse.StatusCode status_code = 1 [default = FAILED];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_status_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DevicePairingResponse)
  return target;
}

size_t DevicePairingResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DevicePairingResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.DevicePairingResponse.StatusCode status_code = 1 [default = FAILED];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status_code());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DevicePairingResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DevicePairingResponse*>(
      &from));
}

void DevicePairingResponse::MergeFrom(const DevicePairingResponse& from) {
  DevicePairingResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DevicePairingResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_status_code()) {
    _this->_internal_set_status_code(from._internal_status_code());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DevicePairingResponse::CopyFrom(const DevicePairingResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DevicePairingResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DevicePairingResponse::IsInitialized() const {
  return true;
}

void DevicePairingResponse::InternalSwap(DevicePairingResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.status_code_, other->_impl_.status_code_);
}

std::string DevicePairingResponse::GetTypeName() const {
  return "enterprise_management.DevicePairingResponse";
}


// ===================================================================

class CheckDevicePairingRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CheckDevicePairingRequest>()._impl_._has_bits_);
  static void set_has_host_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_controller_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CheckDevicePairingRequest::CheckDevicePairingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CheckDevicePairingRequest)
}
CheckDevicePairingRequest::CheckDevicePairingRequest(const CheckDevicePairingRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CheckDevicePairingRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.host_device_id_){}
    , decltype(_impl_.controller_device_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.host_device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_host_device_id()) {
    _this->_impl_.host_device_id_.Set(from._internal_host_device_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.controller_device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.controller_device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_controller_device_id()) {
    _this->_impl_.controller_device_id_.Set(from._internal_controller_device_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CheckDevicePairingRequest)
}

inline void CheckDevicePairingRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.host_device_id_){}
    , decltype(_impl_.controller_device_id_){}
  };
  _impl_.host_device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.controller_device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.controller_device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CheckDevicePairingRequest::~CheckDevicePairingRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.CheckDevicePairingRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckDevicePairingRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.host_device_id_.Destroy();
  _impl_.controller_device_id_.Destroy();
}

void CheckDevicePairingRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckDevicePairingRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CheckDevicePairingRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.host_device_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.controller_device_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CheckDevicePairingRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string host_device_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_host_device_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string controller_device_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_controller_device_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckDevicePairingRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CheckDevicePairingRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string host_device_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_host_device_id(), target);
  }

  // optional string controller_device_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_controller_device_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CheckDevicePairingRequest)
  return target;
}

size_t CheckDevicePairingRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CheckDevicePairingRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string host_device_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_host_device_id());
    }

    // optional string controller_device_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_controller_device_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CheckDevicePairingRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CheckDevicePairingRequest*>(
      &from));
}

void CheckDevicePairingRequest::MergeFrom(const CheckDevicePairingRequest& from) {
  CheckDevicePairingRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CheckDevicePairingRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_host_device_id(from._internal_host_device_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_controller_device_id(from._internal_controller_device_id());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CheckDevicePairingRequest::CopyFrom(const CheckDevicePairingRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CheckDevicePairingRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckDevicePairingRequest::IsInitialized() const {
  return true;
}

void CheckDevicePairingRequest::InternalSwap(CheckDevicePairingRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.host_device_id_, lhs_arena,
      &other->_impl_.host_device_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.controller_device_id_, lhs_arena,
      &other->_impl_.controller_device_id_, rhs_arena
  );
}

std::string CheckDevicePairingRequest::GetTypeName() const {
  return "enterprise_management.CheckDevicePairingRequest";
}


// ===================================================================

class CheckDevicePairingResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CheckDevicePairingResponse>()._impl_._has_bits_);
  static void set_has_status_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CheckDevicePairingResponse::CheckDevicePairingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CheckDevicePairingResponse)
}
CheckDevicePairingResponse::CheckDevicePairingResponse(const CheckDevicePairingResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CheckDevicePairingResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_code_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.status_code_ = from._impl_.status_code_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CheckDevicePairingResponse)
}

inline void CheckDevicePairingResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_code_){1}
  };
}

CheckDevicePairingResponse::~CheckDevicePairingResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.CheckDevicePairingResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckDevicePairingResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CheckDevicePairingResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckDevicePairingResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CheckDevicePairingResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.status_code_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CheckDevicePairingResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.CheckDevicePairingResponse.StatusCode status_code = 1 [default = NOT_PAIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::CheckDevicePairingResponse_StatusCode_IsValid(val))) {
            _internal_set_status_code(static_cast<::enterprise_management::CheckDevicePairingResponse_StatusCode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckDevicePairingResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CheckDevicePairingResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.CheckDevicePairingResponse.StatusCode status_code = 1 [default = NOT_PAIRED];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_status_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CheckDevicePairingResponse)
  return target;
}

size_t CheckDevicePairingResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CheckDevicePairingResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.CheckDevicePairingResponse.StatusCode status_code = 1 [default = NOT_PAIRED];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status_code());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CheckDevicePairingResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CheckDevicePairingResponse*>(
      &from));
}

void CheckDevicePairingResponse::MergeFrom(const CheckDevicePairingResponse& from) {
  CheckDevicePairingResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CheckDevicePairingResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_status_code()) {
    _this->_internal_set_status_code(from._internal_status_code());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CheckDevicePairingResponse::CopyFrom(const CheckDevicePairingResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CheckDevicePairingResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckDevicePairingResponse::IsInitialized() const {
  return true;
}

void CheckDevicePairingResponse::InternalSwap(CheckDevicePairingResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.status_code_, other->_impl_.status_code_);
}

std::string CheckDevicePairingResponse::GetTypeName() const {
  return "enterprise_management.CheckDevicePairingResponse";
}


// ===================================================================

class RemoteCommand::_Internal {
 public:
  using HasBits = decltype(std::declval<RemoteCommand>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_command_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_age_of_command(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_target_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

RemoteCommand::RemoteCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.RemoteCommand)
}
RemoteCommand::RemoteCommand(const RemoteCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RemoteCommand* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.payload_){}
    , decltype(_impl_.target_device_id_){}
    , decltype(_impl_.command_id_){}
    , decltype(_impl_.age_of_command_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_payload()) {
    _this->_impl_.payload_.Set(from._internal_payload(), 
      _this->GetArenaForAllocation());
  }
  _impl_.target_device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_target_device_id()) {
    _this->_impl_.target_device_id_.Set(from._internal_target_device_id(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.command_id_, &from._impl_.command_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.command_id_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.RemoteCommand)
}

inline void RemoteCommand::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.payload_){}
    , decltype(_impl_.target_device_id_){}
    , decltype(_impl_.command_id_){int64_t{0}}
    , decltype(_impl_.age_of_command_){int64_t{0}}
    , decltype(_impl_.type_){-1}
  };
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.target_device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RemoteCommand::~RemoteCommand() {
  // @@protoc_insertion_point(destructor:enterprise_management.RemoteCommand)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoteCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.payload_.Destroy();
  _impl_.target_device_id_.Destroy();
}

void RemoteCommand::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoteCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.RemoteCommand)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.payload_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.target_device_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.command_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.age_of_command_) -
        reinterpret_cast<char*>(&_impl_.command_id_)) + sizeof(_impl_.age_of_command_));
    _impl_.type_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RemoteCommand::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.RemoteCommand.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::RemoteCommand_Type_IsValid(val))) {
            _internal_set_type(static_cast<::enterprise_management::RemoteCommand_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 command_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_command_id(&has_bits);
          _impl_.command_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 age_of_command = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_age_of_command(&has_bits);
          _impl_.age_of_command_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string payload = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string target_device_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_target_device_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoteCommand::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.RemoteCommand)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.RemoteCommand.Type type = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional int64 command_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_command_id(), target);
  }

  // optional int64 age_of_command = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_age_of_command(), target);
  }

  // optional string payload = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_payload(), target);
  }

  // optional string target_device_id = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_target_device_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.RemoteCommand)
  return target;
}

size_t RemoteCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.RemoteCommand)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string payload = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_payload());
    }

    // optional string target_device_id = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_target_device_id());
    }

    // optional int64 command_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_command_id());
    }

    // optional int64 age_of_command = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_age_of_command());
    }

    // optional .enterprise_management.RemoteCommand.Type type = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RemoteCommand::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RemoteCommand*>(
      &from));
}

void RemoteCommand::MergeFrom(const RemoteCommand& from) {
  RemoteCommand* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.RemoteCommand)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_payload(from._internal_payload());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_target_device_id(from._internal_target_device_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.command_id_ = from._impl_.command_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.age_of_command_ = from._impl_.age_of_command_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RemoteCommand::CopyFrom(const RemoteCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.RemoteCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoteCommand::IsInitialized() const {
  return true;
}

void RemoteCommand::InternalSwap(RemoteCommand* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.payload_, lhs_arena,
      &other->_impl_.payload_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.target_device_id_, lhs_arena,
      &other->_impl_.target_device_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemoteCommand, _impl_.age_of_command_)
      + sizeof(RemoteCommand::_impl_.age_of_command_)
      - PROTOBUF_FIELD_OFFSET(RemoteCommand, _impl_.command_id_)>(
          reinterpret_cast<char*>(&_impl_.command_id_),
          reinterpret_cast<char*>(&other->_impl_.command_id_));
  swap(_impl_.type_, other->_impl_.type_);
}

std::string RemoteCommand::GetTypeName() const {
  return "enterprise_management.RemoteCommand";
}


// ===================================================================

class RemoteCommandResult::_Internal {
 public:
  using HasBits = decltype(std::declval<RemoteCommandResult>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_command_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RemoteCommandResult::RemoteCommandResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.RemoteCommandResult)
}
RemoteCommandResult::RemoteCommandResult(const RemoteCommandResult& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RemoteCommandResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.payload_){}
    , decltype(_impl_.command_id_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_payload()) {
    _this->_impl_.payload_.Set(from._internal_payload(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.command_id_, &from._impl_.command_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.result_) -
    reinterpret_cast<char*>(&_impl_.command_id_)) + sizeof(_impl_.result_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.RemoteCommandResult)
}

inline void RemoteCommandResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.payload_){}
    , decltype(_impl_.command_id_){int64_t{0}}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , decltype(_impl_.result_){0}
  };
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RemoteCommandResult::~RemoteCommandResult() {
  // @@protoc_insertion_point(destructor:enterprise_management.RemoteCommandResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoteCommandResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.payload_.Destroy();
}

void RemoteCommandResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoteCommandResult::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.RemoteCommandResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.payload_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.command_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.result_) -
        reinterpret_cast<char*>(&_impl_.command_id_)) + sizeof(_impl_.result_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RemoteCommandResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.RemoteCommandResult.ResultType result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::RemoteCommandResult_ResultType_IsValid(val))) {
            _internal_set_result(static_cast<::enterprise_management::RemoteCommandResult_ResultType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 command_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_command_id(&has_bits);
          _impl_.command_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string payload = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoteCommandResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.RemoteCommandResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.RemoteCommandResult.ResultType result = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_result(), target);
  }

  // optional int64 command_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_command_id(), target);
  }

  // optional int64 timestamp = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_timestamp(), target);
  }

  // optional string payload = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_payload(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.RemoteCommandResult)
  return target;
}

size_t RemoteCommandResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.RemoteCommandResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string payload = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_payload());
    }

    // optional int64 command_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_command_id());
    }

    // optional int64 timestamp = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
    }

    // optional .enterprise_management.RemoteCommandResult.ResultType result = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_result());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RemoteCommandResult::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RemoteCommandResult*>(
      &from));
}

void RemoteCommandResult::MergeFrom(const RemoteCommandResult& from) {
  RemoteCommandResult* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.RemoteCommandResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_payload(from._internal_payload());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.command_id_ = from._impl_.command_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.result_ = from._impl_.result_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RemoteCommandResult::CopyFrom(const RemoteCommandResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.RemoteCommandResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoteCommandResult::IsInitialized() const {
  return true;
}

void RemoteCommandResult::InternalSwap(RemoteCommandResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.payload_, lhs_arena,
      &other->_impl_.payload_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemoteCommandResult, _impl_.result_)
      + sizeof(RemoteCommandResult::_impl_.result_)
      - PROTOBUF_FIELD_OFFSET(RemoteCommandResult, _impl_.command_id_)>(
          reinterpret_cast<char*>(&_impl_.command_id_),
          reinterpret_cast<char*>(&other->_impl_.command_id_));
}

std::string RemoteCommandResult::GetTypeName() const {
  return "enterprise_management.RemoteCommandResult";
}


// ===================================================================

class DeviceRemoteCommandRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceRemoteCommandRequest>()._impl_._has_bits_);
  static void set_has_last_command_unique_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_send_secure_commands(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_signature_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

DeviceRemoteCommandRequest::DeviceRemoteCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceRemoteCommandRequest)
}
DeviceRemoteCommandRequest::DeviceRemoteCommandRequest(const DeviceRemoteCommandRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceRemoteCommandRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_results_){from._impl_.command_results_}
    , decltype(_impl_.last_command_unique_id_){}
    , decltype(_impl_.send_secure_commands_){}
    , decltype(_impl_.signature_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.last_command_unique_id_, &from._impl_.last_command_unique_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.signature_type_) -
    reinterpret_cast<char*>(&_impl_.last_command_unique_id_)) + sizeof(_impl_.signature_type_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceRemoteCommandRequest)
}

inline void DeviceRemoteCommandRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_results_){arena}
    , decltype(_impl_.last_command_unique_id_){int64_t{0}}
    , decltype(_impl_.send_secure_commands_){false}
    , decltype(_impl_.signature_type_){0}
  };
}

DeviceRemoteCommandRequest::~DeviceRemoteCommandRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceRemoteCommandRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceRemoteCommandRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.command_results_.~RepeatedPtrField();
}

void DeviceRemoteCommandRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceRemoteCommandRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceRemoteCommandRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.command_results_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.last_command_unique_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.signature_type_) -
        reinterpret_cast<char*>(&_impl_.last_command_unique_id_)) + sizeof(_impl_.signature_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceRemoteCommandRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 last_command_unique_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_last_command_unique_id(&has_bits);
          _impl_.last_command_unique_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.RemoteCommandResult command_results = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_command_results(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool send_secure_commands = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_send_secure_commands(&has_bits);
          _impl_.send_secure_commands_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyFetchRequest.SignatureType signature_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::PolicyFetchRequest_SignatureType_IsValid(val))) {
            _internal_set_signature_type(static_cast<::enterprise_management::PolicyFetchRequest_SignatureType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceRemoteCommandRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceRemoteCommandRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 last_command_unique_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_last_command_unique_id(), target);
  }

  // repeated .enterprise_management.RemoteCommandResult command_results = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_command_results_size()); i < n; i++) {
    const auto& repfield = this->_internal_command_results(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool send_secure_commands = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_send_secure_commands(), target);
  }

  // optional .enterprise_management.PolicyFetchRequest.SignatureType signature_type = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_signature_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceRemoteCommandRequest)
  return target;
}

size_t DeviceRemoteCommandRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceRemoteCommandRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.RemoteCommandResult command_results = 2;
  total_size += 1UL * this->_internal_command_results_size();
  for (const auto& msg : this->_impl_.command_results_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 last_command_unique_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_command_unique_id());
    }

    // optional bool send_secure_commands = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional .enterprise_management.PolicyFetchRequest.SignatureType signature_type = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_signature_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceRemoteCommandRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceRemoteCommandRequest*>(
      &from));
}

void DeviceRemoteCommandRequest::MergeFrom(const DeviceRemoteCommandRequest& from) {
  DeviceRemoteCommandRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceRemoteCommandRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.command_results_.MergeFrom(from._impl_.command_results_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.last_command_unique_id_ = from._impl_.last_command_unique_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.send_secure_commands_ = from._impl_.send_secure_commands_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.signature_type_ = from._impl_.signature_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceRemoteCommandRequest::CopyFrom(const DeviceRemoteCommandRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceRemoteCommandRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceRemoteCommandRequest::IsInitialized() const {
  return true;
}

void DeviceRemoteCommandRequest::InternalSwap(DeviceRemoteCommandRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.command_results_.InternalSwap(&other->_impl_.command_results_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceRemoteCommandRequest, _impl_.signature_type_)
      + sizeof(DeviceRemoteCommandRequest::_impl_.signature_type_)
      - PROTOBUF_FIELD_OFFSET(DeviceRemoteCommandRequest, _impl_.last_command_unique_id_)>(
          reinterpret_cast<char*>(&_impl_.last_command_unique_id_),
          reinterpret_cast<char*>(&other->_impl_.last_command_unique_id_));
}

std::string DeviceRemoteCommandRequest::GetTypeName() const {
  return "enterprise_management.DeviceRemoteCommandRequest";
}


// ===================================================================

class DeviceRemoteCommandResponse::_Internal {
 public:
};

DeviceRemoteCommandResponse::DeviceRemoteCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceRemoteCommandResponse)
}
DeviceRemoteCommandResponse::DeviceRemoteCommandResponse(const DeviceRemoteCommandResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceRemoteCommandResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.commands_){from._impl_.commands_}
    , decltype(_impl_.secure_commands_){from._impl_.secure_commands_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceRemoteCommandResponse)
}

inline void DeviceRemoteCommandResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.commands_){arena}
    , decltype(_impl_.secure_commands_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DeviceRemoteCommandResponse::~DeviceRemoteCommandResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceRemoteCommandResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceRemoteCommandResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.commands_.~RepeatedPtrField();
  _impl_.secure_commands_.~RepeatedPtrField();
}

void DeviceRemoteCommandResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceRemoteCommandResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceRemoteCommandResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.commands_.Clear();
  _impl_.secure_commands_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceRemoteCommandResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .enterprise_management.RemoteCommand commands = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_commands(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.SignedData secure_commands = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_secure_commands(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceRemoteCommandResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceRemoteCommandResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .enterprise_management.RemoteCommand commands = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_commands_size()); i < n; i++) {
    const auto& repfield = this->_internal_commands(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.SignedData secure_commands = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_secure_commands_size()); i < n; i++) {
    const auto& repfield = this->_internal_secure_commands(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceRemoteCommandResponse)
  return target;
}

size_t DeviceRemoteCommandResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceRemoteCommandResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.RemoteCommand commands = 1;
  total_size += 1UL * this->_internal_commands_size();
  for (const auto& msg : this->_impl_.commands_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.SignedData secure_commands = 2;
  total_size += 1UL * this->_internal_secure_commands_size();
  for (const auto& msg : this->_impl_.secure_commands_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceRemoteCommandResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceRemoteCommandResponse*>(
      &from));
}

void DeviceRemoteCommandResponse::MergeFrom(const DeviceRemoteCommandResponse& from) {
  DeviceRemoteCommandResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceRemoteCommandResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.commands_.MergeFrom(from._impl_.commands_);
  _this->_impl_.secure_commands_.MergeFrom(from._impl_.secure_commands_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceRemoteCommandResponse::CopyFrom(const DeviceRemoteCommandResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceRemoteCommandResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceRemoteCommandResponse::IsInitialized() const {
  return true;
}

void DeviceRemoteCommandResponse::InternalSwap(DeviceRemoteCommandResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.commands_.InternalSwap(&other->_impl_.commands_);
  _impl_.secure_commands_.InternalSwap(&other->_impl_.secure_commands_);
}

std::string DeviceRemoteCommandResponse::GetTypeName() const {
  return "enterprise_management.DeviceRemoteCommandResponse";
}


// ===================================================================

class DeviceAttributeUpdatePermissionRequest::_Internal {
 public:
};

DeviceAttributeUpdatePermissionRequest::DeviceAttributeUpdatePermissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceAttributeUpdatePermissionRequest)
}
DeviceAttributeUpdatePermissionRequest::DeviceAttributeUpdatePermissionRequest(const DeviceAttributeUpdatePermissionRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceAttributeUpdatePermissionRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceAttributeUpdatePermissionRequest)
}

inline void DeviceAttributeUpdatePermissionRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

DeviceAttributeUpdatePermissionRequest::~DeviceAttributeUpdatePermissionRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceAttributeUpdatePermissionRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceAttributeUpdatePermissionRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceAttributeUpdatePermissionRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceAttributeUpdatePermissionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceAttributeUpdatePermissionRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* DeviceAttributeUpdatePermissionRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceAttributeUpdatePermissionRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceAttributeUpdatePermissionRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceAttributeUpdatePermissionRequest)
  return target;
}

size_t DeviceAttributeUpdatePermissionRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceAttributeUpdatePermissionRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceAttributeUpdatePermissionRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceAttributeUpdatePermissionRequest*>(
      &from));
}

void DeviceAttributeUpdatePermissionRequest::MergeFrom(const DeviceAttributeUpdatePermissionRequest& from) {
  DeviceAttributeUpdatePermissionRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceAttributeUpdatePermissionRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceAttributeUpdatePermissionRequest::CopyFrom(const DeviceAttributeUpdatePermissionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceAttributeUpdatePermissionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceAttributeUpdatePermissionRequest::IsInitialized() const {
  return true;
}

void DeviceAttributeUpdatePermissionRequest::InternalSwap(DeviceAttributeUpdatePermissionRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string DeviceAttributeUpdatePermissionRequest::GetTypeName() const {
  return "enterprise_management.DeviceAttributeUpdatePermissionRequest";
}


// ===================================================================

class DeviceAttributeUpdatePermissionResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceAttributeUpdatePermissionResponse>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceAttributeUpdatePermissionResponse::DeviceAttributeUpdatePermissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceAttributeUpdatePermissionResponse)
}
DeviceAttributeUpdatePermissionResponse::DeviceAttributeUpdatePermissionResponse(const DeviceAttributeUpdatePermissionResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceAttributeUpdatePermissionResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceAttributeUpdatePermissionResponse)
}

inline void DeviceAttributeUpdatePermissionResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0}
  };
}

DeviceAttributeUpdatePermissionResponse::~DeviceAttributeUpdatePermissionResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceAttributeUpdatePermissionResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceAttributeUpdatePermissionResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceAttributeUpdatePermissionResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceAttributeUpdatePermissionResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceAttributeUpdatePermissionResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceAttributeUpdatePermissionResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DeviceAttributeUpdatePermissionResponse.ResultType result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType_IsValid(val))) {
            _internal_set_result(static_cast<::enterprise_management::DeviceAttributeUpdatePermissionResponse_ResultType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceAttributeUpdatePermissionResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceAttributeUpdatePermissionResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DeviceAttributeUpdatePermissionResponse.ResultType result = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceAttributeUpdatePermissionResponse)
  return target;
}

size_t DeviceAttributeUpdatePermissionResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceAttributeUpdatePermissionResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.DeviceAttributeUpdatePermissionResponse.ResultType result = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_result());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceAttributeUpdatePermissionResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceAttributeUpdatePermissionResponse*>(
      &from));
}

void DeviceAttributeUpdatePermissionResponse::MergeFrom(const DeviceAttributeUpdatePermissionResponse& from) {
  DeviceAttributeUpdatePermissionResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceAttributeUpdatePermissionResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceAttributeUpdatePermissionResponse::CopyFrom(const DeviceAttributeUpdatePermissionResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceAttributeUpdatePermissionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceAttributeUpdatePermissionResponse::IsInitialized() const {
  return true;
}

void DeviceAttributeUpdatePermissionResponse::InternalSwap(DeviceAttributeUpdatePermissionResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

std::string DeviceAttributeUpdatePermissionResponse::GetTypeName() const {
  return "enterprise_management.DeviceAttributeUpdatePermissionResponse";
}


// ===================================================================

class DeviceAttributeUpdateRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceAttributeUpdateRequest>()._impl_._has_bits_);
  static void set_has_asset_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DeviceAttributeUpdateRequest::DeviceAttributeUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceAttributeUpdateRequest)
}
DeviceAttributeUpdateRequest::DeviceAttributeUpdateRequest(const DeviceAttributeUpdateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceAttributeUpdateRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.asset_id_){}
    , decltype(_impl_.location_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.asset_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_asset_id()) {
    _this->_impl_.asset_id_.Set(from._internal_asset_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_location()) {
    _this->_impl_.location_.Set(from._internal_location(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceAttributeUpdateRequest)
}

inline void DeviceAttributeUpdateRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.asset_id_){}
    , decltype(_impl_.location_){}
  };
  _impl_.asset_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.asset_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceAttributeUpdateRequest::~DeviceAttributeUpdateRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceAttributeUpdateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceAttributeUpdateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.asset_id_.Destroy();
  _impl_.location_.Destroy();
}

void DeviceAttributeUpdateRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceAttributeUpdateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceAttributeUpdateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.asset_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.location_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceAttributeUpdateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string asset_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_asset_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string location = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_location();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceAttributeUpdateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceAttributeUpdateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string asset_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_asset_id(), target);
  }

  // optional string location = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_location(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceAttributeUpdateRequest)
  return target;
}

size_t DeviceAttributeUpdateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceAttributeUpdateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string asset_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_asset_id());
    }

    // optional string location = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_location());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceAttributeUpdateRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceAttributeUpdateRequest*>(
      &from));
}

void DeviceAttributeUpdateRequest::MergeFrom(const DeviceAttributeUpdateRequest& from) {
  DeviceAttributeUpdateRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceAttributeUpdateRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_asset_id(from._internal_asset_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_location(from._internal_location());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceAttributeUpdateRequest::CopyFrom(const DeviceAttributeUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceAttributeUpdateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceAttributeUpdateRequest::IsInitialized() const {
  return true;
}

void DeviceAttributeUpdateRequest::InternalSwap(DeviceAttributeUpdateRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.asset_id_, lhs_arena,
      &other->_impl_.asset_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.location_, lhs_arena,
      &other->_impl_.location_, rhs_arena
  );
}

std::string DeviceAttributeUpdateRequest::GetTypeName() const {
  return "enterprise_management.DeviceAttributeUpdateRequest";
}


// ===================================================================

class DeviceAttributeUpdateResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceAttributeUpdateResponse>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceAttributeUpdateResponse::DeviceAttributeUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceAttributeUpdateResponse)
}
DeviceAttributeUpdateResponse::DeviceAttributeUpdateResponse(const DeviceAttributeUpdateResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceAttributeUpdateResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceAttributeUpdateResponse)
}

inline void DeviceAttributeUpdateResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0}
  };
}

DeviceAttributeUpdateResponse::~DeviceAttributeUpdateResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceAttributeUpdateResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceAttributeUpdateResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceAttributeUpdateResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceAttributeUpdateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceAttributeUpdateResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceAttributeUpdateResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DeviceAttributeUpdateResponse.ResultType result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceAttributeUpdateResponse_ResultType_IsValid(val))) {
            _internal_set_result(static_cast<::enterprise_management::DeviceAttributeUpdateResponse_ResultType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceAttributeUpdateResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceAttributeUpdateResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DeviceAttributeUpdateResponse.ResultType result = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceAttributeUpdateResponse)
  return target;
}

size_t DeviceAttributeUpdateResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceAttributeUpdateResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.DeviceAttributeUpdateResponse.ResultType result = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_result());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceAttributeUpdateResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceAttributeUpdateResponse*>(
      &from));
}

void DeviceAttributeUpdateResponse::MergeFrom(const DeviceAttributeUpdateResponse& from) {
  DeviceAttributeUpdateResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceAttributeUpdateResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceAttributeUpdateResponse::CopyFrom(const DeviceAttributeUpdateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceAttributeUpdateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceAttributeUpdateResponse::IsInitialized() const {
  return true;
}

void DeviceAttributeUpdateResponse::InternalSwap(DeviceAttributeUpdateResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

std::string DeviceAttributeUpdateResponse::GetTypeName() const {
  return "enterprise_management.DeviceAttributeUpdateResponse";
}


// ===================================================================

class GcmIdUpdateRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<GcmIdUpdateRequest>()._impl_._has_bits_);
  static void set_has_gcm_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

GcmIdUpdateRequest::GcmIdUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.GcmIdUpdateRequest)
}
GcmIdUpdateRequest::GcmIdUpdateRequest(const GcmIdUpdateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GcmIdUpdateRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gcm_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.gcm_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gcm_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gcm_id()) {
    _this->_impl_.gcm_id_.Set(from._internal_gcm_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.GcmIdUpdateRequest)
}

inline void GcmIdUpdateRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gcm_id_){}
  };
  _impl_.gcm_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gcm_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GcmIdUpdateRequest::~GcmIdUpdateRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.GcmIdUpdateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GcmIdUpdateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gcm_id_.Destroy();
}

void GcmIdUpdateRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GcmIdUpdateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.GcmIdUpdateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.gcm_id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GcmIdUpdateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string gcm_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_gcm_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GcmIdUpdateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.GcmIdUpdateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string gcm_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_gcm_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.GcmIdUpdateRequest)
  return target;
}

size_t GcmIdUpdateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.GcmIdUpdateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string gcm_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_gcm_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GcmIdUpdateRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GcmIdUpdateRequest*>(
      &from));
}

void GcmIdUpdateRequest::MergeFrom(const GcmIdUpdateRequest& from) {
  GcmIdUpdateRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.GcmIdUpdateRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_gcm_id()) {
    _this->_internal_set_gcm_id(from._internal_gcm_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GcmIdUpdateRequest::CopyFrom(const GcmIdUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.GcmIdUpdateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GcmIdUpdateRequest::IsInitialized() const {
  return true;
}

void GcmIdUpdateRequest::InternalSwap(GcmIdUpdateRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gcm_id_, lhs_arena,
      &other->_impl_.gcm_id_, rhs_arena
  );
}

std::string GcmIdUpdateRequest::GetTypeName() const {
  return "enterprise_management.GcmIdUpdateRequest";
}


// ===================================================================

class GcmIdUpdateResponse::_Internal {
 public:
};

GcmIdUpdateResponse::GcmIdUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.GcmIdUpdateResponse)
}
GcmIdUpdateResponse::GcmIdUpdateResponse(const GcmIdUpdateResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GcmIdUpdateResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.GcmIdUpdateResponse)
}

inline void GcmIdUpdateResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

GcmIdUpdateResponse::~GcmIdUpdateResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.GcmIdUpdateResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GcmIdUpdateResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GcmIdUpdateResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GcmIdUpdateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.GcmIdUpdateResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* GcmIdUpdateResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GcmIdUpdateResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.GcmIdUpdateResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.GcmIdUpdateResponse)
  return target;
}

size_t GcmIdUpdateResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.GcmIdUpdateResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GcmIdUpdateResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GcmIdUpdateResponse*>(
      &from));
}

void GcmIdUpdateResponse::MergeFrom(const GcmIdUpdateResponse& from) {
  GcmIdUpdateResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.GcmIdUpdateResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GcmIdUpdateResponse::CopyFrom(const GcmIdUpdateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.GcmIdUpdateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GcmIdUpdateResponse::IsInitialized() const {
  return true;
}

void GcmIdUpdateResponse::InternalSwap(GcmIdUpdateResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string GcmIdUpdateResponse::GetTypeName() const {
  return "enterprise_management.GcmIdUpdateResponse";
}


// ===================================================================

class CheckAndroidManagementRequest::_Internal {
 public:
};

CheckAndroidManagementRequest::CheckAndroidManagementRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CheckAndroidManagementRequest)
}
CheckAndroidManagementRequest::CheckAndroidManagementRequest(const CheckAndroidManagementRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CheckAndroidManagementRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CheckAndroidManagementRequest)
}

inline void CheckAndroidManagementRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

CheckAndroidManagementRequest::~CheckAndroidManagementRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.CheckAndroidManagementRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckAndroidManagementRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CheckAndroidManagementRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckAndroidManagementRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CheckAndroidManagementRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CheckAndroidManagementRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckAndroidManagementRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CheckAndroidManagementRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CheckAndroidManagementRequest)
  return target;
}

size_t CheckAndroidManagementRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CheckAndroidManagementRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CheckAndroidManagementRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CheckAndroidManagementRequest*>(
      &from));
}

void CheckAndroidManagementRequest::MergeFrom(const CheckAndroidManagementRequest& from) {
  CheckAndroidManagementRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CheckAndroidManagementRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CheckAndroidManagementRequest::CopyFrom(const CheckAndroidManagementRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CheckAndroidManagementRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckAndroidManagementRequest::IsInitialized() const {
  return true;
}

void CheckAndroidManagementRequest::InternalSwap(CheckAndroidManagementRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CheckAndroidManagementRequest::GetTypeName() const {
  return "enterprise_management.CheckAndroidManagementRequest";
}


// ===================================================================

class CheckAndroidManagementResponse::_Internal {
 public:
};

CheckAndroidManagementResponse::CheckAndroidManagementResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CheckAndroidManagementResponse)
}
CheckAndroidManagementResponse::CheckAndroidManagementResponse(const CheckAndroidManagementResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CheckAndroidManagementResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CheckAndroidManagementResponse)
}

inline void CheckAndroidManagementResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

CheckAndroidManagementResponse::~CheckAndroidManagementResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.CheckAndroidManagementResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckAndroidManagementResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CheckAndroidManagementResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckAndroidManagementResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CheckAndroidManagementResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CheckAndroidManagementResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckAndroidManagementResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CheckAndroidManagementResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CheckAndroidManagementResponse)
  return target;
}

size_t CheckAndroidManagementResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CheckAndroidManagementResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CheckAndroidManagementResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CheckAndroidManagementResponse*>(
      &from));
}

void CheckAndroidManagementResponse::MergeFrom(const CheckAndroidManagementResponse& from) {
  CheckAndroidManagementResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CheckAndroidManagementResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CheckAndroidManagementResponse::CopyFrom(const CheckAndroidManagementResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CheckAndroidManagementResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckAndroidManagementResponse::IsInitialized() const {
  return true;
}

void CheckAndroidManagementResponse::InternalSwap(CheckAndroidManagementResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CheckAndroidManagementResponse::GetTypeName() const {
  return "enterprise_management.CheckAndroidManagementResponse";
}


// ===================================================================

class CertificateBasedDeviceRegisterRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CertificateBasedDeviceRegisterRequest>()._impl_._has_bits_);
  static const ::enterprise_management::SignedData& signed_request(const CertificateBasedDeviceRegisterRequest* msg);
  static void set_has_signed_request(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::enterprise_management::SignedData&
CertificateBasedDeviceRegisterRequest::_Internal::signed_request(const CertificateBasedDeviceRegisterRequest* msg) {
  return *msg->_impl_.signed_request_;
}
CertificateBasedDeviceRegisterRequest::CertificateBasedDeviceRegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CertificateBasedDeviceRegisterRequest)
}
CertificateBasedDeviceRegisterRequest::CertificateBasedDeviceRegisterRequest(const CertificateBasedDeviceRegisterRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CertificateBasedDeviceRegisterRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signed_request_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_signed_request()) {
    _this->_impl_.signed_request_ = new ::enterprise_management::SignedData(*from._impl_.signed_request_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CertificateBasedDeviceRegisterRequest)
}

inline void CertificateBasedDeviceRegisterRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signed_request_){nullptr}
  };
}

CertificateBasedDeviceRegisterRequest::~CertificateBasedDeviceRegisterRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.CertificateBasedDeviceRegisterRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CertificateBasedDeviceRegisterRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.signed_request_;
}

void CertificateBasedDeviceRegisterRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CertificateBasedDeviceRegisterRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CertificateBasedDeviceRegisterRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.signed_request_ != nullptr);
    _impl_.signed_request_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CertificateBasedDeviceRegisterRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.SignedData signed_request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_signed_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CertificateBasedDeviceRegisterRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CertificateBasedDeviceRegisterRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.SignedData signed_request = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::signed_request(this),
        _Internal::signed_request(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CertificateBasedDeviceRegisterRequest)
  return target;
}

size_t CertificateBasedDeviceRegisterRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CertificateBasedDeviceRegisterRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.SignedData signed_request = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.signed_request_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertificateBasedDeviceRegisterRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CertificateBasedDeviceRegisterRequest*>(
      &from));
}

void CertificateBasedDeviceRegisterRequest::MergeFrom(const CertificateBasedDeviceRegisterRequest& from) {
  CertificateBasedDeviceRegisterRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CertificateBasedDeviceRegisterRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_signed_request()) {
    _this->_internal_mutable_signed_request()->::enterprise_management::SignedData::MergeFrom(
        from._internal_signed_request());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CertificateBasedDeviceRegisterRequest::CopyFrom(const CertificateBasedDeviceRegisterRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CertificateBasedDeviceRegisterRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertificateBasedDeviceRegisterRequest::IsInitialized() const {
  return true;
}

void CertificateBasedDeviceRegisterRequest::InternalSwap(CertificateBasedDeviceRegisterRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.signed_request_, other->_impl_.signed_request_);
}

std::string CertificateBasedDeviceRegisterRequest::GetTypeName() const {
  return "enterprise_management.CertificateBasedDeviceRegisterRequest";
}


// ===================================================================

class DeviceRegisterConfiguration::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceRegisterConfiguration>()._impl_._has_bits_);
  static void set_has_device_owner(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceRegisterConfiguration::DeviceRegisterConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceRegisterConfiguration)
}
DeviceRegisterConfiguration::DeviceRegisterConfiguration(const DeviceRegisterConfiguration& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceRegisterConfiguration* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_owner_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.device_owner_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_owner_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_owner()) {
    _this->_impl_.device_owner_.Set(from._internal_device_owner(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceRegisterConfiguration)
}

inline void DeviceRegisterConfiguration::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_owner_){}
  };
  _impl_.device_owner_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_owner_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceRegisterConfiguration::~DeviceRegisterConfiguration() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceRegisterConfiguration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceRegisterConfiguration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.device_owner_.Destroy();
}

void DeviceRegisterConfiguration::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceRegisterConfiguration::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceRegisterConfiguration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.device_owner_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceRegisterConfiguration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device_owner = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_owner();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceRegisterConfiguration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceRegisterConfiguration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string device_owner = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_owner(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceRegisterConfiguration)
  return target;
}

size_t DeviceRegisterConfiguration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceRegisterConfiguration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string device_owner = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_device_owner());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceRegisterConfiguration::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceRegisterConfiguration*>(
      &from));
}

void DeviceRegisterConfiguration::MergeFrom(const DeviceRegisterConfiguration& from) {
  DeviceRegisterConfiguration* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceRegisterConfiguration)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_owner()) {
    _this->_internal_set_device_owner(from._internal_device_owner());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceRegisterConfiguration::CopyFrom(const DeviceRegisterConfiguration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceRegisterConfiguration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceRegisterConfiguration::IsInitialized() const {
  return true;
}

void DeviceRegisterConfiguration::InternalSwap(DeviceRegisterConfiguration* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_owner_, lhs_arena,
      &other->_impl_.device_owner_, rhs_arena
  );
}

std::string DeviceRegisterConfiguration::GetTypeName() const {
  return "enterprise_management.DeviceRegisterConfiguration";
}


// ===================================================================

class CertificateBasedDeviceRegistrationData::_Internal {
 public:
  using HasBits = decltype(std::declval<CertificateBasedDeviceRegistrationData>()._impl_._has_bits_);
  static void set_has_certificate_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_device_certificate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::enterprise_management::DeviceRegisterRequest& device_register_request(const CertificateBasedDeviceRegistrationData* msg);
  static void set_has_device_register_request(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::enterprise_management::DeviceRegisterConfiguration& device_register_configuration(const CertificateBasedDeviceRegistrationData* msg);
  static void set_has_device_register_configuration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::enterprise_management::DeviceRegisterRequest&
CertificateBasedDeviceRegistrationData::_Internal::device_register_request(const CertificateBasedDeviceRegistrationData* msg) {
  return *msg->_impl_.device_register_request_;
}
const ::enterprise_management::DeviceRegisterConfiguration&
CertificateBasedDeviceRegistrationData::_Internal::device_register_configuration(const CertificateBasedDeviceRegistrationData* msg) {
  return *msg->_impl_.device_register_configuration_;
}
CertificateBasedDeviceRegistrationData::CertificateBasedDeviceRegistrationData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CertificateBasedDeviceRegistrationData)
}
CertificateBasedDeviceRegistrationData::CertificateBasedDeviceRegistrationData(const CertificateBasedDeviceRegistrationData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CertificateBasedDeviceRegistrationData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_certificate_){}
    , decltype(_impl_.device_register_request_){nullptr}
    , decltype(_impl_.device_register_configuration_){nullptr}
    , decltype(_impl_.certificate_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.device_certificate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_certificate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_certificate()) {
    _this->_impl_.device_certificate_.Set(from._internal_device_certificate(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_device_register_request()) {
    _this->_impl_.device_register_request_ = new ::enterprise_management::DeviceRegisterRequest(*from._impl_.device_register_request_);
  }
  if (from._internal_has_device_register_configuration()) {
    _this->_impl_.device_register_configuration_ = new ::enterprise_management::DeviceRegisterConfiguration(*from._impl_.device_register_configuration_);
  }
  _this->_impl_.certificate_type_ = from._impl_.certificate_type_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CertificateBasedDeviceRegistrationData)
}

inline void CertificateBasedDeviceRegistrationData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.device_certificate_){}
    , decltype(_impl_.device_register_request_){nullptr}
    , decltype(_impl_.device_register_configuration_){nullptr}
    , decltype(_impl_.certificate_type_){0}
  };
  _impl_.device_certificate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_certificate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CertificateBasedDeviceRegistrationData::~CertificateBasedDeviceRegistrationData() {
  // @@protoc_insertion_point(destructor:enterprise_management.CertificateBasedDeviceRegistrationData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CertificateBasedDeviceRegistrationData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.device_certificate_.Destroy();
  if (this != internal_default_instance()) delete _impl_.device_register_request_;
  if (this != internal_default_instance()) delete _impl_.device_register_configuration_;
}

void CertificateBasedDeviceRegistrationData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CertificateBasedDeviceRegistrationData::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CertificateBasedDeviceRegistrationData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.device_certificate_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.device_register_request_ != nullptr);
      _impl_.device_register_request_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.device_register_configuration_ != nullptr);
      _impl_.device_register_configuration_->Clear();
    }
  }
  _impl_.certificate_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CertificateBasedDeviceRegistrationData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.CertificateBasedDeviceRegistrationData.CertificateType certificate_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType_IsValid(val))) {
            _internal_set_certificate_type(static_cast<::enterprise_management::CertificateBasedDeviceRegistrationData_CertificateType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes device_certificate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_device_certificate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceRegisterRequest device_register_request = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_register_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceRegisterConfiguration device_register_configuration = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_register_configuration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CertificateBasedDeviceRegistrationData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CertificateBasedDeviceRegistrationData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.CertificateBasedDeviceRegistrationData.CertificateType certificate_type = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_certificate_type(), target);
  }

  // optional bytes device_certificate = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_device_certificate(), target);
  }

  // optional .enterprise_management.DeviceRegisterRequest device_register_request = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::device_register_request(this),
        _Internal::device_register_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceRegisterConfiguration device_register_configuration = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::device_register_configuration(this),
        _Internal::device_register_configuration(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CertificateBasedDeviceRegistrationData)
  return target;
}

size_t CertificateBasedDeviceRegistrationData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CertificateBasedDeviceRegistrationData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes device_certificate = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_device_certificate());
    }

    // optional .enterprise_management.DeviceRegisterRequest device_register_request = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_register_request_);
    }

    // optional .enterprise_management.DeviceRegisterConfiguration device_register_configuration = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_register_configuration_);
    }

    // optional .enterprise_management.CertificateBasedDeviceRegistrationData.CertificateType certificate_type = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_certificate_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertificateBasedDeviceRegistrationData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CertificateBasedDeviceRegistrationData*>(
      &from));
}

void CertificateBasedDeviceRegistrationData::MergeFrom(const CertificateBasedDeviceRegistrationData& from) {
  CertificateBasedDeviceRegistrationData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CertificateBasedDeviceRegistrationData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_device_certificate(from._internal_device_certificate());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_device_register_request()->::enterprise_management::DeviceRegisterRequest::MergeFrom(
          from._internal_device_register_request());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_device_register_configuration()->::enterprise_management::DeviceRegisterConfiguration::MergeFrom(
          from._internal_device_register_configuration());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.certificate_type_ = from._impl_.certificate_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CertificateBasedDeviceRegistrationData::CopyFrom(const CertificateBasedDeviceRegistrationData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CertificateBasedDeviceRegistrationData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertificateBasedDeviceRegistrationData::IsInitialized() const {
  return true;
}

void CertificateBasedDeviceRegistrationData::InternalSwap(CertificateBasedDeviceRegistrationData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_certificate_, lhs_arena,
      &other->_impl_.device_certificate_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CertificateBasedDeviceRegistrationData, _impl_.certificate_type_)
      + sizeof(CertificateBasedDeviceRegistrationData::_impl_.certificate_type_)
      - PROTOBUF_FIELD_OFFSET(CertificateBasedDeviceRegistrationData, _impl_.device_register_request_)>(
          reinterpret_cast<char*>(&_impl_.device_register_request_),
          reinterpret_cast<char*>(&other->_impl_.device_register_request_));
}

std::string CertificateBasedDeviceRegistrationData::GetTypeName() const {
  return "enterprise_management.CertificateBasedDeviceRegistrationData";
}


// ===================================================================

class RegisterBrowserRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<RegisterBrowserRequest>()._impl_._has_bits_);
  static void set_has_machine_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_os_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_os_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::enterprise_management::BrowserDeviceIdentifier& browser_device_identifier(const RegisterBrowserRequest* msg);
  static void set_has_browser_device_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_device_model(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_brand_name(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::enterprise_management::BrowserDeviceIdentifier&
RegisterBrowserRequest::_Internal::browser_device_identifier(const RegisterBrowserRequest* msg) {
  return *msg->_impl_.browser_device_identifier_;
}
RegisterBrowserRequest::RegisterBrowserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.RegisterBrowserRequest)
}
RegisterBrowserRequest::RegisterBrowserRequest(const RegisterBrowserRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RegisterBrowserRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.machine_name_){}
    , decltype(_impl_.os_platform_){}
    , decltype(_impl_.os_version_){}
    , decltype(_impl_.device_model_){}
    , decltype(_impl_.brand_name_){}
    , decltype(_impl_.browser_device_identifier_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.machine_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_machine_name()) {
    _this->_impl_.machine_name_.Set(from._internal_machine_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.os_platform_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_platform_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_os_platform()) {
    _this->_impl_.os_platform_.Set(from._internal_os_platform(), 
      _this->GetArenaForAllocation());
  }
  _impl_.os_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_os_version()) {
    _this->_impl_.os_version_.Set(from._internal_os_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.device_model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_model()) {
    _this->_impl_.device_model_.Set(from._internal_device_model(), 
      _this->GetArenaForAllocation());
  }
  _impl_.brand_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.brand_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_brand_name()) {
    _this->_impl_.brand_name_.Set(from._internal_brand_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_browser_device_identifier()) {
    _this->_impl_.browser_device_identifier_ = new ::enterprise_management::BrowserDeviceIdentifier(*from._impl_.browser_device_identifier_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.RegisterBrowserRequest)
}

inline void RegisterBrowserRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.machine_name_){}
    , decltype(_impl_.os_platform_){}
    , decltype(_impl_.os_version_){}
    , decltype(_impl_.device_model_){}
    , decltype(_impl_.brand_name_){}
    , decltype(_impl_.browser_device_identifier_){nullptr}
  };
  _impl_.machine_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.os_platform_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_platform_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.os_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.device_model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.brand_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.brand_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RegisterBrowserRequest::~RegisterBrowserRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.RegisterBrowserRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RegisterBrowserRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.machine_name_.Destroy();
  _impl_.os_platform_.Destroy();
  _impl_.os_version_.Destroy();
  _impl_.device_model_.Destroy();
  _impl_.brand_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.browser_device_identifier_;
}

void RegisterBrowserRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RegisterBrowserRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.RegisterBrowserRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.machine_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.os_platform_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.os_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.device_model_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.brand_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.browser_device_identifier_ != nullptr);
      _impl_.browser_device_identifier_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RegisterBrowserRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string machine_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_machine_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string os_platform = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_os_platform();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string os_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_os_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BrowserDeviceIdentifier browser_device_identifier = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_browser_device_identifier(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string device_model = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_device_model();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string brand_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_brand_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RegisterBrowserRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.RegisterBrowserRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string machine_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_machine_name(), target);
  }

  // optional string os_platform = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_os_platform(), target);
  }

  // optional string os_version = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_os_version(), target);
  }

  // optional .enterprise_management.BrowserDeviceIdentifier browser_device_identifier = 4;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::browser_device_identifier(this),
        _Internal::browser_device_identifier(this).GetCachedSize(), target, stream);
  }

  // optional string device_model = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_device_model(), target);
  }

  // optional string brand_name = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_brand_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.RegisterBrowserRequest)
  return target;
}

size_t RegisterBrowserRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.RegisterBrowserRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string machine_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_machine_name());
    }

    // optional string os_platform = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_os_platform());
    }

    // optional string os_version = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_os_version());
    }

    // optional string device_model = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_model());
    }

    // optional string brand_name = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_brand_name());
    }

    // optional .enterprise_management.BrowserDeviceIdentifier browser_device_identifier = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.browser_device_identifier_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RegisterBrowserRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RegisterBrowserRequest*>(
      &from));
}

void RegisterBrowserRequest::MergeFrom(const RegisterBrowserRequest& from) {
  RegisterBrowserRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.RegisterBrowserRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_machine_name(from._internal_machine_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_os_platform(from._internal_os_platform());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_os_version(from._internal_os_version());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_device_model(from._internal_device_model());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_brand_name(from._internal_brand_name());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_browser_device_identifier()->::enterprise_management::BrowserDeviceIdentifier::MergeFrom(
          from._internal_browser_device_identifier());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RegisterBrowserRequest::CopyFrom(const RegisterBrowserRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.RegisterBrowserRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterBrowserRequest::IsInitialized() const {
  return true;
}

void RegisterBrowserRequest::InternalSwap(RegisterBrowserRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_name_, lhs_arena,
      &other->_impl_.machine_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.os_platform_, lhs_arena,
      &other->_impl_.os_platform_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.os_version_, lhs_arena,
      &other->_impl_.os_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_model_, lhs_arena,
      &other->_impl_.device_model_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.brand_name_, lhs_arena,
      &other->_impl_.brand_name_, rhs_arena
  );
  swap(_impl_.browser_device_identifier_, other->_impl_.browser_device_identifier_);
}

std::string RegisterBrowserRequest::GetTypeName() const {
  return "enterprise_management.RegisterBrowserRequest";
}


// ===================================================================

class ActiveDirectoryEnrollPlayUserRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ActiveDirectoryEnrollPlayUserRequest>()._impl_._has_bits_);
  static void set_has_auth_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ActiveDirectoryEnrollPlayUserRequest::ActiveDirectoryEnrollPlayUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ActiveDirectoryEnrollPlayUserRequest)
}
ActiveDirectoryEnrollPlayUserRequest::ActiveDirectoryEnrollPlayUserRequest(const ActiveDirectoryEnrollPlayUserRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ActiveDirectoryEnrollPlayUserRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.auth_session_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.auth_session_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_session_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_auth_session_id()) {
    _this->_impl_.auth_session_id_.Set(from._internal_auth_session_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ActiveDirectoryEnrollPlayUserRequest)
}

inline void ActiveDirectoryEnrollPlayUserRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.auth_session_id_){}
  };
  _impl_.auth_session_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_session_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ActiveDirectoryEnrollPlayUserRequest::~ActiveDirectoryEnrollPlayUserRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.ActiveDirectoryEnrollPlayUserRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActiveDirectoryEnrollPlayUserRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.auth_session_id_.Destroy();
}

void ActiveDirectoryEnrollPlayUserRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActiveDirectoryEnrollPlayUserRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ActiveDirectoryEnrollPlayUserRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.auth_session_id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ActiveDirectoryEnrollPlayUserRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string auth_session_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_auth_session_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActiveDirectoryEnrollPlayUserRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ActiveDirectoryEnrollPlayUserRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string auth_session_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_auth_session_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ActiveDirectoryEnrollPlayUserRequest)
  return target;
}

size_t ActiveDirectoryEnrollPlayUserRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ActiveDirectoryEnrollPlayUserRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string auth_session_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_auth_session_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActiveDirectoryEnrollPlayUserRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ActiveDirectoryEnrollPlayUserRequest*>(
      &from));
}

void ActiveDirectoryEnrollPlayUserRequest::MergeFrom(const ActiveDirectoryEnrollPlayUserRequest& from) {
  ActiveDirectoryEnrollPlayUserRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ActiveDirectoryEnrollPlayUserRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_auth_session_id()) {
    _this->_internal_set_auth_session_id(from._internal_auth_session_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActiveDirectoryEnrollPlayUserRequest::CopyFrom(const ActiveDirectoryEnrollPlayUserRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ActiveDirectoryEnrollPlayUserRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActiveDirectoryEnrollPlayUserRequest::IsInitialized() const {
  return true;
}

void ActiveDirectoryEnrollPlayUserRequest::InternalSwap(ActiveDirectoryEnrollPlayUserRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.auth_session_id_, lhs_arena,
      &other->_impl_.auth_session_id_, rhs_arena
  );
}

std::string ActiveDirectoryEnrollPlayUserRequest::GetTypeName() const {
  return "enterprise_management.ActiveDirectoryEnrollPlayUserRequest";
}


// ===================================================================

class ActiveDirectoryEnrollPlayUserResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ActiveDirectoryEnrollPlayUserResponse>()._impl_._has_bits_);
  static void set_has_enrollment_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::enterprise_management::SamlParametersProto& saml_parameters(const ActiveDirectoryEnrollPlayUserResponse* msg);
  static void set_has_saml_parameters(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::enterprise_management::SamlParametersProto&
ActiveDirectoryEnrollPlayUserResponse::_Internal::saml_parameters(const ActiveDirectoryEnrollPlayUserResponse* msg) {
  return *msg->_impl_.saml_parameters_;
}
ActiveDirectoryEnrollPlayUserResponse::ActiveDirectoryEnrollPlayUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ActiveDirectoryEnrollPlayUserResponse)
}
ActiveDirectoryEnrollPlayUserResponse::ActiveDirectoryEnrollPlayUserResponse(const ActiveDirectoryEnrollPlayUserResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ActiveDirectoryEnrollPlayUserResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enrollment_token_){}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.saml_parameters_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.enrollment_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.enrollment_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_enrollment_token()) {
    _this->_impl_.enrollment_token_.Set(from._internal_enrollment_token(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    _this->_impl_.user_id_.Set(from._internal_user_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_saml_parameters()) {
    _this->_impl_.saml_parameters_ = new ::enterprise_management::SamlParametersProto(*from._impl_.saml_parameters_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ActiveDirectoryEnrollPlayUserResponse)
}

inline void ActiveDirectoryEnrollPlayUserResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enrollment_token_){}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.saml_parameters_){nullptr}
  };
  _impl_.enrollment_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.enrollment_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ActiveDirectoryEnrollPlayUserResponse::~ActiveDirectoryEnrollPlayUserResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.ActiveDirectoryEnrollPlayUserResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActiveDirectoryEnrollPlayUserResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.enrollment_token_.Destroy();
  _impl_.user_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.saml_parameters_;
}

void ActiveDirectoryEnrollPlayUserResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActiveDirectoryEnrollPlayUserResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ActiveDirectoryEnrollPlayUserResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.enrollment_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.saml_parameters_ != nullptr);
      _impl_.saml_parameters_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ActiveDirectoryEnrollPlayUserResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string enrollment_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_enrollment_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string user_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.SamlParametersProto saml_parameters = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_saml_parameters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActiveDirectoryEnrollPlayUserResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ActiveDirectoryEnrollPlayUserResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string enrollment_token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_enrollment_token(), target);
  }

  // optional string user_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_user_id(), target);
  }

  // optional .enterprise_management.SamlParametersProto saml_parameters = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::saml_parameters(this),
        _Internal::saml_parameters(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ActiveDirectoryEnrollPlayUserResponse)
  return target;
}

size_t ActiveDirectoryEnrollPlayUserResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ActiveDirectoryEnrollPlayUserResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string enrollment_token = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_enrollment_token());
    }

    // optional string user_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional .enterprise_management.SamlParametersProto saml_parameters = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.saml_parameters_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActiveDirectoryEnrollPlayUserResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ActiveDirectoryEnrollPlayUserResponse*>(
      &from));
}

void ActiveDirectoryEnrollPlayUserResponse::MergeFrom(const ActiveDirectoryEnrollPlayUserResponse& from) {
  ActiveDirectoryEnrollPlayUserResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ActiveDirectoryEnrollPlayUserResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_enrollment_token(from._internal_enrollment_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_saml_parameters()->::enterprise_management::SamlParametersProto::MergeFrom(
          from._internal_saml_parameters());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActiveDirectoryEnrollPlayUserResponse::CopyFrom(const ActiveDirectoryEnrollPlayUserResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ActiveDirectoryEnrollPlayUserResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActiveDirectoryEnrollPlayUserResponse::IsInitialized() const {
  return true;
}

void ActiveDirectoryEnrollPlayUserResponse::InternalSwap(ActiveDirectoryEnrollPlayUserResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.enrollment_token_, lhs_arena,
      &other->_impl_.enrollment_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_id_, lhs_arena,
      &other->_impl_.user_id_, rhs_arena
  );
  swap(_impl_.saml_parameters_, other->_impl_.saml_parameters_);
}

std::string ActiveDirectoryEnrollPlayUserResponse::GetTypeName() const {
  return "enterprise_management.ActiveDirectoryEnrollPlayUserResponse";
}


// ===================================================================

class SamlParametersProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SamlParametersProto>()._impl_._has_bits_);
  static void set_has_auth_redirect_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SamlParametersProto::SamlParametersProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.SamlParametersProto)
}
SamlParametersProto::SamlParametersProto(const SamlParametersProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SamlParametersProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.auth_redirect_url_){}
    , decltype(_impl_.auth_session_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.auth_redirect_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_redirect_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_auth_redirect_url()) {
    _this->_impl_.auth_redirect_url_.Set(from._internal_auth_redirect_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.auth_session_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_session_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_auth_session_id()) {
    _this->_impl_.auth_session_id_.Set(from._internal_auth_session_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.SamlParametersProto)
}

inline void SamlParametersProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.auth_redirect_url_){}
    , decltype(_impl_.auth_session_id_){}
  };
  _impl_.auth_redirect_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_redirect_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.auth_session_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_session_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SamlParametersProto::~SamlParametersProto() {
  // @@protoc_insertion_point(destructor:enterprise_management.SamlParametersProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SamlParametersProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.auth_redirect_url_.Destroy();
  _impl_.auth_session_id_.Destroy();
}

void SamlParametersProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SamlParametersProto::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.SamlParametersProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.auth_redirect_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.auth_session_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SamlParametersProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string auth_redirect_url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_auth_redirect_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string auth_session_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_auth_session_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SamlParametersProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.SamlParametersProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string auth_redirect_url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_auth_redirect_url(), target);
  }

  // optional string auth_session_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_auth_session_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.SamlParametersProto)
  return target;
}

size_t SamlParametersProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.SamlParametersProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string auth_redirect_url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_auth_redirect_url());
    }

    // optional string auth_session_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_auth_session_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SamlParametersProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SamlParametersProto*>(
      &from));
}

void SamlParametersProto::MergeFrom(const SamlParametersProto& from) {
  SamlParametersProto* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.SamlParametersProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_auth_redirect_url(from._internal_auth_redirect_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_auth_session_id(from._internal_auth_session_id());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SamlParametersProto::CopyFrom(const SamlParametersProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.SamlParametersProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SamlParametersProto::IsInitialized() const {
  return true;
}

void SamlParametersProto::InternalSwap(SamlParametersProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.auth_redirect_url_, lhs_arena,
      &other->_impl_.auth_redirect_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.auth_session_id_, lhs_arena,
      &other->_impl_.auth_session_id_, rhs_arena
  );
}

std::string SamlParametersProto::GetTypeName() const {
  return "enterprise_management.SamlParametersProto";
}


// ===================================================================

class PublicSamlUserRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<PublicSamlUserRequest>()._impl_._has_bits_);
  static void set_has_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PublicSamlUserRequest::PublicSamlUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PublicSamlUserRequest)
}
PublicSamlUserRequest::PublicSamlUserRequest(const PublicSamlUserRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PublicSamlUserRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_account_id()) {
    _this->_impl_.account_id_.Set(from._internal_account_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PublicSamlUserRequest)
}

inline void PublicSamlUserRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_id_){}
  };
  _impl_.account_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PublicSamlUserRequest::~PublicSamlUserRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.PublicSamlUserRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PublicSamlUserRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_id_.Destroy();
}

void PublicSamlUserRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PublicSamlUserRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PublicSamlUserRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.account_id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PublicSamlUserRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string account_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_account_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PublicSamlUserRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PublicSamlUserRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string account_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_account_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PublicSamlUserRequest)
  return target;
}

size_t PublicSamlUserRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PublicSamlUserRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string account_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_account_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PublicSamlUserRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PublicSamlUserRequest*>(
      &from));
}

void PublicSamlUserRequest::MergeFrom(const PublicSamlUserRequest& from) {
  PublicSamlUserRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PublicSamlUserRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_account_id()) {
    _this->_internal_set_account_id(from._internal_account_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PublicSamlUserRequest::CopyFrom(const PublicSamlUserRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PublicSamlUserRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublicSamlUserRequest::IsInitialized() const {
  return true;
}

void PublicSamlUserRequest::InternalSwap(PublicSamlUserRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.account_id_, lhs_arena,
      &other->_impl_.account_id_, rhs_arena
  );
}

std::string PublicSamlUserRequest::GetTypeName() const {
  return "enterprise_management.PublicSamlUserRequest";
}


// ===================================================================

class PublicSamlUserResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<PublicSamlUserResponse>()._impl_._has_bits_);
  static const ::enterprise_management::SamlParametersProto& saml_parameters(const PublicSamlUserResponse* msg);
  static void set_has_saml_parameters(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::enterprise_management::SamlParametersProto&
PublicSamlUserResponse::_Internal::saml_parameters(const PublicSamlUserResponse* msg) {
  return *msg->_impl_.saml_parameters_;
}
PublicSamlUserResponse::PublicSamlUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PublicSamlUserResponse)
}
PublicSamlUserResponse::PublicSamlUserResponse(const PublicSamlUserResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PublicSamlUserResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.saml_parameters_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_saml_parameters()) {
    _this->_impl_.saml_parameters_ = new ::enterprise_management::SamlParametersProto(*from._impl_.saml_parameters_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PublicSamlUserResponse)
}

inline void PublicSamlUserResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.saml_parameters_){nullptr}
  };
}

PublicSamlUserResponse::~PublicSamlUserResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.PublicSamlUserResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PublicSamlUserResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.saml_parameters_;
}

void PublicSamlUserResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PublicSamlUserResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PublicSamlUserResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.saml_parameters_ != nullptr);
    _impl_.saml_parameters_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PublicSamlUserResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.SamlParametersProto saml_parameters = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_saml_parameters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PublicSamlUserResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PublicSamlUserResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.SamlParametersProto saml_parameters = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::saml_parameters(this),
        _Internal::saml_parameters(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PublicSamlUserResponse)
  return target;
}

size_t PublicSamlUserResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PublicSamlUserResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.SamlParametersProto saml_parameters = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.saml_parameters_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PublicSamlUserResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PublicSamlUserResponse*>(
      &from));
}

void PublicSamlUserResponse::MergeFrom(const PublicSamlUserResponse& from) {
  PublicSamlUserResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PublicSamlUserResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_saml_parameters()) {
    _this->_internal_mutable_saml_parameters()->::enterprise_management::SamlParametersProto::MergeFrom(
        from._internal_saml_parameters());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PublicSamlUserResponse::CopyFrom(const PublicSamlUserResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PublicSamlUserResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublicSamlUserResponse::IsInitialized() const {
  return true;
}

void PublicSamlUserResponse::InternalSwap(PublicSamlUserResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.saml_parameters_, other->_impl_.saml_parameters_);
}

std::string PublicSamlUserResponse::GetTypeName() const {
  return "enterprise_management.PublicSamlUserResponse";
}


// ===================================================================

class ActiveDirectoryPlayActivityRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ActiveDirectoryPlayActivityRequest>()._impl_._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ActiveDirectoryPlayActivityRequest::ActiveDirectoryPlayActivityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ActiveDirectoryPlayActivityRequest)
}
ActiveDirectoryPlayActivityRequest::ActiveDirectoryPlayActivityRequest(const ActiveDirectoryPlayActivityRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ActiveDirectoryPlayActivityRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    _this->_impl_.user_id_.Set(from._internal_user_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ActiveDirectoryPlayActivityRequest)
}

inline void ActiveDirectoryPlayActivityRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_id_){}
  };
  _impl_.user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ActiveDirectoryPlayActivityRequest::~ActiveDirectoryPlayActivityRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.ActiveDirectoryPlayActivityRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActiveDirectoryPlayActivityRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_id_.Destroy();
}

void ActiveDirectoryPlayActivityRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActiveDirectoryPlayActivityRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ActiveDirectoryPlayActivityRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.user_id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ActiveDirectoryPlayActivityRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActiveDirectoryPlayActivityRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ActiveDirectoryPlayActivityRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ActiveDirectoryPlayActivityRequest)
  return target;
}

size_t ActiveDirectoryPlayActivityRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ActiveDirectoryPlayActivityRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string user_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActiveDirectoryPlayActivityRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ActiveDirectoryPlayActivityRequest*>(
      &from));
}

void ActiveDirectoryPlayActivityRequest::MergeFrom(const ActiveDirectoryPlayActivityRequest& from) {
  ActiveDirectoryPlayActivityRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ActiveDirectoryPlayActivityRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_user_id()) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActiveDirectoryPlayActivityRequest::CopyFrom(const ActiveDirectoryPlayActivityRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ActiveDirectoryPlayActivityRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActiveDirectoryPlayActivityRequest::IsInitialized() const {
  return true;
}

void ActiveDirectoryPlayActivityRequest::InternalSwap(ActiveDirectoryPlayActivityRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_id_, lhs_arena,
      &other->_impl_.user_id_, rhs_arena
  );
}

std::string ActiveDirectoryPlayActivityRequest::GetTypeName() const {
  return "enterprise_management.ActiveDirectoryPlayActivityRequest";
}


// ===================================================================

class ActiveDirectoryPlayActivityResponse::_Internal {
 public:
};

ActiveDirectoryPlayActivityResponse::ActiveDirectoryPlayActivityResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ActiveDirectoryPlayActivityResponse)
}
ActiveDirectoryPlayActivityResponse::ActiveDirectoryPlayActivityResponse(const ActiveDirectoryPlayActivityResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ActiveDirectoryPlayActivityResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ActiveDirectoryPlayActivityResponse)
}

inline void ActiveDirectoryPlayActivityResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

ActiveDirectoryPlayActivityResponse::~ActiveDirectoryPlayActivityResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.ActiveDirectoryPlayActivityResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActiveDirectoryPlayActivityResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ActiveDirectoryPlayActivityResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActiveDirectoryPlayActivityResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ActiveDirectoryPlayActivityResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ActiveDirectoryPlayActivityResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActiveDirectoryPlayActivityResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ActiveDirectoryPlayActivityResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ActiveDirectoryPlayActivityResponse)
  return target;
}

size_t ActiveDirectoryPlayActivityResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ActiveDirectoryPlayActivityResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActiveDirectoryPlayActivityResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ActiveDirectoryPlayActivityResponse*>(
      &from));
}

void ActiveDirectoryPlayActivityResponse::MergeFrom(const ActiveDirectoryPlayActivityResponse& from) {
  ActiveDirectoryPlayActivityResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ActiveDirectoryPlayActivityResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActiveDirectoryPlayActivityResponse::CopyFrom(const ActiveDirectoryPlayActivityResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ActiveDirectoryPlayActivityResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActiveDirectoryPlayActivityResponse::IsInitialized() const {
  return true;
}

void ActiveDirectoryPlayActivityResponse::InternalSwap(ActiveDirectoryPlayActivityResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ActiveDirectoryPlayActivityResponse::GetTypeName() const {
  return "enterprise_management.ActiveDirectoryPlayActivityResponse";
}


// ===================================================================

class CheckDeviceLicenseRequest::_Internal {
 public:
};

CheckDeviceLicenseRequest::CheckDeviceLicenseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CheckDeviceLicenseRequest)
}
CheckDeviceLicenseRequest::CheckDeviceLicenseRequest(const CheckDeviceLicenseRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CheckDeviceLicenseRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CheckDeviceLicenseRequest)
}

inline void CheckDeviceLicenseRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

CheckDeviceLicenseRequest::~CheckDeviceLicenseRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.CheckDeviceLicenseRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckDeviceLicenseRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CheckDeviceLicenseRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckDeviceLicenseRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CheckDeviceLicenseRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CheckDeviceLicenseRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckDeviceLicenseRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CheckDeviceLicenseRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CheckDeviceLicenseRequest)
  return target;
}

size_t CheckDeviceLicenseRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CheckDeviceLicenseRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CheckDeviceLicenseRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CheckDeviceLicenseRequest*>(
      &from));
}

void CheckDeviceLicenseRequest::MergeFrom(const CheckDeviceLicenseRequest& from) {
  CheckDeviceLicenseRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CheckDeviceLicenseRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CheckDeviceLicenseRequest::CopyFrom(const CheckDeviceLicenseRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CheckDeviceLicenseRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckDeviceLicenseRequest::IsInitialized() const {
  return true;
}

void CheckDeviceLicenseRequest::InternalSwap(CheckDeviceLicenseRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CheckDeviceLicenseRequest::GetTypeName() const {
  return "enterprise_management.CheckDeviceLicenseRequest";
}


// ===================================================================

class LicenseAvailability::_Internal {
 public:
  using HasBits = decltype(std::declval<LicenseAvailability>()._impl_._has_bits_);
  static const ::enterprise_management::LicenseType& license_type_deprecated(const LicenseAvailability* msg);
  static void set_has_license_type_deprecated(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_available_licenses_deprecated(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::enterprise_management::LicenseType&
LicenseAvailability::_Internal::license_type_deprecated(const LicenseAvailability* msg) {
  return *msg->_impl_.license_type_deprecated_;
}
LicenseAvailability::LicenseAvailability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.LicenseAvailability)
}
LicenseAvailability::LicenseAvailability(const LicenseAvailability& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LicenseAvailability* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.license_type_deprecated_){nullptr}
    , decltype(_impl_.available_licenses_deprecated_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_license_type_deprecated()) {
    _this->_impl_.license_type_deprecated_ = new ::enterprise_management::LicenseType(*from._impl_.license_type_deprecated_);
  }
  _this->_impl_.available_licenses_deprecated_ = from._impl_.available_licenses_deprecated_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.LicenseAvailability)
}

inline void LicenseAvailability::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.license_type_deprecated_){nullptr}
    , decltype(_impl_.available_licenses_deprecated_){0}
  };
}

LicenseAvailability::~LicenseAvailability() {
  // @@protoc_insertion_point(destructor:enterprise_management.LicenseAvailability)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LicenseAvailability::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.license_type_deprecated_;
}

void LicenseAvailability::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LicenseAvailability::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.LicenseAvailability)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.license_type_deprecated_ != nullptr);
    _impl_.license_type_deprecated_->Clear();
  }
  _impl_.available_licenses_deprecated_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LicenseAvailability::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.LicenseType license_type_deprecated = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_license_type_deprecated(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 available_licenses_deprecated = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_available_licenses_deprecated(&has_bits);
          _impl_.available_licenses_deprecated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LicenseAvailability::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.LicenseAvailability)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.LicenseType license_type_deprecated = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::license_type_deprecated(this),
        _Internal::license_type_deprecated(this).GetCachedSize(), target, stream);
  }

  // optional int32 available_licenses_deprecated = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_available_licenses_deprecated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.LicenseAvailability)
  return target;
}

size_t LicenseAvailability::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.LicenseAvailability)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .enterprise_management.LicenseType license_type_deprecated = 1 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.license_type_deprecated_);
    }

    // optional int32 available_licenses_deprecated = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_available_licenses_deprecated());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LicenseAvailability::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LicenseAvailability*>(
      &from));
}

void LicenseAvailability::MergeFrom(const LicenseAvailability& from) {
  LicenseAvailability* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.LicenseAvailability)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_license_type_deprecated()->::enterprise_management::LicenseType::MergeFrom(
          from._internal_license_type_deprecated());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.available_licenses_deprecated_ = from._impl_.available_licenses_deprecated_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LicenseAvailability::CopyFrom(const LicenseAvailability& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.LicenseAvailability)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LicenseAvailability::IsInitialized() const {
  return true;
}

void LicenseAvailability::InternalSwap(LicenseAvailability* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LicenseAvailability, _impl_.available_licenses_deprecated_)
      + sizeof(LicenseAvailability::_impl_.available_licenses_deprecated_)
      - PROTOBUF_FIELD_OFFSET(LicenseAvailability, _impl_.license_type_deprecated_)>(
          reinterpret_cast<char*>(&_impl_.license_type_deprecated_),
          reinterpret_cast<char*>(&other->_impl_.license_type_deprecated_));
}

std::string LicenseAvailability::GetTypeName() const {
  return "enterprise_management.LicenseAvailability";
}


// ===================================================================

class CheckDeviceLicenseResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CheckDeviceLicenseResponse>()._impl_._has_bits_);
  static void set_has_license_selection_mode_deprecated(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CheckDeviceLicenseResponse::CheckDeviceLicenseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CheckDeviceLicenseResponse)
}
CheckDeviceLicenseResponse::CheckDeviceLicenseResponse(const CheckDeviceLicenseResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CheckDeviceLicenseResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.license_availabilities_deprecated_){from._impl_.license_availabilities_deprecated_}
    , decltype(_impl_.license_selection_mode_deprecated_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.license_selection_mode_deprecated_ = from._impl_.license_selection_mode_deprecated_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CheckDeviceLicenseResponse)
}

inline void CheckDeviceLicenseResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.license_availabilities_deprecated_){arena}
    , decltype(_impl_.license_selection_mode_deprecated_){0}
  };
}

CheckDeviceLicenseResponse::~CheckDeviceLicenseResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.CheckDeviceLicenseResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckDeviceLicenseResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.license_availabilities_deprecated_.~RepeatedPtrField();
}

void CheckDeviceLicenseResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckDeviceLicenseResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CheckDeviceLicenseResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.license_availabilities_deprecated_.Clear();
  _impl_.license_selection_mode_deprecated_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CheckDeviceLicenseResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.CheckDeviceLicenseResponse.LicenseSelectionMode license_selection_mode_deprecated = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode_IsValid(val))) {
            _internal_set_license_selection_mode_deprecated(static_cast<::enterprise_management::CheckDeviceLicenseResponse_LicenseSelectionMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.LicenseAvailability license_availabilities_deprecated = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_license_availabilities_deprecated(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckDeviceLicenseResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CheckDeviceLicenseResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.CheckDeviceLicenseResponse.LicenseSelectionMode license_selection_mode_deprecated = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_license_selection_mode_deprecated(), target);
  }

  // repeated .enterprise_management.LicenseAvailability license_availabilities_deprecated = 2 [deprecated = true];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_license_availabilities_deprecated_size()); i < n; i++) {
    const auto& repfield = this->_internal_license_availabilities_deprecated(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CheckDeviceLicenseResponse)
  return target;
}

size_t CheckDeviceLicenseResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CheckDeviceLicenseResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.LicenseAvailability license_availabilities_deprecated = 2 [deprecated = true];
  total_size += 1UL * this->_internal_license_availabilities_deprecated_size();
  for (const auto& msg : this->_impl_.license_availabilities_deprecated_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .enterprise_management.CheckDeviceLicenseResponse.LicenseSelectionMode license_selection_mode_deprecated = 1 [deprecated = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_license_selection_mode_deprecated());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CheckDeviceLicenseResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CheckDeviceLicenseResponse*>(
      &from));
}

void CheckDeviceLicenseResponse::MergeFrom(const CheckDeviceLicenseResponse& from) {
  CheckDeviceLicenseResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CheckDeviceLicenseResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.license_availabilities_deprecated_.MergeFrom(from._impl_.license_availabilities_deprecated_);
  if (from._internal_has_license_selection_mode_deprecated()) {
    _this->_internal_set_license_selection_mode_deprecated(from._internal_license_selection_mode_deprecated());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CheckDeviceLicenseResponse::CopyFrom(const CheckDeviceLicenseResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CheckDeviceLicenseResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckDeviceLicenseResponse::IsInitialized() const {
  return true;
}

void CheckDeviceLicenseResponse::InternalSwap(CheckDeviceLicenseResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.license_availabilities_deprecated_.InternalSwap(&other->_impl_.license_availabilities_deprecated_);
  swap(_impl_.license_selection_mode_deprecated_, other->_impl_.license_selection_mode_deprecated_);
}

std::string CheckDeviceLicenseResponse::GetTypeName() const {
  return "enterprise_management.CheckDeviceLicenseResponse";
}


// ===================================================================

class ActiveDirectoryUserSigninRequest::_Internal {
 public:
};

ActiveDirectoryUserSigninRequest::ActiveDirectoryUserSigninRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ActiveDirectoryUserSigninRequest)
}
ActiveDirectoryUserSigninRequest::ActiveDirectoryUserSigninRequest(const ActiveDirectoryUserSigninRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ActiveDirectoryUserSigninRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ActiveDirectoryUserSigninRequest)
}

inline void ActiveDirectoryUserSigninRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

ActiveDirectoryUserSigninRequest::~ActiveDirectoryUserSigninRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.ActiveDirectoryUserSigninRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActiveDirectoryUserSigninRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ActiveDirectoryUserSigninRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActiveDirectoryUserSigninRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ActiveDirectoryUserSigninRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ActiveDirectoryUserSigninRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActiveDirectoryUserSigninRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ActiveDirectoryUserSigninRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ActiveDirectoryUserSigninRequest)
  return target;
}

size_t ActiveDirectoryUserSigninRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ActiveDirectoryUserSigninRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActiveDirectoryUserSigninRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ActiveDirectoryUserSigninRequest*>(
      &from));
}

void ActiveDirectoryUserSigninRequest::MergeFrom(const ActiveDirectoryUserSigninRequest& from) {
  ActiveDirectoryUserSigninRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ActiveDirectoryUserSigninRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActiveDirectoryUserSigninRequest::CopyFrom(const ActiveDirectoryUserSigninRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ActiveDirectoryUserSigninRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActiveDirectoryUserSigninRequest::IsInitialized() const {
  return true;
}

void ActiveDirectoryUserSigninRequest::InternalSwap(ActiveDirectoryUserSigninRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ActiveDirectoryUserSigninRequest::GetTypeName() const {
  return "enterprise_management.ActiveDirectoryUserSigninRequest";
}


// ===================================================================

class ActiveDirectoryUserSigninResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ActiveDirectoryUserSigninResponse>()._impl_._has_bits_);
  static void set_has_auth_redirect_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ActiveDirectoryUserSigninResponse::ActiveDirectoryUserSigninResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ActiveDirectoryUserSigninResponse)
}
ActiveDirectoryUserSigninResponse::ActiveDirectoryUserSigninResponse(const ActiveDirectoryUserSigninResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ActiveDirectoryUserSigninResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.auth_redirect_url_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.auth_redirect_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_redirect_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_auth_redirect_url()) {
    _this->_impl_.auth_redirect_url_.Set(from._internal_auth_redirect_url(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ActiveDirectoryUserSigninResponse)
}

inline void ActiveDirectoryUserSigninResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.auth_redirect_url_){}
  };
  _impl_.auth_redirect_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.auth_redirect_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ActiveDirectoryUserSigninResponse::~ActiveDirectoryUserSigninResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.ActiveDirectoryUserSigninResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActiveDirectoryUserSigninResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.auth_redirect_url_.Destroy();
}

void ActiveDirectoryUserSigninResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActiveDirectoryUserSigninResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ActiveDirectoryUserSigninResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.auth_redirect_url_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ActiveDirectoryUserSigninResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string auth_redirect_url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_auth_redirect_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActiveDirectoryUserSigninResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ActiveDirectoryUserSigninResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string auth_redirect_url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_auth_redirect_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ActiveDirectoryUserSigninResponse)
  return target;
}

size_t ActiveDirectoryUserSigninResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ActiveDirectoryUserSigninResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string auth_redirect_url = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_auth_redirect_url());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActiveDirectoryUserSigninResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ActiveDirectoryUserSigninResponse*>(
      &from));
}

void ActiveDirectoryUserSigninResponse::MergeFrom(const ActiveDirectoryUserSigninResponse& from) {
  ActiveDirectoryUserSigninResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ActiveDirectoryUserSigninResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_auth_redirect_url()) {
    _this->_internal_set_auth_redirect_url(from._internal_auth_redirect_url());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActiveDirectoryUserSigninResponse::CopyFrom(const ActiveDirectoryUserSigninResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ActiveDirectoryUserSigninResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActiveDirectoryUserSigninResponse::IsInitialized() const {
  return true;
}

void ActiveDirectoryUserSigninResponse::InternalSwap(ActiveDirectoryUserSigninResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.auth_redirect_url_, lhs_arena,
      &other->_impl_.auth_redirect_url_, rhs_arena
  );
}

std::string ActiveDirectoryUserSigninResponse::GetTypeName() const {
  return "enterprise_management.ActiveDirectoryUserSigninResponse";
}


// ===================================================================

class TpmVersionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TpmVersionInfo>()._impl_._has_bits_);
  static void set_has_family(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_spec_level(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_manufacturer(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_tpm_model(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_firmware_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_vendor_specific(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gsc_version(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_did_vid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TpmVersionInfo::TpmVersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.TpmVersionInfo)
}
TpmVersionInfo::TpmVersionInfo(const TpmVersionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TpmVersionInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vendor_specific_){}
    , decltype(_impl_.did_vid_){}
    , decltype(_impl_.spec_level_){}
    , decltype(_impl_.family_){}
    , decltype(_impl_.manufacturer_){}
    , decltype(_impl_.firmware_version_){}
    , decltype(_impl_.tpm_model_){}
    , decltype(_impl_.gsc_version_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.vendor_specific_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vendor_specific_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vendor_specific()) {
    _this->_impl_.vendor_specific_.Set(from._internal_vendor_specific(), 
      _this->GetArenaForAllocation());
  }
  _impl_.did_vid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.did_vid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_did_vid()) {
    _this->_impl_.did_vid_.Set(from._internal_did_vid(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.spec_level_, &from._impl_.spec_level_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.gsc_version_) -
    reinterpret_cast<char*>(&_impl_.spec_level_)) + sizeof(_impl_.gsc_version_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.TpmVersionInfo)
}

inline void TpmVersionInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vendor_specific_){}
    , decltype(_impl_.did_vid_){}
    , decltype(_impl_.spec_level_){uint64_t{0u}}
    , decltype(_impl_.family_){0u}
    , decltype(_impl_.manufacturer_){0u}
    , decltype(_impl_.firmware_version_){uint64_t{0u}}
    , decltype(_impl_.tpm_model_){0u}
    , decltype(_impl_.gsc_version_){0}
  };
  _impl_.vendor_specific_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vendor_specific_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.did_vid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.did_vid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TpmVersionInfo::~TpmVersionInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.TpmVersionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TpmVersionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vendor_specific_.Destroy();
  _impl_.did_vid_.Destroy();
}

void TpmVersionInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TpmVersionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.TpmVersionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.vendor_specific_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.did_vid_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.spec_level_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.gsc_version_) -
        reinterpret_cast<char*>(&_impl_.spec_level_)) + sizeof(_impl_.gsc_version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TpmVersionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 family = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_family(&has_bits);
          _impl_.family_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 spec_level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_spec_level(&has_bits);
          _impl_.spec_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 manufacturer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_manufacturer(&has_bits);
          _impl_.manufacturer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tpm_model = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_tpm_model(&has_bits);
          _impl_.tpm_model_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 firmware_version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_firmware_version(&has_bits);
          _impl_.firmware_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string vendor_specific = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_vendor_specific();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.TpmVersionInfo.GscVersion gsc_version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::TpmVersionInfo_GscVersion_IsValid(val))) {
            _internal_set_gsc_version(static_cast<::enterprise_management::TpmVersionInfo_GscVersion>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string did_vid = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_did_vid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TpmVersionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.TpmVersionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 family = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_family(), target);
  }

  // optional uint64 spec_level = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_spec_level(), target);
  }

  // optional uint32 manufacturer = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_manufacturer(), target);
  }

  // optional uint32 tpm_model = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_tpm_model(), target);
  }

  // optional uint64 firmware_version = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_firmware_version(), target);
  }

  // optional string vendor_specific = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_vendor_specific(), target);
  }

  // optional .enterprise_management.TpmVersionInfo.GscVersion gsc_version = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_gsc_version(), target);
  }

  // optional string did_vid = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_did_vid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.TpmVersionInfo)
  return target;
}

size_t TpmVersionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.TpmVersionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string vendor_specific = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_vendor_specific());
    }

    // optional string did_vid = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_did_vid());
    }

    // optional uint64 spec_level = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_spec_level());
    }

    // optional uint32 family = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_family());
    }

    // optional uint32 manufacturer = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_manufacturer());
    }

    // optional uint64 firmware_version = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_firmware_version());
    }

    // optional uint32 tpm_model = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tpm_model());
    }

    // optional .enterprise_management.TpmVersionInfo.GscVersion gsc_version = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_gsc_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TpmVersionInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TpmVersionInfo*>(
      &from));
}

void TpmVersionInfo::MergeFrom(const TpmVersionInfo& from) {
  TpmVersionInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.TpmVersionInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_vendor_specific(from._internal_vendor_specific());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_did_vid(from._internal_did_vid());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.spec_level_ = from._impl_.spec_level_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.family_ = from._impl_.family_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.manufacturer_ = from._impl_.manufacturer_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.firmware_version_ = from._impl_.firmware_version_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.tpm_model_ = from._impl_.tpm_model_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.gsc_version_ = from._impl_.gsc_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TpmVersionInfo::CopyFrom(const TpmVersionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.TpmVersionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TpmVersionInfo::IsInitialized() const {
  return true;
}

void TpmVersionInfo::InternalSwap(TpmVersionInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vendor_specific_, lhs_arena,
      &other->_impl_.vendor_specific_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.did_vid_, lhs_arena,
      &other->_impl_.did_vid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TpmVersionInfo, _impl_.gsc_version_)
      + sizeof(TpmVersionInfo::_impl_.gsc_version_)
      - PROTOBUF_FIELD_OFFSET(TpmVersionInfo, _impl_.spec_level_)>(
          reinterpret_cast<char*>(&_impl_.spec_level_),
          reinterpret_cast<char*>(&other->_impl_.spec_level_));
}

std::string TpmVersionInfo::GetTypeName() const {
  return "enterprise_management.TpmVersionInfo";
}


// ===================================================================

class TpmStatusInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TpmStatusInfo>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_owned(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tpm_initialized(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_attestation_prepared(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_attestation_enrolled(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_dictionary_attack_counter(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_dictionary_attack_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_dictionary_attack_lockout_in_effect(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_dictionary_attack_lockout_seconds_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_boot_lockbox_finalized(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_owner_password_is_present(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::enterprise_management::TpmSupportedFeatures& tpm_supported_features(const TpmStatusInfo* msg);
  static void set_has_tpm_supported_features(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::enterprise_management::TpmSupportedFeatures&
TpmStatusInfo::_Internal::tpm_supported_features(const TpmStatusInfo* msg) {
  return *msg->_impl_.tpm_supported_features_;
}
TpmStatusInfo::TpmStatusInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.TpmStatusInfo)
}
TpmStatusInfo::TpmStatusInfo(const TpmStatusInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TpmStatusInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tpm_supported_features_){nullptr}
    , decltype(_impl_.enabled_){}
    , decltype(_impl_.owned_){}
    , decltype(_impl_.tpm_initialized_){}
    , decltype(_impl_.attestation_prepared_){}
    , decltype(_impl_.dictionary_attack_counter_){}
    , decltype(_impl_.dictionary_attack_threshold_){}
    , decltype(_impl_.attestation_enrolled_){}
    , decltype(_impl_.dictionary_attack_lockout_in_effect_){}
    , decltype(_impl_.boot_lockbox_finalized_){}
    , decltype(_impl_.owner_password_is_present_){}
    , decltype(_impl_.dictionary_attack_lockout_seconds_remaining_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_tpm_supported_features()) {
    _this->_impl_.tpm_supported_features_ = new ::enterprise_management::TpmSupportedFeatures(*from._impl_.tpm_supported_features_);
  }
  ::memcpy(&_impl_.enabled_, &from._impl_.enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dictionary_attack_lockout_seconds_remaining_) -
    reinterpret_cast<char*>(&_impl_.enabled_)) + sizeof(_impl_.dictionary_attack_lockout_seconds_remaining_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.TpmStatusInfo)
}

inline void TpmStatusInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tpm_supported_features_){nullptr}
    , decltype(_impl_.enabled_){false}
    , decltype(_impl_.owned_){false}
    , decltype(_impl_.tpm_initialized_){false}
    , decltype(_impl_.attestation_prepared_){false}
    , decltype(_impl_.dictionary_attack_counter_){0}
    , decltype(_impl_.dictionary_attack_threshold_){0}
    , decltype(_impl_.attestation_enrolled_){false}
    , decltype(_impl_.dictionary_attack_lockout_in_effect_){false}
    , decltype(_impl_.boot_lockbox_finalized_){false}
    , decltype(_impl_.owner_password_is_present_){false}
    , decltype(_impl_.dictionary_attack_lockout_seconds_remaining_){0}
  };
}

TpmStatusInfo::~TpmStatusInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.TpmStatusInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TpmStatusInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tpm_supported_features_;
}

void TpmStatusInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TpmStatusInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.TpmStatusInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.tpm_supported_features_ != nullptr);
    _impl_.tpm_supported_features_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.attestation_enrolled_) -
        reinterpret_cast<char*>(&_impl_.enabled_)) + sizeof(_impl_.attestation_enrolled_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.dictionary_attack_lockout_in_effect_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.dictionary_attack_lockout_seconds_remaining_) -
        reinterpret_cast<char*>(&_impl_.dictionary_attack_lockout_in_effect_)) + sizeof(_impl_.dictionary_attack_lockout_seconds_remaining_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TpmStatusInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool owned = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_owned(&has_bits);
          _impl_.owned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool tpm_initialized = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_tpm_initialized(&has_bits);
          _impl_.tpm_initialized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool attestation_prepared = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_attestation_prepared(&has_bits);
          _impl_.attestation_prepared_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool attestation_enrolled = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_attestation_enrolled(&has_bits);
          _impl_.attestation_enrolled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dictionary_attack_counter = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_dictionary_attack_counter(&has_bits);
          _impl_.dictionary_attack_counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dictionary_attack_threshold = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_dictionary_attack_threshold(&has_bits);
          _impl_.dictionary_attack_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool dictionary_attack_lockout_in_effect = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_dictionary_attack_lockout_in_effect(&has_bits);
          _impl_.dictionary_attack_lockout_in_effect_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dictionary_attack_lockout_seconds_remaining = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_dictionary_attack_lockout_seconds_remaining(&has_bits);
          _impl_.dictionary_attack_lockout_seconds_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool boot_lockbox_finalized = 10 [deprecated = true];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_boot_lockbox_finalized(&has_bits);
          _impl_.boot_lockbox_finalized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool owner_password_is_present = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_owner_password_is_present(&has_bits);
          _impl_.owner_password_is_present_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.TpmSupportedFeatures tpm_supported_features = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_tpm_supported_features(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TpmStatusInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.TpmStatusInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool enabled = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  // optional bool owned = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_owned(), target);
  }

  // optional bool tpm_initialized = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_tpm_initialized(), target);
  }

  // optional bool attestation_prepared = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_attestation_prepared(), target);
  }

  // optional bool attestation_enrolled = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_attestation_enrolled(), target);
  }

  // optional int32 dictionary_attack_counter = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_dictionary_attack_counter(), target);
  }

  // optional int32 dictionary_attack_threshold = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_dictionary_attack_threshold(), target);
  }

  // optional bool dictionary_attack_lockout_in_effect = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_dictionary_attack_lockout_in_effect(), target);
  }

  // optional int32 dictionary_attack_lockout_seconds_remaining = 9;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_dictionary_attack_lockout_seconds_remaining(), target);
  }

  // optional bool boot_lockbox_finalized = 10 [deprecated = true];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_boot_lockbox_finalized(), target);
  }

  // optional bool owner_password_is_present = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_owner_password_is_present(), target);
  }

  // optional .enterprise_management.TpmSupportedFeatures tpm_supported_features = 12;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::tpm_supported_features(this),
        _Internal::tpm_supported_features(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.TpmStatusInfo)
  return target;
}

size_t TpmStatusInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.TpmStatusInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .enterprise_management.TpmSupportedFeatures tpm_supported_features = 12;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tpm_supported_features_);
    }

    // optional bool enabled = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool owned = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool tpm_initialized = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool attestation_prepared = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional int32 dictionary_attack_counter = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dictionary_attack_counter());
    }

    // optional int32 dictionary_attack_threshold = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dictionary_attack_threshold());
    }

    // optional bool attestation_enrolled = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional bool dictionary_attack_lockout_in_effect = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool boot_lockbox_finalized = 10 [deprecated = true];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool owner_password_is_present = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional int32 dictionary_attack_lockout_seconds_remaining = 9;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dictionary_attack_lockout_seconds_remaining());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TpmStatusInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TpmStatusInfo*>(
      &from));
}

void TpmStatusInfo::MergeFrom(const TpmStatusInfo& from) {
  TpmStatusInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.TpmStatusInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_tpm_supported_features()->::enterprise_management::TpmSupportedFeatures::MergeFrom(
          from._internal_tpm_supported_features());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.enabled_ = from._impl_.enabled_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.owned_ = from._impl_.owned_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.tpm_initialized_ = from._impl_.tpm_initialized_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.attestation_prepared_ = from._impl_.attestation_prepared_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.dictionary_attack_counter_ = from._impl_.dictionary_attack_counter_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.dictionary_attack_threshold_ = from._impl_.dictionary_attack_threshold_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.attestation_enrolled_ = from._impl_.attestation_enrolled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.dictionary_attack_lockout_in_effect_ = from._impl_.dictionary_attack_lockout_in_effect_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.boot_lockbox_finalized_ = from._impl_.boot_lockbox_finalized_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.owner_password_is_present_ = from._impl_.owner_password_is_present_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.dictionary_attack_lockout_seconds_remaining_ = from._impl_.dictionary_attack_lockout_seconds_remaining_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TpmStatusInfo::CopyFrom(const TpmStatusInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.TpmStatusInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TpmStatusInfo::IsInitialized() const {
  return true;
}

void TpmStatusInfo::InternalSwap(TpmStatusInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TpmStatusInfo, _impl_.dictionary_attack_lockout_seconds_remaining_)
      + sizeof(TpmStatusInfo::_impl_.dictionary_attack_lockout_seconds_remaining_)
      - PROTOBUF_FIELD_OFFSET(TpmStatusInfo, _impl_.tpm_supported_features_)>(
          reinterpret_cast<char*>(&_impl_.tpm_supported_features_),
          reinterpret_cast<char*>(&other->_impl_.tpm_supported_features_));
}

std::string TpmStatusInfo::GetTypeName() const {
  return "enterprise_management.TpmStatusInfo";
}


// ===================================================================

class TpmSupportedFeatures::_Internal {
 public:
  using HasBits = decltype(std::declval<TpmSupportedFeatures>()._impl_._has_bits_);
  static void set_has_is_allowed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_support_pinweaver(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_support_runtime_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_support_u2f(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

TpmSupportedFeatures::TpmSupportedFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.TpmSupportedFeatures)
}
TpmSupportedFeatures::TpmSupportedFeatures(const TpmSupportedFeatures& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TpmSupportedFeatures* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.is_allowed_){}
    , decltype(_impl_.support_pinweaver_){}
    , decltype(_impl_.support_runtime_selection_){}
    , decltype(_impl_.support_u2f_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.is_allowed_, &from._impl_.is_allowed_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.support_u2f_) -
    reinterpret_cast<char*>(&_impl_.is_allowed_)) + sizeof(_impl_.support_u2f_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.TpmSupportedFeatures)
}

inline void TpmSupportedFeatures::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.is_allowed_){false}
    , decltype(_impl_.support_pinweaver_){false}
    , decltype(_impl_.support_runtime_selection_){false}
    , decltype(_impl_.support_u2f_){false}
  };
}

TpmSupportedFeatures::~TpmSupportedFeatures() {
  // @@protoc_insertion_point(destructor:enterprise_management.TpmSupportedFeatures)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TpmSupportedFeatures::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TpmSupportedFeatures::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TpmSupportedFeatures::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.TpmSupportedFeatures)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.is_allowed_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.support_u2f_) -
      reinterpret_cast<char*>(&_impl_.is_allowed_)) + sizeof(_impl_.support_u2f_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TpmSupportedFeatures::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool is_allowed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_is_allowed(&has_bits);
          _impl_.is_allowed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool support_pinweaver = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_support_pinweaver(&has_bits);
          _impl_.support_pinweaver_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool support_runtime_selection = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_support_runtime_selection(&has_bits);
          _impl_.support_runtime_selection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool support_u2f = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_support_u2f(&has_bits);
          _impl_.support_u2f_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TpmSupportedFeatures::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.TpmSupportedFeatures)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool is_allowed = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_allowed(), target);
  }

  // optional bool support_pinweaver = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_support_pinweaver(), target);
  }

  // optional bool support_runtime_selection = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_support_runtime_selection(), target);
  }

  // optional bool support_u2f = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_support_u2f(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.TpmSupportedFeatures)
  return target;
}

size_t TpmSupportedFeatures::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.TpmSupportedFeatures)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bool is_allowed = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool support_pinweaver = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool support_runtime_selection = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool support_u2f = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TpmSupportedFeatures::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TpmSupportedFeatures*>(
      &from));
}

void TpmSupportedFeatures::MergeFrom(const TpmSupportedFeatures& from) {
  TpmSupportedFeatures* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.TpmSupportedFeatures)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.is_allowed_ = from._impl_.is_allowed_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.support_pinweaver_ = from._impl_.support_pinweaver_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.support_runtime_selection_ = from._impl_.support_runtime_selection_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.support_u2f_ = from._impl_.support_u2f_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TpmSupportedFeatures::CopyFrom(const TpmSupportedFeatures& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.TpmSupportedFeatures)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TpmSupportedFeatures::IsInitialized() const {
  return true;
}

void TpmSupportedFeatures::InternalSwap(TpmSupportedFeatures* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TpmSupportedFeatures, _impl_.support_u2f_)
      + sizeof(TpmSupportedFeatures::_impl_.support_u2f_)
      - PROTOBUF_FIELD_OFFSET(TpmSupportedFeatures, _impl_.is_allowed_)>(
          reinterpret_cast<char*>(&_impl_.is_allowed_),
          reinterpret_cast<char*>(&other->_impl_.is_allowed_));
}

std::string TpmSupportedFeatures::GetTypeName() const {
  return "enterprise_management.TpmSupportedFeatures";
}


// ===================================================================

class SystemState::_Internal {
 public:
};

SystemState::SystemState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.SystemState)
}
SystemState::SystemState(const SystemState& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SystemState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.volume_infos_){from._impl_.volume_infos_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.SystemState)
}

inline void SystemState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.volume_infos_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SystemState::~SystemState() {
  // @@protoc_insertion_point(destructor:enterprise_management.SystemState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.volume_infos_.~RepeatedPtrField();
}

void SystemState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SystemState::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.SystemState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.volume_infos_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .enterprise_management.VolumeInfo volume_infos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_volume_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.SystemState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .enterprise_management.VolumeInfo volume_infos = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_volume_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_volume_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.SystemState)
  return target;
}

size_t SystemState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.SystemState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.VolumeInfo volume_infos = 1;
  total_size += 1UL * this->_internal_volume_infos_size();
  for (const auto& msg : this->_impl_.volume_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemState::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemState*>(
      &from));
}

void SystemState::MergeFrom(const SystemState& from) {
  SystemState* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.SystemState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.volume_infos_.MergeFrom(from._impl_.volume_infos_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemState::CopyFrom(const SystemState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.SystemState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemState::IsInitialized() const {
  return true;
}

void SystemState::InternalSwap(SystemState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.volume_infos_.InternalSwap(&other->_impl_.volume_infos_);
}

std::string SystemState::GetTypeName() const {
  return "enterprise_management.SystemState";
}


// ===================================================================

class ExtensionInstallReportLogEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<ExtensionInstallReportLogEvent>()._impl_._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_event_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_stateful_total(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_stateful_free(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_online(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_session_state_change_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_failure_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_installation_stage(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_downloading_stage(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_extension_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_user_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_is_new_user(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_is_misconfiguration_failure(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_install_creation_stage(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_download_cache_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_unpacker_failure_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_manifest_invalid_error(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_crx_install_error_detail(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_fetch_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_fetch_tries(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
};

ExtensionInstallReportLogEvent::ExtensionInstallReportLogEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ExtensionInstallReportLogEvent)
}
ExtensionInstallReportLogEvent::ExtensionInstallReportLogEvent(const ExtensionInstallReportLogEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ExtensionInstallReportLogEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.stateful_total_){}
    , decltype(_impl_.stateful_free_){}
    , decltype(_impl_.event_type_){}
    , decltype(_impl_.session_state_change_type_){}
    , decltype(_impl_.failure_reason_){}
    , decltype(_impl_.installation_stage_){}
    , decltype(_impl_.downloading_stage_){}
    , decltype(_impl_.extension_type_){}
    , decltype(_impl_.online_){}
    , decltype(_impl_.is_new_user_){}
    , decltype(_impl_.is_misconfiguration_failure_){}
    , decltype(_impl_.user_type_){}
    , decltype(_impl_.install_creation_stage_){}
    , decltype(_impl_.download_cache_status_){}
    , decltype(_impl_.unpacker_failure_reason_){}
    , decltype(_impl_.manifest_invalid_error_){}
    , decltype(_impl_.crx_install_error_detail_){}
    , decltype(_impl_.fetch_error_code_){}
    , decltype(_impl_.fetch_tries_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fetch_tries_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.fetch_tries_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ExtensionInstallReportLogEvent)
}

inline void ExtensionInstallReportLogEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , decltype(_impl_.stateful_total_){int64_t{0}}
    , decltype(_impl_.stateful_free_){int64_t{0}}
    , decltype(_impl_.event_type_){0}
    , decltype(_impl_.session_state_change_type_){0}
    , decltype(_impl_.failure_reason_){0}
    , decltype(_impl_.installation_stage_){0}
    , decltype(_impl_.downloading_stage_){0}
    , decltype(_impl_.extension_type_){0}
    , decltype(_impl_.online_){false}
    , decltype(_impl_.is_new_user_){false}
    , decltype(_impl_.is_misconfiguration_failure_){false}
    , decltype(_impl_.user_type_){0}
    , decltype(_impl_.install_creation_stage_){0}
    , decltype(_impl_.download_cache_status_){0}
    , decltype(_impl_.unpacker_failure_reason_){0}
    , decltype(_impl_.manifest_invalid_error_){0}
    , decltype(_impl_.crx_install_error_detail_){0}
    , decltype(_impl_.fetch_error_code_){0}
    , decltype(_impl_.fetch_tries_){0}
  };
}

ExtensionInstallReportLogEvent::~ExtensionInstallReportLogEvent() {
  // @@protoc_insertion_point(destructor:enterprise_management.ExtensionInstallReportLogEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExtensionInstallReportLogEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ExtensionInstallReportLogEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExtensionInstallReportLogEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ExtensionInstallReportLogEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.downloading_stage_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.downloading_stage_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.extension_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.unpacker_failure_reason_) -
        reinterpret_cast<char*>(&_impl_.extension_type_)) + sizeof(_impl_.unpacker_failure_reason_));
  }
  if (cached_has_bits & 0x000f0000u) {
    ::memset(&_impl_.manifest_invalid_error_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.fetch_tries_) -
        reinterpret_cast<char*>(&_impl_.manifest_invalid_error_)) + sizeof(_impl_.fetch_tries_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ExtensionInstallReportLogEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ExtensionInstallReportLogEvent.EventType event_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::ExtensionInstallReportLogEvent_EventType_IsValid(val))) {
            _internal_set_event_type(static_cast<::enterprise_management::ExtensionInstallReportLogEvent_EventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 stateful_total = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_stateful_total(&has_bits);
          _impl_.stateful_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 stateful_free = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_stateful_free(&has_bits);
          _impl_.stateful_free_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool online = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_online(&has_bits);
          _impl_.online_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ExtensionInstallReportLogEvent.SessionStateChangeType session_state_change_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType_IsValid(val))) {
            _internal_set_session_state_change_type(static_cast<::enterprise_management::ExtensionInstallReportLogEvent_SessionStateChangeType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ExtensionInstallReportLogEvent.FailureReason failure_reason = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::ExtensionInstallReportLogEvent_FailureReason_IsValid(val))) {
            _internal_set_failure_reason(static_cast<::enterprise_management::ExtensionInstallReportLogEvent_FailureReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ExtensionInstallReportLogEvent.InstallationStage installation_stage = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::ExtensionInstallReportLogEvent_InstallationStage_IsValid(val))) {
            _internal_set_installation_stage(static_cast<::enterprise_management::ExtensionInstallReportLogEvent_InstallationStage>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ExtensionInstallReportLogEvent.DownloadingStage downloading_stage = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::ExtensionInstallReportLogEvent_DownloadingStage_IsValid(val))) {
            _internal_set_downloading_stage(static_cast<::enterprise_management::ExtensionInstallReportLogEvent_DownloadingStage>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.Extension.ExtensionType extension_type = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::Extension_ExtensionType_IsValid(val))) {
            _internal_set_extension_type(static_cast<::enterprise_management::Extension_ExtensionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ExtensionInstallReportLogEvent.UserType user_type = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::ExtensionInstallReportLogEvent_UserType_IsValid(val))) {
            _internal_set_user_type(static_cast<::enterprise_management::ExtensionInstallReportLogEvent_UserType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(11, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool is_new_user = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_is_new_user(&has_bits);
          _impl_.is_new_user_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_misconfiguration_failure = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_is_misconfiguration_failure(&has_bits);
          _impl_.is_misconfiguration_failure_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ExtensionInstallReportLogEvent.InstallCreationStage install_creation_stage = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::ExtensionInstallReportLogEvent_InstallCreationStage_IsValid(val))) {
            _internal_set_install_creation_stage(static_cast<::enterprise_management::ExtensionInstallReportLogEvent_InstallCreationStage>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(14, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ExtensionInstallReportLogEvent.DownloadCacheStatus download_cache_status = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::ExtensionInstallReportLogEvent_DownloadCacheStatus_IsValid(val))) {
            _internal_set_download_cache_status(static_cast<::enterprise_management::ExtensionInstallReportLogEvent_DownloadCacheStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(15, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ExtensionInstallReportLogEvent.SandboxedUnpackerFailureReason unpacker_failure_reason = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason_IsValid(val))) {
            _internal_set_unpacker_failure_reason(static_cast<::enterprise_management::ExtensionInstallReportLogEvent_SandboxedUnpackerFailureReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(16, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ExtensionInstallReportLogEvent.ManifestInvalidError manifest_invalid_error = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::ExtensionInstallReportLogEvent_ManifestInvalidError_IsValid(val))) {
            _internal_set_manifest_invalid_error(static_cast<::enterprise_management::ExtensionInstallReportLogEvent_ManifestInvalidError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(17, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ExtensionInstallReportLogEvent.CrxInstallErrorDetail crx_install_error_detail = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::ExtensionInstallReportLogEvent_CrxInstallErrorDetail_IsValid(val))) {
            _internal_set_crx_install_error_detail(static_cast<::enterprise_management::ExtensionInstallReportLogEvent_CrxInstallErrorDetail>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(18, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 fetch_error_code = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_fetch_error_code(&has_bits);
          _impl_.fetch_error_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 fetch_tries = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_fetch_tries(&has_bits);
          _impl_.fetch_tries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExtensionInstallReportLogEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ExtensionInstallReportLogEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp(), target);
  }

  // optional .enterprise_management.ExtensionInstallReportLogEvent.EventType event_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_event_type(), target);
  }

  // optional int64 stateful_total = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_stateful_total(), target);
  }

  // optional int64 stateful_free = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_stateful_free(), target);
  }

  // optional bool online = 5;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_online(), target);
  }

  // optional .enterprise_management.ExtensionInstallReportLogEvent.SessionStateChangeType session_state_change_type = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_session_state_change_type(), target);
  }

  // optional .enterprise_management.ExtensionInstallReportLogEvent.FailureReason failure_reason = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_failure_reason(), target);
  }

  // optional .enterprise_management.ExtensionInstallReportLogEvent.InstallationStage installation_stage = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_installation_stage(), target);
  }

  // optional .enterprise_management.ExtensionInstallReportLogEvent.DownloadingStage downloading_stage = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_downloading_stage(), target);
  }

  // optional .enterprise_management.Extension.ExtensionType extension_type = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_extension_type(), target);
  }

  // optional .enterprise_management.ExtensionInstallReportLogEvent.UserType user_type = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      11, this->_internal_user_type(), target);
  }

  // optional bool is_new_user = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_is_new_user(), target);
  }

  // optional bool is_misconfiguration_failure = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_is_misconfiguration_failure(), target);
  }

  // optional .enterprise_management.ExtensionInstallReportLogEvent.InstallCreationStage install_creation_stage = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      14, this->_internal_install_creation_stage(), target);
  }

  // optional .enterprise_management.ExtensionInstallReportLogEvent.DownloadCacheStatus download_cache_status = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      15, this->_internal_download_cache_status(), target);
  }

  // optional .enterprise_management.ExtensionInstallReportLogEvent.SandboxedUnpackerFailureReason unpacker_failure_reason = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      16, this->_internal_unpacker_failure_reason(), target);
  }

  // optional .enterprise_management.ExtensionInstallReportLogEvent.ManifestInvalidError manifest_invalid_error = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      17, this->_internal_manifest_invalid_error(), target);
  }

  // optional .enterprise_management.ExtensionInstallReportLogEvent.CrxInstallErrorDetail crx_install_error_detail = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      18, this->_internal_crx_install_error_detail(), target);
  }

  // optional int32 fetch_error_code = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(19, this->_internal_fetch_error_code(), target);
  }

  // optional int32 fetch_tries = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(20, this->_internal_fetch_tries(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ExtensionInstallReportLogEvent)
  return target;
}

size_t ExtensionInstallReportLogEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ExtensionInstallReportLogEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int64 timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
    }

    // optional int64 stateful_total = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_stateful_total());
    }

    // optional int64 stateful_free = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_stateful_free());
    }

    // optional .enterprise_management.ExtensionInstallReportLogEvent.EventType event_type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_event_type());
    }

    // optional .enterprise_management.ExtensionInstallReportLogEvent.SessionStateChangeType session_state_change_type = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_session_state_change_type());
    }

    // optional .enterprise_management.ExtensionInstallReportLogEvent.FailureReason failure_reason = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_failure_reason());
    }

    // optional .enterprise_management.ExtensionInstallReportLogEvent.InstallationStage installation_stage = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_installation_stage());
    }

    // optional .enterprise_management.ExtensionInstallReportLogEvent.DownloadingStage downloading_stage = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_downloading_stage());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .enterprise_management.Extension.ExtensionType extension_type = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_extension_type());
    }

    // optional bool online = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool is_new_user = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool is_misconfiguration_failure = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional .enterprise_management.ExtensionInstallReportLogEvent.UserType user_type = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_user_type());
    }

    // optional .enterprise_management.ExtensionInstallReportLogEvent.InstallCreationStage install_creation_stage = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_install_creation_stage());
    }

    // optional .enterprise_management.ExtensionInstallReportLogEvent.DownloadCacheStatus download_cache_status = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_download_cache_status());
    }

    // optional .enterprise_management.ExtensionInstallReportLogEvent.SandboxedUnpackerFailureReason unpacker_failure_reason = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_unpacker_failure_reason());
    }

  }
  if (cached_has_bits & 0x000f0000u) {
    // optional .enterprise_management.ExtensionInstallReportLogEvent.ManifestInvalidError manifest_invalid_error = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_manifest_invalid_error());
    }

    // optional .enterprise_management.ExtensionInstallReportLogEvent.CrxInstallErrorDetail crx_install_error_detail = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_crx_install_error_detail());
    }

    // optional int32 fetch_error_code = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_fetch_error_code());
    }

    // optional int32 fetch_tries = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_fetch_tries());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExtensionInstallReportLogEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ExtensionInstallReportLogEvent*>(
      &from));
}

void ExtensionInstallReportLogEvent::MergeFrom(const ExtensionInstallReportLogEvent& from) {
  ExtensionInstallReportLogEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ExtensionInstallReportLogEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.stateful_total_ = from._impl_.stateful_total_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.stateful_free_ = from._impl_.stateful_free_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.event_type_ = from._impl_.event_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.session_state_change_type_ = from._impl_.session_state_change_type_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.failure_reason_ = from._impl_.failure_reason_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.installation_stage_ = from._impl_.installation_stage_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.downloading_stage_ = from._impl_.downloading_stage_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.extension_type_ = from._impl_.extension_type_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.online_ = from._impl_.online_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.is_new_user_ = from._impl_.is_new_user_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.is_misconfiguration_failure_ = from._impl_.is_misconfiguration_failure_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.user_type_ = from._impl_.user_type_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.install_creation_stage_ = from._impl_.install_creation_stage_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.download_cache_status_ = from._impl_.download_cache_status_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.unpacker_failure_reason_ = from._impl_.unpacker_failure_reason_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x000f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.manifest_invalid_error_ = from._impl_.manifest_invalid_error_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.crx_install_error_detail_ = from._impl_.crx_install_error_detail_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.fetch_error_code_ = from._impl_.fetch_error_code_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.fetch_tries_ = from._impl_.fetch_tries_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionInstallReportLogEvent::CopyFrom(const ExtensionInstallReportLogEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ExtensionInstallReportLogEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExtensionInstallReportLogEvent::IsInitialized() const {
  return true;
}

void ExtensionInstallReportLogEvent::InternalSwap(ExtensionInstallReportLogEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExtensionInstallReportLogEvent, _impl_.fetch_tries_)
      + sizeof(ExtensionInstallReportLogEvent::_impl_.fetch_tries_)
      - PROTOBUF_FIELD_OFFSET(ExtensionInstallReportLogEvent, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

std::string ExtensionInstallReportLogEvent::GetTypeName() const {
  return "enterprise_management.ExtensionInstallReportLogEvent";
}


// ===================================================================

class AppInstallReportLogEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AppInstallReportLogEvent>()._impl_._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_event_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_stateful_total(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_stateful_free(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_clouddps_response(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_phonesky_log(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_online(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_session_state_change_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_android_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

AppInstallReportLogEvent::AppInstallReportLogEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AppInstallReportLogEvent)
}
AppInstallReportLogEvent::AppInstallReportLogEvent(const AppInstallReportLogEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AppInstallReportLogEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.phonesky_log_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.stateful_total_){}
    , decltype(_impl_.event_type_){}
    , decltype(_impl_.clouddps_response_){}
    , decltype(_impl_.stateful_free_){}
    , decltype(_impl_.online_){}
    , decltype(_impl_.session_state_change_type_){}
    , decltype(_impl_.android_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.phonesky_log_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phonesky_log_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_phonesky_log()) {
    _this->_impl_.phonesky_log_.Set(from._internal_phonesky_log(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.android_id_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.android_id_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AppInstallReportLogEvent)
}

inline void AppInstallReportLogEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.phonesky_log_){}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , decltype(_impl_.stateful_total_){int64_t{0}}
    , decltype(_impl_.event_type_){0}
    , decltype(_impl_.clouddps_response_){0}
    , decltype(_impl_.stateful_free_){int64_t{0}}
    , decltype(_impl_.online_){false}
    , decltype(_impl_.session_state_change_type_){0}
    , decltype(_impl_.android_id_){int64_t{0}}
  };
  _impl_.phonesky_log_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phonesky_log_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AppInstallReportLogEvent::~AppInstallReportLogEvent() {
  // @@protoc_insertion_point(destructor:enterprise_management.AppInstallReportLogEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AppInstallReportLogEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.phonesky_log_.Destroy();
}

void AppInstallReportLogEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AppInstallReportLogEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AppInstallReportLogEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.phonesky_log_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.session_state_change_type_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.session_state_change_type_));
  }
  _impl_.android_id_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AppInstallReportLogEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AppInstallReportLogEvent.EventType event_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::AppInstallReportLogEvent_EventType_IsValid(val))) {
            _internal_set_event_type(static_cast<::enterprise_management::AppInstallReportLogEvent_EventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 stateful_total = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_stateful_total(&has_bits);
          _impl_.stateful_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 stateful_free = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_stateful_free(&has_bits);
          _impl_.stateful_free_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 clouddps_response = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_clouddps_response(&has_bits);
          _impl_.clouddps_response_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string phonesky_log = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_phonesky_log();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool online = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_online(&has_bits);
          _impl_.online_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AppInstallReportLogEvent.SessionStateChangeType session_state_change_type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType_IsValid(val))) {
            _internal_set_session_state_change_type(static_cast<::enterprise_management::AppInstallReportLogEvent_SessionStateChangeType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 android_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_android_id(&has_bits);
          _impl_.android_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AppInstallReportLogEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AppInstallReportLogEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp(), target);
  }

  // optional .enterprise_management.AppInstallReportLogEvent.EventType event_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_event_type(), target);
  }

  // optional int64 stateful_total = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_stateful_total(), target);
  }

  // optional int64 stateful_free = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_stateful_free(), target);
  }

  // optional int32 clouddps_response = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_clouddps_response(), target);
  }

  // optional string phonesky_log = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_phonesky_log(), target);
  }

  // optional bool online = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_online(), target);
  }

  // optional .enterprise_management.AppInstallReportLogEvent.SessionStateChangeType session_state_change_type = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_session_state_change_type(), target);
  }

  // optional int64 android_id = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(9, this->_internal_android_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AppInstallReportLogEvent)
  return target;
}

size_t AppInstallReportLogEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AppInstallReportLogEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string phonesky_log = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_phonesky_log());
    }

    // optional int64 timestamp = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
    }

    // optional int64 stateful_total = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_stateful_total());
    }

    // optional .enterprise_management.AppInstallReportLogEvent.EventType event_type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_event_type());
    }

    // optional int32 clouddps_response = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_clouddps_response());
    }

    // optional int64 stateful_free = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_stateful_free());
    }

    // optional bool online = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional .enterprise_management.AppInstallReportLogEvent.SessionStateChangeType session_state_change_type = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_session_state_change_type());
    }

  }
  // optional int64 android_id = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_android_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AppInstallReportLogEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AppInstallReportLogEvent*>(
      &from));
}

void AppInstallReportLogEvent::MergeFrom(const AppInstallReportLogEvent& from) {
  AppInstallReportLogEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AppInstallReportLogEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_phonesky_log(from._internal_phonesky_log());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.stateful_total_ = from._impl_.stateful_total_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.event_type_ = from._impl_.event_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.clouddps_response_ = from._impl_.clouddps_response_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.stateful_free_ = from._impl_.stateful_free_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.online_ = from._impl_.online_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.session_state_change_type_ = from._impl_.session_state_change_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_android_id(from._internal_android_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AppInstallReportLogEvent::CopyFrom(const AppInstallReportLogEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AppInstallReportLogEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AppInstallReportLogEvent::IsInitialized() const {
  return true;
}

void AppInstallReportLogEvent::InternalSwap(AppInstallReportLogEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.phonesky_log_, lhs_arena,
      &other->_impl_.phonesky_log_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AppInstallReportLogEvent, _impl_.android_id_)
      + sizeof(AppInstallReportLogEvent::_impl_.android_id_)
      - PROTOBUF_FIELD_OFFSET(AppInstallReportLogEvent, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

std::string AppInstallReportLogEvent::GetTypeName() const {
  return "enterprise_management.AppInstallReportLogEvent";
}


// ===================================================================

class ExtensionInstallReport::_Internal {
 public:
  using HasBits = decltype(std::declval<ExtensionInstallReport>()._impl_._has_bits_);
  static void set_has_extension_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_incomplete(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ExtensionInstallReport::ExtensionInstallReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ExtensionInstallReport)
}
ExtensionInstallReport::ExtensionInstallReport(const ExtensionInstallReport& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ExtensionInstallReport* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.logs_){from._impl_.logs_}
    , decltype(_impl_.extension_id_){}
    , decltype(_impl_.incomplete_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.extension_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extension_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_extension_id()) {
    _this->_impl_.extension_id_.Set(from._internal_extension_id(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.incomplete_ = from._impl_.incomplete_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ExtensionInstallReport)
}

inline void ExtensionInstallReport::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.logs_){arena}
    , decltype(_impl_.extension_id_){}
    , decltype(_impl_.incomplete_){false}
  };
  _impl_.extension_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extension_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExtensionInstallReport::~ExtensionInstallReport() {
  // @@protoc_insertion_point(destructor:enterprise_management.ExtensionInstallReport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExtensionInstallReport::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.logs_.~RepeatedPtrField();
  _impl_.extension_id_.Destroy();
}

void ExtensionInstallReport::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExtensionInstallReport::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ExtensionInstallReport)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.logs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.extension_id_.ClearNonDefaultToEmpty();
  }
  _impl_.incomplete_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ExtensionInstallReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string extension_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_extension_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool incomplete = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_incomplete(&has_bits);
          _impl_.incomplete_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.ExtensionInstallReportLogEvent logs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_logs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExtensionInstallReport::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ExtensionInstallReport)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string extension_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_extension_id(), target);
  }

  // optional bool incomplete = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_incomplete(), target);
  }

  // repeated .enterprise_management.ExtensionInstallReportLogEvent logs = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_logs_size()); i < n; i++) {
    const auto& repfield = this->_internal_logs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ExtensionInstallReport)
  return target;
}

size_t ExtensionInstallReport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ExtensionInstallReport)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.ExtensionInstallReportLogEvent logs = 3;
  total_size += 1UL * this->_internal_logs_size();
  for (const auto& msg : this->_impl_.logs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string extension_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_extension_id());
    }

    // optional bool incomplete = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExtensionInstallReport::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ExtensionInstallReport*>(
      &from));
}

void ExtensionInstallReport::MergeFrom(const ExtensionInstallReport& from) {
  ExtensionInstallReport* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ExtensionInstallReport)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.logs_.MergeFrom(from._impl_.logs_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_extension_id(from._internal_extension_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.incomplete_ = from._impl_.incomplete_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionInstallReport::CopyFrom(const ExtensionInstallReport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ExtensionInstallReport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExtensionInstallReport::IsInitialized() const {
  return true;
}

void ExtensionInstallReport::InternalSwap(ExtensionInstallReport* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.logs_.InternalSwap(&other->_impl_.logs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.extension_id_, lhs_arena,
      &other->_impl_.extension_id_, rhs_arena
  );
  swap(_impl_.incomplete_, other->_impl_.incomplete_);
}

std::string ExtensionInstallReport::GetTypeName() const {
  return "enterprise_management.ExtensionInstallReport";
}


// ===================================================================

class AppInstallReport::_Internal {
 public:
  using HasBits = decltype(std::declval<AppInstallReport>()._impl_._has_bits_);
  static void set_has_package(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_incomplete(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AppInstallReport::AppInstallReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AppInstallReport)
}
AppInstallReport::AppInstallReport(const AppInstallReport& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AppInstallReport* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.logs_){from._impl_.logs_}
    , decltype(_impl_.package_){}
    , decltype(_impl_.incomplete_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.package_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.package_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_package()) {
    _this->_impl_.package_.Set(from._internal_package(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.incomplete_ = from._impl_.incomplete_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AppInstallReport)
}

inline void AppInstallReport::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.logs_){arena}
    , decltype(_impl_.package_){}
    , decltype(_impl_.incomplete_){false}
  };
  _impl_.package_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.package_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AppInstallReport::~AppInstallReport() {
  // @@protoc_insertion_point(destructor:enterprise_management.AppInstallReport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AppInstallReport::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.logs_.~RepeatedPtrField();
  _impl_.package_.Destroy();
}

void AppInstallReport::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AppInstallReport::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AppInstallReport)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.logs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.package_.ClearNonDefaultToEmpty();
  }
  _impl_.incomplete_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AppInstallReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string package = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_package();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool incomplete = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_incomplete(&has_bits);
          _impl_.incomplete_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.AppInstallReportLogEvent logs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_logs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AppInstallReport::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AppInstallReport)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string package = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_package(), target);
  }

  // optional bool incomplete = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_incomplete(), target);
  }

  // repeated .enterprise_management.AppInstallReportLogEvent logs = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_logs_size()); i < n; i++) {
    const auto& repfield = this->_internal_logs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AppInstallReport)
  return target;
}

size_t AppInstallReport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AppInstallReport)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.AppInstallReportLogEvent logs = 3;
  total_size += 1UL * this->_internal_logs_size();
  for (const auto& msg : this->_impl_.logs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string package = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_package());
    }

    // optional bool incomplete = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AppInstallReport::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AppInstallReport*>(
      &from));
}

void AppInstallReport::MergeFrom(const AppInstallReport& from) {
  AppInstallReport* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AppInstallReport)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.logs_.MergeFrom(from._impl_.logs_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_package(from._internal_package());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.incomplete_ = from._impl_.incomplete_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AppInstallReport::CopyFrom(const AppInstallReport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AppInstallReport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AppInstallReport::IsInitialized() const {
  return true;
}

void AppInstallReport::InternalSwap(AppInstallReport* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.logs_.InternalSwap(&other->_impl_.logs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.package_, lhs_arena,
      &other->_impl_.package_, rhs_arena
  );
  swap(_impl_.incomplete_, other->_impl_.incomplete_);
}

std::string AppInstallReport::GetTypeName() const {
  return "enterprise_management.AppInstallReport";
}


// ===================================================================

class AppInstallReportRequest::_Internal {
 public:
};

AppInstallReportRequest::AppInstallReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AppInstallReportRequest)
}
AppInstallReportRequest::AppInstallReportRequest(const AppInstallReportRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AppInstallReportRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.app_install_reports_){from._impl_.app_install_reports_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AppInstallReportRequest)
}

inline void AppInstallReportRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.app_install_reports_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AppInstallReportRequest::~AppInstallReportRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.AppInstallReportRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AppInstallReportRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.app_install_reports_.~RepeatedPtrField();
}

void AppInstallReportRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AppInstallReportRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AppInstallReportRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.app_install_reports_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AppInstallReportRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .enterprise_management.AppInstallReport app_install_reports = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_app_install_reports(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AppInstallReportRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AppInstallReportRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .enterprise_management.AppInstallReport app_install_reports = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_app_install_reports_size()); i < n; i++) {
    const auto& repfield = this->_internal_app_install_reports(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AppInstallReportRequest)
  return target;
}

size_t AppInstallReportRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AppInstallReportRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.AppInstallReport app_install_reports = 1;
  total_size += 1UL * this->_internal_app_install_reports_size();
  for (const auto& msg : this->_impl_.app_install_reports_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AppInstallReportRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AppInstallReportRequest*>(
      &from));
}

void AppInstallReportRequest::MergeFrom(const AppInstallReportRequest& from) {
  AppInstallReportRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AppInstallReportRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.app_install_reports_.MergeFrom(from._impl_.app_install_reports_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AppInstallReportRequest::CopyFrom(const AppInstallReportRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AppInstallReportRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AppInstallReportRequest::IsInitialized() const {
  return true;
}

void AppInstallReportRequest::InternalSwap(AppInstallReportRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.app_install_reports_.InternalSwap(&other->_impl_.app_install_reports_);
}

std::string AppInstallReportRequest::GetTypeName() const {
  return "enterprise_management.AppInstallReportRequest";
}


// ===================================================================

class ExtensionInstallReportRequest::_Internal {
 public:
};

ExtensionInstallReportRequest::ExtensionInstallReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ExtensionInstallReportRequest)
}
ExtensionInstallReportRequest::ExtensionInstallReportRequest(const ExtensionInstallReportRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ExtensionInstallReportRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.extension_install_reports_){from._impl_.extension_install_reports_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ExtensionInstallReportRequest)
}

inline void ExtensionInstallReportRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.extension_install_reports_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ExtensionInstallReportRequest::~ExtensionInstallReportRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.ExtensionInstallReportRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExtensionInstallReportRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.extension_install_reports_.~RepeatedPtrField();
}

void ExtensionInstallReportRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExtensionInstallReportRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ExtensionInstallReportRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_install_reports_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ExtensionInstallReportRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .enterprise_management.ExtensionInstallReport extension_install_reports = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_extension_install_reports(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExtensionInstallReportRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ExtensionInstallReportRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .enterprise_management.ExtensionInstallReport extension_install_reports = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_install_reports_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension_install_reports(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ExtensionInstallReportRequest)
  return target;
}

size_t ExtensionInstallReportRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ExtensionInstallReportRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.ExtensionInstallReport extension_install_reports = 1;
  total_size += 1UL * this->_internal_extension_install_reports_size();
  for (const auto& msg : this->_impl_.extension_install_reports_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExtensionInstallReportRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ExtensionInstallReportRequest*>(
      &from));
}

void ExtensionInstallReportRequest::MergeFrom(const ExtensionInstallReportRequest& from) {
  ExtensionInstallReportRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ExtensionInstallReportRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.extension_install_reports_.MergeFrom(from._impl_.extension_install_reports_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionInstallReportRequest::CopyFrom(const ExtensionInstallReportRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ExtensionInstallReportRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExtensionInstallReportRequest::IsInitialized() const {
  return true;
}

void ExtensionInstallReportRequest::InternalSwap(ExtensionInstallReportRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.extension_install_reports_.InternalSwap(&other->_impl_.extension_install_reports_);
}

std::string ExtensionInstallReportRequest::GetTypeName() const {
  return "enterprise_management.ExtensionInstallReportRequest";
}


// ===================================================================

class AppInstallReportResponse::_Internal {
 public:
};

AppInstallReportResponse::AppInstallReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AppInstallReportResponse)
}
AppInstallReportResponse::AppInstallReportResponse(const AppInstallReportResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AppInstallReportResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AppInstallReportResponse)
}

inline void AppInstallReportResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

AppInstallReportResponse::~AppInstallReportResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.AppInstallReportResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AppInstallReportResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AppInstallReportResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AppInstallReportResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AppInstallReportResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* AppInstallReportResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AppInstallReportResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AppInstallReportResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AppInstallReportResponse)
  return target;
}

size_t AppInstallReportResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AppInstallReportResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AppInstallReportResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AppInstallReportResponse*>(
      &from));
}

void AppInstallReportResponse::MergeFrom(const AppInstallReportResponse& from) {
  AppInstallReportResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AppInstallReportResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AppInstallReportResponse::CopyFrom(const AppInstallReportResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AppInstallReportResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AppInstallReportResponse::IsInitialized() const {
  return true;
}

void AppInstallReportResponse::InternalSwap(AppInstallReportResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string AppInstallReportResponse::GetTypeName() const {
  return "enterprise_management.AppInstallReportResponse";
}


// ===================================================================

class RefreshAccountRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<RefreshAccountRequest>()._impl_._has_bits_);
  static void set_has_account_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RefreshAccountRequest::RefreshAccountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.RefreshAccountRequest)
}
RefreshAccountRequest::RefreshAccountRequest(const RefreshAccountRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RefreshAccountRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.account_type_ = from._impl_.account_type_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.RefreshAccountRequest)
}

inline void RefreshAccountRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.account_type_){0}
  };
}

RefreshAccountRequest::~RefreshAccountRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.RefreshAccountRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RefreshAccountRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RefreshAccountRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RefreshAccountRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.RefreshAccountRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RefreshAccountRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.RefreshAccountRequest.AccountType account_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::RefreshAccountRequest_AccountType_IsValid(val))) {
            _internal_set_account_type(static_cast<::enterprise_management::RefreshAccountRequest_AccountType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RefreshAccountRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.RefreshAccountRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.RefreshAccountRequest.AccountType account_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_account_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.RefreshAccountRequest)
  return target;
}

size_t RefreshAccountRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.RefreshAccountRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.RefreshAccountRequest.AccountType account_type = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_account_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RefreshAccountRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RefreshAccountRequest*>(
      &from));
}

void RefreshAccountRequest::MergeFrom(const RefreshAccountRequest& from) {
  RefreshAccountRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.RefreshAccountRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_account_type()) {
    _this->_internal_set_account_type(from._internal_account_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RefreshAccountRequest::CopyFrom(const RefreshAccountRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.RefreshAccountRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RefreshAccountRequest::IsInitialized() const {
  return true;
}

void RefreshAccountRequest::InternalSwap(RefreshAccountRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.account_type_, other->_impl_.account_type_);
}

std::string RefreshAccountRequest::GetTypeName() const {
  return "enterprise_management.RefreshAccountRequest";
}


// ===================================================================

class RefreshAccountResponse::_Internal {
 public:
};

RefreshAccountResponse::RefreshAccountResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.RefreshAccountResponse)
}
RefreshAccountResponse::RefreshAccountResponse(const RefreshAccountResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RefreshAccountResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.RefreshAccountResponse)
}

inline void RefreshAccountResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

RefreshAccountResponse::~RefreshAccountResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.RefreshAccountResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RefreshAccountResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RefreshAccountResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RefreshAccountResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.RefreshAccountResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* RefreshAccountResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RefreshAccountResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.RefreshAccountResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.RefreshAccountResponse)
  return target;
}

size_t RefreshAccountResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.RefreshAccountResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RefreshAccountResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RefreshAccountResponse*>(
      &from));
}

void RefreshAccountResponse::MergeFrom(const RefreshAccountResponse& from) {
  RefreshAccountResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.RefreshAccountResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RefreshAccountResponse::CopyFrom(const RefreshAccountResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.RefreshAccountResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RefreshAccountResponse::IsInitialized() const {
  return true;
}

void RefreshAccountResponse::InternalSwap(RefreshAccountResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string RefreshAccountResponse::GetTypeName() const {
  return "enterprise_management.RefreshAccountResponse";
}


// ===================================================================

class RsuLookupKeyUploadRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<RsuLookupKeyUploadRequest>()._impl_._has_bits_);
  static void set_has_board_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cr50_hashed_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

RsuLookupKeyUploadRequest::RsuLookupKeyUploadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.RsuLookupKeyUploadRequest)
}
RsuLookupKeyUploadRequest::RsuLookupKeyUploadRequest(const RsuLookupKeyUploadRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RsuLookupKeyUploadRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.board_id_){}
    , decltype(_impl_.cr50_hashed_device_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.board_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.board_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_board_id()) {
    _this->_impl_.board_id_.Set(from._internal_board_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.cr50_hashed_device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cr50_hashed_device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cr50_hashed_device_id()) {
    _this->_impl_.cr50_hashed_device_id_.Set(from._internal_cr50_hashed_device_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.RsuLookupKeyUploadRequest)
}

inline void RsuLookupKeyUploadRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.board_id_){}
    , decltype(_impl_.cr50_hashed_device_id_){}
  };
  _impl_.board_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.board_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cr50_hashed_device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cr50_hashed_device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RsuLookupKeyUploadRequest::~RsuLookupKeyUploadRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.RsuLookupKeyUploadRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RsuLookupKeyUploadRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.board_id_.Destroy();
  _impl_.cr50_hashed_device_id_.Destroy();
}

void RsuLookupKeyUploadRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RsuLookupKeyUploadRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.RsuLookupKeyUploadRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.board_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.cr50_hashed_device_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RsuLookupKeyUploadRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes board_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_board_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes cr50_hashed_device_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_cr50_hashed_device_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RsuLookupKeyUploadRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.RsuLookupKeyUploadRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes board_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_board_id(), target);
  }

  // optional bytes cr50_hashed_device_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_cr50_hashed_device_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.RsuLookupKeyUploadRequest)
  return target;
}

size_t RsuLookupKeyUploadRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.RsuLookupKeyUploadRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes board_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_board_id());
    }

    // optional bytes cr50_hashed_device_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_cr50_hashed_device_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RsuLookupKeyUploadRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RsuLookupKeyUploadRequest*>(
      &from));
}

void RsuLookupKeyUploadRequest::MergeFrom(const RsuLookupKeyUploadRequest& from) {
  RsuLookupKeyUploadRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.RsuLookupKeyUploadRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_board_id(from._internal_board_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_cr50_hashed_device_id(from._internal_cr50_hashed_device_id());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RsuLookupKeyUploadRequest::CopyFrom(const RsuLookupKeyUploadRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.RsuLookupKeyUploadRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RsuLookupKeyUploadRequest::IsInitialized() const {
  return true;
}

void RsuLookupKeyUploadRequest::InternalSwap(RsuLookupKeyUploadRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.board_id_, lhs_arena,
      &other->_impl_.board_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cr50_hashed_device_id_, lhs_arena,
      &other->_impl_.cr50_hashed_device_id_, rhs_arena
  );
}

std::string RsuLookupKeyUploadRequest::GetTypeName() const {
  return "enterprise_management.RsuLookupKeyUploadRequest";
}


// ===================================================================

class RsuLookupKeyUploadResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<RsuLookupKeyUploadResponse>()._impl_._has_bits_);
  static void set_has_rsu_lookup_key_updated(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RsuLookupKeyUploadResponse::RsuLookupKeyUploadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.RsuLookupKeyUploadResponse)
}
RsuLookupKeyUploadResponse::RsuLookupKeyUploadResponse(const RsuLookupKeyUploadResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RsuLookupKeyUploadResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rsu_lookup_key_updated_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.rsu_lookup_key_updated_ = from._impl_.rsu_lookup_key_updated_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.RsuLookupKeyUploadResponse)
}

inline void RsuLookupKeyUploadResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rsu_lookup_key_updated_){false}
  };
}

RsuLookupKeyUploadResponse::~RsuLookupKeyUploadResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.RsuLookupKeyUploadResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RsuLookupKeyUploadResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RsuLookupKeyUploadResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RsuLookupKeyUploadResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.RsuLookupKeyUploadResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.rsu_lookup_key_updated_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RsuLookupKeyUploadResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool rsu_lookup_key_updated = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_rsu_lookup_key_updated(&has_bits);
          _impl_.rsu_lookup_key_updated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RsuLookupKeyUploadResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.RsuLookupKeyUploadResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool rsu_lookup_key_updated = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_rsu_lookup_key_updated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.RsuLookupKeyUploadResponse)
  return target;
}

size_t RsuLookupKeyUploadResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.RsuLookupKeyUploadResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool rsu_lookup_key_updated = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RsuLookupKeyUploadResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RsuLookupKeyUploadResponse*>(
      &from));
}

void RsuLookupKeyUploadResponse::MergeFrom(const RsuLookupKeyUploadResponse& from) {
  RsuLookupKeyUploadResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.RsuLookupKeyUploadResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_rsu_lookup_key_updated()) {
    _this->_internal_set_rsu_lookup_key_updated(from._internal_rsu_lookup_key_updated());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RsuLookupKeyUploadResponse::CopyFrom(const RsuLookupKeyUploadResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.RsuLookupKeyUploadResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RsuLookupKeyUploadResponse::IsInitialized() const {
  return true;
}

void RsuLookupKeyUploadResponse::InternalSwap(RsuLookupKeyUploadResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.rsu_lookup_key_updated_, other->_impl_.rsu_lookup_key_updated_);
}

std::string RsuLookupKeyUploadResponse::GetTypeName() const {
  return "enterprise_management.RsuLookupKeyUploadResponse";
}


// ===================================================================

class ESimProfileInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ESimProfileInfo>()._impl_._has_bits_);
  static void set_has_iccid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_smdp_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ESimProfileInfo::ESimProfileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ESimProfileInfo)
}
ESimProfileInfo::ESimProfileInfo(const ESimProfileInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ESimProfileInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.iccid_){}
    , decltype(_impl_.smdp_address_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.iccid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iccid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_iccid()) {
    _this->_impl_.iccid_.Set(from._internal_iccid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.smdp_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.smdp_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_smdp_address()) {
    _this->_impl_.smdp_address_.Set(from._internal_smdp_address(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ESimProfileInfo)
}

inline void ESimProfileInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.iccid_){}
    , decltype(_impl_.smdp_address_){}
  };
  _impl_.iccid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iccid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.smdp_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.smdp_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ESimProfileInfo::~ESimProfileInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.ESimProfileInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ESimProfileInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.iccid_.Destroy();
  _impl_.smdp_address_.Destroy();
}

void ESimProfileInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ESimProfileInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ESimProfileInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.iccid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.smdp_address_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ESimProfileInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string iccid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_iccid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string smdp_address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_smdp_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ESimProfileInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ESimProfileInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string iccid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_iccid(), target);
  }

  // optional string smdp_address = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_smdp_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ESimProfileInfo)
  return target;
}

size_t ESimProfileInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ESimProfileInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string iccid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_iccid());
    }

    // optional string smdp_address = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_smdp_address());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ESimProfileInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ESimProfileInfo*>(
      &from));
}

void ESimProfileInfo::MergeFrom(const ESimProfileInfo& from) {
  ESimProfileInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ESimProfileInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_iccid(from._internal_iccid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_smdp_address(from._internal_smdp_address());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ESimProfileInfo::CopyFrom(const ESimProfileInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ESimProfileInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ESimProfileInfo::IsInitialized() const {
  return true;
}

void ESimProfileInfo::InternalSwap(ESimProfileInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.iccid_, lhs_arena,
      &other->_impl_.iccid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.smdp_address_, lhs_arena,
      &other->_impl_.smdp_address_, rhs_arena
  );
}

std::string ESimProfileInfo::GetTypeName() const {
  return "enterprise_management.ESimProfileInfo";
}


// ===================================================================

class UploadEuiccInfoRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<UploadEuiccInfoRequest>()._impl_._has_bits_);
  static void set_has_euicc_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_clear_profile_list(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UploadEuiccInfoRequest::UploadEuiccInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.UploadEuiccInfoRequest)
}
UploadEuiccInfoRequest::UploadEuiccInfoRequest(const UploadEuiccInfoRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UploadEuiccInfoRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.esim_profiles_){from._impl_.esim_profiles_}
    , decltype(_impl_.euicc_count_){}
    , decltype(_impl_.clear_profile_list_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.euicc_count_, &from._impl_.euicc_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.clear_profile_list_) -
    reinterpret_cast<char*>(&_impl_.euicc_count_)) + sizeof(_impl_.clear_profile_list_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.UploadEuiccInfoRequest)
}

inline void UploadEuiccInfoRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.esim_profiles_){arena}
    , decltype(_impl_.euicc_count_){0u}
    , decltype(_impl_.clear_profile_list_){false}
  };
}

UploadEuiccInfoRequest::~UploadEuiccInfoRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.UploadEuiccInfoRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UploadEuiccInfoRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.esim_profiles_.~RepeatedPtrField();
}

void UploadEuiccInfoRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UploadEuiccInfoRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.UploadEuiccInfoRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.esim_profiles_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.euicc_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.clear_profile_list_) -
        reinterpret_cast<char*>(&_impl_.euicc_count_)) + sizeof(_impl_.clear_profile_list_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UploadEuiccInfoRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 euicc_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_euicc_count(&has_bits);
          _impl_.euicc_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.ESimProfileInfo esim_profiles = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_esim_profiles(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool clear_profile_list = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_clear_profile_list(&has_bits);
          _impl_.clear_profile_list_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UploadEuiccInfoRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.UploadEuiccInfoRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 euicc_count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_euicc_count(), target);
  }

  // repeated .enterprise_management.ESimProfileInfo esim_profiles = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_esim_profiles_size()); i < n; i++) {
    const auto& repfield = this->_internal_esim_profiles(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool clear_profile_list = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_clear_profile_list(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.UploadEuiccInfoRequest)
  return target;
}

size_t UploadEuiccInfoRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.UploadEuiccInfoRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.ESimProfileInfo esim_profiles = 2;
  total_size += 1UL * this->_internal_esim_profiles_size();
  for (const auto& msg : this->_impl_.esim_profiles_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 euicc_count = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_euicc_count());
    }

    // optional bool clear_profile_list = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UploadEuiccInfoRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UploadEuiccInfoRequest*>(
      &from));
}

void UploadEuiccInfoRequest::MergeFrom(const UploadEuiccInfoRequest& from) {
  UploadEuiccInfoRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.UploadEuiccInfoRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.esim_profiles_.MergeFrom(from._impl_.esim_profiles_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.euicc_count_ = from._impl_.euicc_count_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.clear_profile_list_ = from._impl_.clear_profile_list_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UploadEuiccInfoRequest::CopyFrom(const UploadEuiccInfoRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.UploadEuiccInfoRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UploadEuiccInfoRequest::IsInitialized() const {
  return true;
}

void UploadEuiccInfoRequest::InternalSwap(UploadEuiccInfoRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.esim_profiles_.InternalSwap(&other->_impl_.esim_profiles_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UploadEuiccInfoRequest, _impl_.clear_profile_list_)
      + sizeof(UploadEuiccInfoRequest::_impl_.clear_profile_list_)
      - PROTOBUF_FIELD_OFFSET(UploadEuiccInfoRequest, _impl_.euicc_count_)>(
          reinterpret_cast<char*>(&_impl_.euicc_count_),
          reinterpret_cast<char*>(&other->_impl_.euicc_count_));
}

std::string UploadEuiccInfoRequest::GetTypeName() const {
  return "enterprise_management.UploadEuiccInfoRequest";
}


// ===================================================================

class UploadEuiccInfoResponse::_Internal {
 public:
};

UploadEuiccInfoResponse::UploadEuiccInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.UploadEuiccInfoResponse)
}
UploadEuiccInfoResponse::UploadEuiccInfoResponse(const UploadEuiccInfoResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UploadEuiccInfoResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.UploadEuiccInfoResponse)
}

inline void UploadEuiccInfoResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

UploadEuiccInfoResponse::~UploadEuiccInfoResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.UploadEuiccInfoResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UploadEuiccInfoResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UploadEuiccInfoResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UploadEuiccInfoResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.UploadEuiccInfoResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* UploadEuiccInfoResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UploadEuiccInfoResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.UploadEuiccInfoResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.UploadEuiccInfoResponse)
  return target;
}

size_t UploadEuiccInfoResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.UploadEuiccInfoResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UploadEuiccInfoResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UploadEuiccInfoResponse*>(
      &from));
}

void UploadEuiccInfoResponse::MergeFrom(const UploadEuiccInfoResponse& from) {
  UploadEuiccInfoResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.UploadEuiccInfoResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UploadEuiccInfoResponse::CopyFrom(const UploadEuiccInfoResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.UploadEuiccInfoResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UploadEuiccInfoResponse::IsInitialized() const {
  return true;
}

void UploadEuiccInfoResponse::InternalSwap(UploadEuiccInfoResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string UploadEuiccInfoResponse::GetTypeName() const {
  return "enterprise_management.UploadEuiccInfoResponse";
}


// ===================================================================

class PrintJobEvent_PrintJobConfiguration::_Internal {
 public:
  using HasBits = decltype(std::declval<PrintJobEvent_PrintJobConfiguration>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_creation_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_completion_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_number_of_pages(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::enterprise_management::PrintJobEvent_PrintSettings& settings(const PrintJobEvent_PrintJobConfiguration* msg);
  static void set_has_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::enterprise_management::PrintJobEvent_PrintSettings&
PrintJobEvent_PrintJobConfiguration::_Internal::settings(const PrintJobEvent_PrintJobConfiguration* msg) {
  return *msg->_impl_.settings_;
}
PrintJobEvent_PrintJobConfiguration::PrintJobEvent_PrintJobConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PrintJobEvent.PrintJobConfiguration)
}
PrintJobEvent_PrintJobConfiguration::PrintJobEvent_PrintJobConfiguration(const PrintJobEvent_PrintJobConfiguration& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PrintJobEvent_PrintJobConfiguration* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.settings_){nullptr}
    , decltype(_impl_.creation_timestamp_ms_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.number_of_pages_){}
    , decltype(_impl_.completion_timestamp_ms_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_title()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_settings()) {
    _this->_impl_.settings_ = new ::enterprise_management::PrintJobEvent_PrintSettings(*from._impl_.settings_);
  }
  ::memcpy(&_impl_.creation_timestamp_ms_, &from._impl_.creation_timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.completion_timestamp_ms_) -
    reinterpret_cast<char*>(&_impl_.creation_timestamp_ms_)) + sizeof(_impl_.completion_timestamp_ms_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PrintJobEvent.PrintJobConfiguration)
}

inline void PrintJobEvent_PrintJobConfiguration::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.settings_){nullptr}
    , decltype(_impl_.creation_timestamp_ms_){int64_t{0}}
    , decltype(_impl_.status_){0}
    , decltype(_impl_.number_of_pages_){0}
    , decltype(_impl_.completion_timestamp_ms_){int64_t{0}}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PrintJobEvent_PrintJobConfiguration::~PrintJobEvent_PrintJobConfiguration() {
  // @@protoc_insertion_point(destructor:enterprise_management.PrintJobEvent.PrintJobConfiguration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PrintJobEvent_PrintJobConfiguration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  _impl_.title_.Destroy();
  if (this != internal_default_instance()) delete _impl_.settings_;
}

void PrintJobEvent_PrintJobConfiguration::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PrintJobEvent_PrintJobConfiguration::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PrintJobEvent.PrintJobConfiguration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.settings_ != nullptr);
      _impl_.settings_->Clear();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&_impl_.creation_timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.completion_timestamp_ms_) -
        reinterpret_cast<char*>(&_impl_.creation_timestamp_ms_)) + sizeof(_impl_.completion_timestamp_ms_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PrintJobEvent_PrintJobConfiguration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string title = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_status(&has_bits);
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 creation_timestamp_ms = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_creation_timestamp_ms(&has_bits);
          _impl_.creation_timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 completion_timestamp_ms = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_completion_timestamp_ms(&has_bits);
          _impl_.completion_timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 number_of_pages = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_number_of_pages(&has_bits);
          _impl_.number_of_pages_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PrintJobEvent.PrintSettings settings = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PrintJobEvent_PrintJobConfiguration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PrintJobEvent.PrintJobConfiguration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional string title = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_title(), target);
  }

  // optional int32 status = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_status(), target);
  }

  // optional int64 creation_timestamp_ms = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_creation_timestamp_ms(), target);
  }

  // optional int64 completion_timestamp_ms = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_completion_timestamp_ms(), target);
  }

  // optional int32 number_of_pages = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_number_of_pages(), target);
  }

  // optional .enterprise_management.PrintJobEvent.PrintSettings settings = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::settings(this),
        _Internal::settings(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PrintJobEvent.PrintJobConfiguration)
  return target;
}

size_t PrintJobEvent_PrintJobConfiguration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PrintJobEvent.PrintJobConfiguration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id());
    }

    // optional string title = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_title());
    }

    // optional .enterprise_management.PrintJobEvent.PrintSettings settings = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.settings_);
    }

    // optional int64 creation_timestamp_ms = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_creation_timestamp_ms());
    }

    // optional int32 status = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_status());
    }

    // optional int32 number_of_pages = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_number_of_pages());
    }

    // optional int64 completion_timestamp_ms = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_completion_timestamp_ms());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PrintJobEvent_PrintJobConfiguration::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PrintJobEvent_PrintJobConfiguration*>(
      &from));
}

void PrintJobEvent_PrintJobConfiguration::MergeFrom(const PrintJobEvent_PrintJobConfiguration& from) {
  PrintJobEvent_PrintJobConfiguration* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PrintJobEvent.PrintJobConfiguration)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_title(from._internal_title());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_settings()->::enterprise_management::PrintJobEvent_PrintSettings::MergeFrom(
          from._internal_settings());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.creation_timestamp_ms_ = from._impl_.creation_timestamp_ms_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.number_of_pages_ = from._impl_.number_of_pages_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.completion_timestamp_ms_ = from._impl_.completion_timestamp_ms_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PrintJobEvent_PrintJobConfiguration::CopyFrom(const PrintJobEvent_PrintJobConfiguration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PrintJobEvent.PrintJobConfiguration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrintJobEvent_PrintJobConfiguration::IsInitialized() const {
  return true;
}

void PrintJobEvent_PrintJobConfiguration::InternalSwap(PrintJobEvent_PrintJobConfiguration* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PrintJobEvent_PrintJobConfiguration, _impl_.completion_timestamp_ms_)
      + sizeof(PrintJobEvent_PrintJobConfiguration::_impl_.completion_timestamp_ms_)
      - PROTOBUF_FIELD_OFFSET(PrintJobEvent_PrintJobConfiguration, _impl_.settings_)>(
          reinterpret_cast<char*>(&_impl_.settings_),
          reinterpret_cast<char*>(&other->_impl_.settings_));
}

std::string PrintJobEvent_PrintJobConfiguration::GetTypeName() const {
  return "enterprise_management.PrintJobEvent.PrintJobConfiguration";
}


// ===================================================================

class PrintJobEvent_Printer::_Internal {
 public:
  using HasBits = decltype(std::declval<PrintJobEvent_Printer>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_uri(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

PrintJobEvent_Printer::PrintJobEvent_Printer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PrintJobEvent.Printer)
}
PrintJobEvent_Printer::PrintJobEvent_Printer(const PrintJobEvent_Printer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PrintJobEvent_Printer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.uri_){}
    , decltype(_impl_.id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.uri_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uri_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_uri()) {
    _this->_impl_.uri_.Set(from._internal_uri(), 
      _this->GetArenaForAllocation());
  }
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PrintJobEvent.Printer)
}

inline void PrintJobEvent_Printer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.uri_){}
    , decltype(_impl_.id_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uri_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uri_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PrintJobEvent_Printer::~PrintJobEvent_Printer() {
  // @@protoc_insertion_point(destructor:enterprise_management.PrintJobEvent.Printer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PrintJobEvent_Printer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.uri_.Destroy();
  _impl_.id_.Destroy();
}

void PrintJobEvent_Printer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PrintJobEvent_Printer::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PrintJobEvent.Printer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.uri_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PrintJobEvent_Printer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string uri = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_uri();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PrintJobEvent_Printer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PrintJobEvent.Printer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string uri = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_uri(), target);
  }

  // optional string id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PrintJobEvent.Printer)
  return target;
}

size_t PrintJobEvent_Printer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PrintJobEvent.Printer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string uri = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_uri());
    }

    // optional string id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PrintJobEvent_Printer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PrintJobEvent_Printer*>(
      &from));
}

void PrintJobEvent_Printer::MergeFrom(const PrintJobEvent_Printer& from) {
  PrintJobEvent_Printer* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PrintJobEvent.Printer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_uri(from._internal_uri());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_id(from._internal_id());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PrintJobEvent_Printer::CopyFrom(const PrintJobEvent_Printer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PrintJobEvent.Printer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrintJobEvent_Printer::IsInitialized() const {
  return true;
}

void PrintJobEvent_Printer::InternalSwap(PrintJobEvent_Printer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uri_, lhs_arena,
      &other->_impl_.uri_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
}

std::string PrintJobEvent_Printer::GetTypeName() const {
  return "enterprise_management.PrintJobEvent.Printer";
}


// ===================================================================

class PrintJobEvent_PrintSettings_MediaSize::_Internal {
 public:
  using HasBits = decltype(std::declval<PrintJobEvent_PrintSettings_MediaSize>()._impl_._has_bits_);
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_vendor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PrintJobEvent_PrintSettings_MediaSize::PrintJobEvent_PrintSettings_MediaSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PrintJobEvent.PrintSettings.MediaSize)
}
PrintJobEvent_PrintSettings_MediaSize::PrintJobEvent_PrintSettings_MediaSize(const PrintJobEvent_PrintSettings_MediaSize& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PrintJobEvent_PrintSettings_MediaSize* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vendor_id_){}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.vendor_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vendor_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vendor_id()) {
    _this->_impl_.vendor_id_.Set(from._internal_vendor_id(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.height_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PrintJobEvent.PrintSettings.MediaSize)
}

inline void PrintJobEvent_PrintSettings_MediaSize::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vendor_id_){}
    , decltype(_impl_.width_){0}
    , decltype(_impl_.height_){0}
  };
  _impl_.vendor_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vendor_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PrintJobEvent_PrintSettings_MediaSize::~PrintJobEvent_PrintSettings_MediaSize() {
  // @@protoc_insertion_point(destructor:enterprise_management.PrintJobEvent.PrintSettings.MediaSize)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PrintJobEvent_PrintSettings_MediaSize::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vendor_id_.Destroy();
}

void PrintJobEvent_PrintSettings_MediaSize::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PrintJobEvent_PrintSettings_MediaSize::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PrintJobEvent.PrintSettings.MediaSize)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.vendor_id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.height_) -
        reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.height_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PrintJobEvent_PrintSettings_MediaSize::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string vendor_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_vendor_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PrintJobEvent_PrintSettings_MediaSize::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PrintJobEvent.PrintSettings.MediaSize)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 width = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_width(), target);
  }

  // optional int32 height = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_height(), target);
  }

  // optional string vendor_id = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_vendor_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PrintJobEvent.PrintSettings.MediaSize)
  return target;
}

size_t PrintJobEvent_PrintSettings_MediaSize::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PrintJobEvent.PrintSettings.MediaSize)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string vendor_id = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_vendor_id());
    }

    // optional int32 width = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
    }

    // optional int32 height = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PrintJobEvent_PrintSettings_MediaSize::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PrintJobEvent_PrintSettings_MediaSize*>(
      &from));
}

void PrintJobEvent_PrintSettings_MediaSize::MergeFrom(const PrintJobEvent_PrintSettings_MediaSize& from) {
  PrintJobEvent_PrintSettings_MediaSize* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PrintJobEvent.PrintSettings.MediaSize)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_vendor_id(from._internal_vendor_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PrintJobEvent_PrintSettings_MediaSize::CopyFrom(const PrintJobEvent_PrintSettings_MediaSize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PrintJobEvent.PrintSettings.MediaSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrintJobEvent_PrintSettings_MediaSize::IsInitialized() const {
  return true;
}

void PrintJobEvent_PrintSettings_MediaSize::InternalSwap(PrintJobEvent_PrintSettings_MediaSize* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vendor_id_, lhs_arena,
      &other->_impl_.vendor_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PrintJobEvent_PrintSettings_MediaSize, _impl_.height_)
      + sizeof(PrintJobEvent_PrintSettings_MediaSize::_impl_.height_)
      - PROTOBUF_FIELD_OFFSET(PrintJobEvent_PrintSettings_MediaSize, _impl_.width_)>(
          reinterpret_cast<char*>(&_impl_.width_),
          reinterpret_cast<char*>(&other->_impl_.width_));
}

std::string PrintJobEvent_PrintSettings_MediaSize::GetTypeName() const {
  return "enterprise_management.PrintJobEvent.PrintSettings.MediaSize";
}


// ===================================================================

class PrintJobEvent_PrintSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<PrintJobEvent_PrintSettings>()._impl_._has_bits_);
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_duplex(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize& media_size(const PrintJobEvent_PrintSettings* msg);
  static void set_has_media_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_copies(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize&
PrintJobEvent_PrintSettings::_Internal::media_size(const PrintJobEvent_PrintSettings* msg) {
  return *msg->_impl_.media_size_;
}
PrintJobEvent_PrintSettings::PrintJobEvent_PrintSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PrintJobEvent.PrintSettings)
}
PrintJobEvent_PrintSettings::PrintJobEvent_PrintSettings(const PrintJobEvent_PrintSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PrintJobEvent_PrintSettings* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.media_size_){nullptr}
    , decltype(_impl_.color_){}
    , decltype(_impl_.duplex_){}
    , decltype(_impl_.copies_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_media_size()) {
    _this->_impl_.media_size_ = new ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize(*from._impl_.media_size_);
  }
  ::memcpy(&_impl_.color_, &from._impl_.color_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.copies_) -
    reinterpret_cast<char*>(&_impl_.color_)) + sizeof(_impl_.copies_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PrintJobEvent.PrintSettings)
}

inline void PrintJobEvent_PrintSettings::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.media_size_){nullptr}
    , decltype(_impl_.color_){0}
    , decltype(_impl_.duplex_){0}
    , decltype(_impl_.copies_){0}
  };
}

PrintJobEvent_PrintSettings::~PrintJobEvent_PrintSettings() {
  // @@protoc_insertion_point(destructor:enterprise_management.PrintJobEvent.PrintSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PrintJobEvent_PrintSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.media_size_;
}

void PrintJobEvent_PrintSettings::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PrintJobEvent_PrintSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PrintJobEvent.PrintSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.media_size_ != nullptr);
    _impl_.media_size_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.color_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.copies_) -
        reinterpret_cast<char*>(&_impl_.color_)) + sizeof(_impl_.copies_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PrintJobEvent_PrintSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.PrintJobEvent.PrintSettings.ColorMode color = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::PrintJobEvent_PrintSettings_ColorMode_IsValid(val))) {
            _internal_set_color(static_cast<::enterprise_management::PrintJobEvent_PrintSettings_ColorMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PrintJobEvent.PrintSettings.DuplexMode duplex = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::PrintJobEvent_PrintSettings_DuplexMode_IsValid(val))) {
            _internal_set_duplex(static_cast<::enterprise_management::PrintJobEvent_PrintSettings_DuplexMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PrintJobEvent.PrintSettings.MediaSize media_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_media_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 copies = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_copies(&has_bits);
          _impl_.copies_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PrintJobEvent_PrintSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PrintJobEvent.PrintSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.PrintJobEvent.PrintSettings.ColorMode color = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_color(), target);
  }

  // optional .enterprise_management.PrintJobEvent.PrintSettings.DuplexMode duplex = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_duplex(), target);
  }

  // optional .enterprise_management.PrintJobEvent.PrintSettings.MediaSize media_size = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::media_size(this),
        _Internal::media_size(this).GetCachedSize(), target, stream);
  }

  // optional int32 copies = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_copies(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PrintJobEvent.PrintSettings)
  return target;
}

size_t PrintJobEvent_PrintSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PrintJobEvent.PrintSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .enterprise_management.PrintJobEvent.PrintSettings.MediaSize media_size = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.media_size_);
    }

    // optional .enterprise_management.PrintJobEvent.PrintSettings.ColorMode color = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_color());
    }

    // optional .enterprise_management.PrintJobEvent.PrintSettings.DuplexMode duplex = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_duplex());
    }

    // optional int32 copies = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_copies());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PrintJobEvent_PrintSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PrintJobEvent_PrintSettings*>(
      &from));
}

void PrintJobEvent_PrintSettings::MergeFrom(const PrintJobEvent_PrintSettings& from) {
  PrintJobEvent_PrintSettings* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PrintJobEvent.PrintSettings)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_media_size()->::enterprise_management::PrintJobEvent_PrintSettings_MediaSize::MergeFrom(
          from._internal_media_size());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.color_ = from._impl_.color_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.duplex_ = from._impl_.duplex_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.copies_ = from._impl_.copies_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PrintJobEvent_PrintSettings::CopyFrom(const PrintJobEvent_PrintSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PrintJobEvent.PrintSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrintJobEvent_PrintSettings::IsInitialized() const {
  return true;
}

void PrintJobEvent_PrintSettings::InternalSwap(PrintJobEvent_PrintSettings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PrintJobEvent_PrintSettings, _impl_.copies_)
      + sizeof(PrintJobEvent_PrintSettings::_impl_.copies_)
      - PROTOBUF_FIELD_OFFSET(PrintJobEvent_PrintSettings, _impl_.media_size_)>(
          reinterpret_cast<char*>(&_impl_.media_size_),
          reinterpret_cast<char*>(&other->_impl_.media_size_));
}

std::string PrintJobEvent_PrintSettings::GetTypeName() const {
  return "enterprise_management.PrintJobEvent.PrintSettings";
}


// ===================================================================

class PrintJobEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<PrintJobEvent>()._impl_._has_bits_);
  static const ::enterprise_management::PrintJobEvent_PrintJobConfiguration& job_configuration(const PrintJobEvent* msg);
  static void set_has_job_configuration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::enterprise_management::PrintJobEvent_Printer& printer(const PrintJobEvent* msg);
  static void set_has_printer(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::enterprise_management::PrintJobEvent_PrintJobConfiguration&
PrintJobEvent::_Internal::job_configuration(const PrintJobEvent* msg) {
  return *msg->_impl_.job_configuration_;
}
const ::enterprise_management::PrintJobEvent_Printer&
PrintJobEvent::_Internal::printer(const PrintJobEvent* msg) {
  return *msg->_impl_.printer_;
}
PrintJobEvent::PrintJobEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.PrintJobEvent)
}
PrintJobEvent::PrintJobEvent(const PrintJobEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PrintJobEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.job_configuration_){nullptr}
    , decltype(_impl_.printer_){nullptr}
    , decltype(_impl_.user_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_job_configuration()) {
    _this->_impl_.job_configuration_ = new ::enterprise_management::PrintJobEvent_PrintJobConfiguration(*from._impl_.job_configuration_);
  }
  if (from._internal_has_printer()) {
    _this->_impl_.printer_ = new ::enterprise_management::PrintJobEvent_Printer(*from._impl_.printer_);
  }
  _this->_impl_.user_type_ = from._impl_.user_type_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.PrintJobEvent)
}

inline void PrintJobEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.job_configuration_){nullptr}
    , decltype(_impl_.printer_){nullptr}
    , decltype(_impl_.user_type_){0}
  };
}

PrintJobEvent::~PrintJobEvent() {
  // @@protoc_insertion_point(destructor:enterprise_management.PrintJobEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PrintJobEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.job_configuration_;
  if (this != internal_default_instance()) delete _impl_.printer_;
}

void PrintJobEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PrintJobEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.PrintJobEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.job_configuration_ != nullptr);
      _impl_.job_configuration_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.printer_ != nullptr);
      _impl_.printer_->Clear();
    }
  }
  _impl_.user_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PrintJobEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.PrintJobEvent.PrintJobConfiguration job_configuration = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_job_configuration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PrintJobEvent.UserType user_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::PrintJobEvent_UserType_IsValid(val))) {
            _internal_set_user_type(static_cast<::enterprise_management::PrintJobEvent_UserType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PrintJobEvent.Printer printer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_printer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PrintJobEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.PrintJobEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.PrintJobEvent.PrintJobConfiguration job_configuration = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::job_configuration(this),
        _Internal::job_configuration(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.PrintJobEvent.UserType user_type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_user_type(), target);
  }

  // optional .enterprise_management.PrintJobEvent.Printer printer = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::printer(this),
        _Internal::printer(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.PrintJobEvent)
  return target;
}

size_t PrintJobEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.PrintJobEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .enterprise_management.PrintJobEvent.PrintJobConfiguration job_configuration = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.job_configuration_);
    }

    // optional .enterprise_management.PrintJobEvent.Printer printer = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.printer_);
    }

    // optional .enterprise_management.PrintJobEvent.UserType user_type = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_user_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PrintJobEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PrintJobEvent*>(
      &from));
}

void PrintJobEvent::MergeFrom(const PrintJobEvent& from) {
  PrintJobEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.PrintJobEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_job_configuration()->::enterprise_management::PrintJobEvent_PrintJobConfiguration::MergeFrom(
          from._internal_job_configuration());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_printer()->::enterprise_management::PrintJobEvent_Printer::MergeFrom(
          from._internal_printer());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.user_type_ = from._impl_.user_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PrintJobEvent::CopyFrom(const PrintJobEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.PrintJobEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrintJobEvent::IsInitialized() const {
  return true;
}

void PrintJobEvent::InternalSwap(PrintJobEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PrintJobEvent, _impl_.user_type_)
      + sizeof(PrintJobEvent::_impl_.user_type_)
      - PROTOBUF_FIELD_OFFSET(PrintJobEvent, _impl_.job_configuration_)>(
          reinterpret_cast<char*>(&_impl_.job_configuration_),
          reinterpret_cast<char*>(&other->_impl_.job_configuration_));
}

std::string PrintJobEvent::GetTypeName() const {
  return "enterprise_management.PrintJobEvent";
}


// ===================================================================

class App::_Internal {
 public:
  using HasBits = decltype(std::declval<App>()._impl_._has_bits_);
  static void set_has_app_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_app_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

App::App(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.App)
}
App::App(const App& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  App* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.additional_app_id_){from._impl_.additional_app_id_}
    , decltype(_impl_.app_id_){}
    , decltype(_impl_.app_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.app_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_app_id()) {
    _this->_impl_.app_id_.Set(from._internal_app_id(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.app_type_ = from._impl_.app_type_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.App)
}

inline void App::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.additional_app_id_){arena}
    , decltype(_impl_.app_id_){}
    , decltype(_impl_.app_type_){0}
  };
  _impl_.app_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

App::~App() {
  // @@protoc_insertion_point(destructor:enterprise_management.App)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void App::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_app_id_.~RepeatedPtrField();
  _impl_.app_id_.Destroy();
}

void App::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void App::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.App)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_app_id_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.app_id_.ClearNonDefaultToEmpty();
  }
  _impl_.app_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* App::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string app_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_app_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.App.AppType app_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::App_AppType_IsValid(val))) {
            _internal_set_app_type(static_cast<::enterprise_management::App_AppType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated string additional_app_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_additional_app_id();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* App::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.App)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string app_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_app_id(), target);
  }

  // optional .enterprise_management.App.AppType app_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_app_type(), target);
  }

  // repeated string additional_app_id = 3;
  for (int i = 0, n = this->_internal_additional_app_id_size(); i < n; i++) {
    const auto& s = this->_internal_additional_app_id(i);
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.App)
  return target;
}

size_t App::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.App)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string additional_app_id = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.additional_app_id_.size());
  for (int i = 0, n = _impl_.additional_app_id_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.additional_app_id_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string app_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_app_id());
    }

    // optional .enterprise_management.App.AppType app_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_app_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void App::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const App*>(
      &from));
}

void App::MergeFrom(const App& from) {
  App* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.App)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_app_id_.MergeFrom(from._impl_.additional_app_id_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_app_id(from._internal_app_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.app_type_ = from._impl_.app_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void App::CopyFrom(const App& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.App)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool App::IsInitialized() const {
  return true;
}

void App::InternalSwap(App* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.additional_app_id_.InternalSwap(&other->_impl_.additional_app_id_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.app_id_, lhs_arena,
      &other->_impl_.app_id_, rhs_arena
  );
  swap(_impl_.app_type_, other->_impl_.app_type_);
}

std::string App::GetTypeName() const {
  return "enterprise_management.App";
}


// ===================================================================

class AppActivity::_Internal {
 public:
  using HasBits = decltype(std::declval<AppActivity>()._impl_._has_bits_);
  static const ::enterprise_management::App& app_info(const AppActivity* msg);
  static void set_has_app_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_populated_at(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_app_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::enterprise_management::App&
AppActivity::_Internal::app_info(const AppActivity* msg) {
  return *msg->_impl_.app_info_;
}
AppActivity::AppActivity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.AppActivity)
}
AppActivity::AppActivity(const AppActivity& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AppActivity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.active_time_periods_){from._impl_.active_time_periods_}
    , decltype(_impl_.app_info_){nullptr}
    , decltype(_impl_.populated_at_){}
    , decltype(_impl_.app_state_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_app_info()) {
    _this->_impl_.app_info_ = new ::enterprise_management::App(*from._impl_.app_info_);
  }
  ::memcpy(&_impl_.populated_at_, &from._impl_.populated_at_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.app_state_) -
    reinterpret_cast<char*>(&_impl_.populated_at_)) + sizeof(_impl_.app_state_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.AppActivity)
}

inline void AppActivity::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.active_time_periods_){arena}
    , decltype(_impl_.app_info_){nullptr}
    , decltype(_impl_.populated_at_){int64_t{0}}
    , decltype(_impl_.app_state_){0}
  };
}

AppActivity::~AppActivity() {
  // @@protoc_insertion_point(destructor:enterprise_management.AppActivity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AppActivity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.active_time_periods_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.app_info_;
}

void AppActivity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AppActivity::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.AppActivity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.active_time_periods_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.app_info_ != nullptr);
    _impl_.app_info_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.populated_at_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.app_state_) -
        reinterpret_cast<char*>(&_impl_.populated_at_)) + sizeof(_impl_.app_state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AppActivity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.App app_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_app_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.TimePeriod active_time_periods = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_active_time_periods(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 populated_at = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_populated_at(&has_bits);
          _impl_.populated_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AppActivity.AppState app_state = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::AppActivity_AppState_IsValid(val))) {
            _internal_set_app_state(static_cast<::enterprise_management::AppActivity_AppState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AppActivity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.AppActivity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.App app_info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::app_info(this),
        _Internal::app_info(this).GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.TimePeriod active_time_periods = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_active_time_periods_size()); i < n; i++) {
    const auto& repfield = this->_internal_active_time_periods(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int64 populated_at = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_populated_at(), target);
  }

  // optional .enterprise_management.AppActivity.AppState app_state = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_app_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.AppActivity)
  return target;
}

size_t AppActivity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.AppActivity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.TimePeriod active_time_periods = 2;
  total_size += 1UL * this->_internal_active_time_periods_size();
  for (const auto& msg : this->_impl_.active_time_periods_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .enterprise_management.App app_info = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.app_info_);
    }

    // optional int64 populated_at = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_populated_at());
    }

    // optional .enterprise_management.AppActivity.AppState app_state = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_app_state());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AppActivity::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AppActivity*>(
      &from));
}

void AppActivity::MergeFrom(const AppActivity& from) {
  AppActivity* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.AppActivity)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.active_time_periods_.MergeFrom(from._impl_.active_time_periods_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_app_info()->::enterprise_management::App::MergeFrom(
          from._internal_app_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.populated_at_ = from._impl_.populated_at_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.app_state_ = from._impl_.app_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AppActivity::CopyFrom(const AppActivity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.AppActivity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AppActivity::IsInitialized() const {
  return true;
}

void AppActivity::InternalSwap(AppActivity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.active_time_periods_.InternalSwap(&other->_impl_.active_time_periods_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AppActivity, _impl_.app_state_)
      + sizeof(AppActivity::_impl_.app_state_)
      - PROTOBUF_FIELD_OFFSET(AppActivity, _impl_.app_info_)>(
          reinterpret_cast<char*>(&_impl_.app_info_),
          reinterpret_cast<char*>(&other->_impl_.app_info_));
}

std::string AppActivity::GetTypeName() const {
  return "enterprise_management.AppActivity";
}


// ===================================================================

class ScreenTimeSpan::_Internal {
 public:
  using HasBits = decltype(std::declval<ScreenTimeSpan>()._impl_._has_bits_);
  static const ::enterprise_management::TimePeriod& time_period(const ScreenTimeSpan* msg);
  static void set_has_time_period(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_active_duration_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::enterprise_management::TimePeriod&
ScreenTimeSpan::_Internal::time_period(const ScreenTimeSpan* msg) {
  return *msg->_impl_.time_period_;
}
ScreenTimeSpan::ScreenTimeSpan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ScreenTimeSpan)
}
ScreenTimeSpan::ScreenTimeSpan(const ScreenTimeSpan& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ScreenTimeSpan* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.time_period_){nullptr}
    , decltype(_impl_.active_duration_ms_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_time_period()) {
    _this->_impl_.time_period_ = new ::enterprise_management::TimePeriod(*from._impl_.time_period_);
  }
  _this->_impl_.active_duration_ms_ = from._impl_.active_duration_ms_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ScreenTimeSpan)
}

inline void ScreenTimeSpan::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.time_period_){nullptr}
    , decltype(_impl_.active_duration_ms_){int64_t{0}}
  };
}

ScreenTimeSpan::~ScreenTimeSpan() {
  // @@protoc_insertion_point(destructor:enterprise_management.ScreenTimeSpan)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScreenTimeSpan::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.time_period_;
}

void ScreenTimeSpan::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ScreenTimeSpan::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ScreenTimeSpan)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.time_period_ != nullptr);
    _impl_.time_period_->Clear();
  }
  _impl_.active_duration_ms_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ScreenTimeSpan::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.TimePeriod time_period = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_time_period(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 active_duration_ms = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_active_duration_ms(&has_bits);
          _impl_.active_duration_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScreenTimeSpan::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ScreenTimeSpan)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.TimePeriod time_period = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::time_period(this),
        _Internal::time_period(this).GetCachedSize(), target, stream);
  }

  // optional int64 active_duration_ms = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_active_duration_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ScreenTimeSpan)
  return target;
}

size_t ScreenTimeSpan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ScreenTimeSpan)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .enterprise_management.TimePeriod time_period = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.time_period_);
    }

    // optional int64 active_duration_ms = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_active_duration_ms());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ScreenTimeSpan::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ScreenTimeSpan*>(
      &from));
}

void ScreenTimeSpan::MergeFrom(const ScreenTimeSpan& from) {
  ScreenTimeSpan* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ScreenTimeSpan)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_time_period()->::enterprise_management::TimePeriod::MergeFrom(
          from._internal_time_period());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.active_duration_ms_ = from._impl_.active_duration_ms_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ScreenTimeSpan::CopyFrom(const ScreenTimeSpan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ScreenTimeSpan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScreenTimeSpan::IsInitialized() const {
  return true;
}

void ScreenTimeSpan::InternalSwap(ScreenTimeSpan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScreenTimeSpan, _impl_.active_duration_ms_)
      + sizeof(ScreenTimeSpan::_impl_.active_duration_ms_)
      - PROTOBUF_FIELD_OFFSET(ScreenTimeSpan, _impl_.time_period_)>(
          reinterpret_cast<char*>(&_impl_.time_period_),
          reinterpret_cast<char*>(&other->_impl_.time_period_));
}

std::string ScreenTimeSpan::GetTypeName() const {
  return "enterprise_management.ScreenTimeSpan";
}


// ===================================================================

class ChildStatusReportRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ChildStatusReportRequest>()._impl_._has_bits_);
  static void set_has_user_dm_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_time_zone(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::enterprise_management::AndroidStatus& android_status(const ChildStatusReportRequest* msg);
  static void set_has_android_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_os_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_boot_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::enterprise_management::AndroidStatus&
ChildStatusReportRequest::_Internal::android_status(const ChildStatusReportRequest* msg) {
  return *msg->_impl_.android_status_;
}
ChildStatusReportRequest::ChildStatusReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ChildStatusReportRequest)
}
ChildStatusReportRequest::ChildStatusReportRequest(const ChildStatusReportRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ChildStatusReportRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.screen_time_span_){from._impl_.screen_time_span_}
    , decltype(_impl_.app_activity_){from._impl_.app_activity_}
    , decltype(_impl_.hidden_app_){from._impl_.hidden_app_}
    , decltype(_impl_.user_dm_token_){}
    , decltype(_impl_.time_zone_){}
    , decltype(_impl_.os_version_){}
    , decltype(_impl_.boot_mode_){}
    , decltype(_impl_.android_status_){nullptr}
    , decltype(_impl_.timestamp_ms_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.user_dm_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_dm_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_dm_token()) {
    _this->_impl_.user_dm_token_.Set(from._internal_user_dm_token(), 
      _this->GetArenaForAllocation());
  }
  _impl_.time_zone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.time_zone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_time_zone()) {
    _this->_impl_.time_zone_.Set(from._internal_time_zone(), 
      _this->GetArenaForAllocation());
  }
  _impl_.os_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_os_version()) {
    _this->_impl_.os_version_.Set(from._internal_os_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.boot_mode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.boot_mode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_boot_mode()) {
    _this->_impl_.boot_mode_.Set(from._internal_boot_mode(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_android_status()) {
    _this->_impl_.android_status_ = new ::enterprise_management::AndroidStatus(*from._impl_.android_status_);
  }
  _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ChildStatusReportRequest)
}

inline void ChildStatusReportRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.screen_time_span_){arena}
    , decltype(_impl_.app_activity_){arena}
    , decltype(_impl_.hidden_app_){arena}
    , decltype(_impl_.user_dm_token_){}
    , decltype(_impl_.time_zone_){}
    , decltype(_impl_.os_version_){}
    , decltype(_impl_.boot_mode_){}
    , decltype(_impl_.android_status_){nullptr}
    , decltype(_impl_.timestamp_ms_){int64_t{0}}
  };
  _impl_.user_dm_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_dm_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.time_zone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.time_zone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.os_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.boot_mode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.boot_mode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChildStatusReportRequest::~ChildStatusReportRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.ChildStatusReportRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChildStatusReportRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.screen_time_span_.~RepeatedPtrField();
  _impl_.app_activity_.~RepeatedPtrField();
  _impl_.hidden_app_.~RepeatedPtrField();
  _impl_.user_dm_token_.Destroy();
  _impl_.time_zone_.Destroy();
  _impl_.os_version_.Destroy();
  _impl_.boot_mode_.Destroy();
  if (this != internal_default_instance()) delete _impl_.android_status_;
}

void ChildStatusReportRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChildStatusReportRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ChildStatusReportRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.screen_time_span_.Clear();
  _impl_.app_activity_.Clear();
  _impl_.hidden_app_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.user_dm_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.time_zone_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.os_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.boot_mode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.android_status_ != nullptr);
      _impl_.android_status_->Clear();
    }
  }
  _impl_.timestamp_ms_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChildStatusReportRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_dm_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_dm_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 timestamp_ms = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          _impl_.timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string time_zone = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_time_zone();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.ScreenTimeSpan screen_time_span = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_screen_time_span(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AndroidStatus android_status = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_android_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string os_version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_os_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string boot_mode = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_boot_mode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.AppActivity app_activity = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_app_activity(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.App hidden_app = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_hidden_app(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChildStatusReportRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ChildStatusReportRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string user_dm_token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_dm_token(), target);
  }

  // optional int64 timestamp_ms = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_timestamp_ms(), target);
  }

  // optional string time_zone = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_time_zone(), target);
  }

  // repeated .enterprise_management.ScreenTimeSpan screen_time_span = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_screen_time_span_size()); i < n; i++) {
    const auto& repfield = this->_internal_screen_time_span(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.AndroidStatus android_status = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::android_status(this),
        _Internal::android_status(this).GetCachedSize(), target, stream);
  }

  // optional string os_version = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_os_version(), target);
  }

  // optional string boot_mode = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_boot_mode(), target);
  }

  // repeated .enterprise_management.AppActivity app_activity = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_app_activity_size()); i < n; i++) {
    const auto& repfield = this->_internal_app_activity(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.App hidden_app = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hidden_app_size()); i < n; i++) {
    const auto& repfield = this->_internal_hidden_app(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ChildStatusReportRequest)
  return target;
}

size_t ChildStatusReportRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ChildStatusReportRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.ScreenTimeSpan screen_time_span = 4;
  total_size += 1UL * this->_internal_screen_time_span_size();
  for (const auto& msg : this->_impl_.screen_time_span_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.AppActivity app_activity = 8;
  total_size += 1UL * this->_internal_app_activity_size();
  for (const auto& msg : this->_impl_.app_activity_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .enterprise_management.App hidden_app = 9;
  total_size += 1UL * this->_internal_hidden_app_size();
  for (const auto& msg : this->_impl_.hidden_app_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string user_dm_token = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_dm_token());
    }

    // optional string time_zone = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_time_zone());
    }

    // optional string os_version = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_os_version());
    }

    // optional string boot_mode = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_boot_mode());
    }

    // optional .enterprise_management.AndroidStatus android_status = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.android_status_);
    }

    // optional int64 timestamp_ms = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChildStatusReportRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChildStatusReportRequest*>(
      &from));
}

void ChildStatusReportRequest::MergeFrom(const ChildStatusReportRequest& from) {
  ChildStatusReportRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ChildStatusReportRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.screen_time_span_.MergeFrom(from._impl_.screen_time_span_);
  _this->_impl_.app_activity_.MergeFrom(from._impl_.app_activity_);
  _this->_impl_.hidden_app_.MergeFrom(from._impl_.hidden_app_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_user_dm_token(from._internal_user_dm_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_time_zone(from._internal_time_zone());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_os_version(from._internal_os_version());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_boot_mode(from._internal_boot_mode());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_android_status()->::enterprise_management::AndroidStatus::MergeFrom(
          from._internal_android_status());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChildStatusReportRequest::CopyFrom(const ChildStatusReportRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ChildStatusReportRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChildStatusReportRequest::IsInitialized() const {
  return true;
}

void ChildStatusReportRequest::InternalSwap(ChildStatusReportRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.screen_time_span_.InternalSwap(&other->_impl_.screen_time_span_);
  _impl_.app_activity_.InternalSwap(&other->_impl_.app_activity_);
  _impl_.hidden_app_.InternalSwap(&other->_impl_.hidden_app_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_dm_token_, lhs_arena,
      &other->_impl_.user_dm_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.time_zone_, lhs_arena,
      &other->_impl_.time_zone_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.os_version_, lhs_arena,
      &other->_impl_.os_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.boot_mode_, lhs_arena,
      &other->_impl_.boot_mode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChildStatusReportRequest, _impl_.timestamp_ms_)
      + sizeof(ChildStatusReportRequest::_impl_.timestamp_ms_)
      - PROTOBUF_FIELD_OFFSET(ChildStatusReportRequest, _impl_.android_status_)>(
          reinterpret_cast<char*>(&_impl_.android_status_),
          reinterpret_cast<char*>(&other->_impl_.android_status_));
}

std::string ChildStatusReportRequest::GetTypeName() const {
  return "enterprise_management.ChildStatusReportRequest";
}


// ===================================================================

class ChildStatusReportResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ChildStatusReportResponse>()._impl_._has_bits_);
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ChildStatusReportResponse::ChildStatusReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ChildStatusReportResponse)
}
ChildStatusReportResponse::ChildStatusReportResponse(const ChildStatusReportResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ChildStatusReportResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.error_code_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error_message()) {
    _this->_impl_.error_message_.Set(from._internal_error_message(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.error_code_ = from._impl_.error_code_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ChildStatusReportResponse)
}

inline void ChildStatusReportResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.error_code_){0}
  };
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChildStatusReportResponse::~ChildStatusReportResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.ChildStatusReportResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChildStatusReportResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_message_.Destroy();
}

void ChildStatusReportResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChildStatusReportResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ChildStatusReportResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.error_message_.ClearNonDefaultToEmpty();
  }
  _impl_.error_code_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChildStatusReportResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 error_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_error_code(&has_bits);
          _impl_.error_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string error_message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_error_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChildStatusReportResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ChildStatusReportResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 error_code = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_error_code(), target);
  }

  // optional string error_message = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_error_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ChildStatusReportResponse)
  return target;
}

size_t ChildStatusReportResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ChildStatusReportResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string error_message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error_message());
    }

    // optional int32 error_code = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_error_code());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChildStatusReportResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChildStatusReportResponse*>(
      &from));
}

void ChildStatusReportResponse::MergeFrom(const ChildStatusReportResponse& from) {
  ChildStatusReportResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ChildStatusReportResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.error_code_ = from._impl_.error_code_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChildStatusReportResponse::CopyFrom(const ChildStatusReportResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ChildStatusReportResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChildStatusReportResponse::IsInitialized() const {
  return true;
}

void ChildStatusReportResponse::InternalSwap(ChildStatusReportResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_message_, lhs_arena,
      &other->_impl_.error_message_, rhs_arena
  );
  swap(_impl_.error_code_, other->_impl_.error_code_);
}

std::string ChildStatusReportResponse::GetTypeName() const {
  return "enterprise_management.ChildStatusReportResponse";
}


// ===================================================================

class StartCsrRequest::_Internal {
 public:
};

StartCsrRequest::StartCsrRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.StartCsrRequest)
}
StartCsrRequest::StartCsrRequest(const StartCsrRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  StartCsrRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.StartCsrRequest)
}

inline void StartCsrRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

StartCsrRequest::~StartCsrRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.StartCsrRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StartCsrRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StartCsrRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StartCsrRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.StartCsrRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* StartCsrRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StartCsrRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.StartCsrRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.StartCsrRequest)
  return target;
}

size_t StartCsrRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.StartCsrRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StartCsrRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StartCsrRequest*>(
      &from));
}

void StartCsrRequest::MergeFrom(const StartCsrRequest& from) {
  StartCsrRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.StartCsrRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StartCsrRequest::CopyFrom(const StartCsrRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.StartCsrRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartCsrRequest::IsInitialized() const {
  return true;
}

void StartCsrRequest::InternalSwap(StartCsrRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string StartCsrRequest::GetTypeName() const {
  return "enterprise_management.StartCsrRequest";
}


// ===================================================================

class StartCsrResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<StartCsrResponse>()._impl_._has_bits_);
  static void set_has_invalidation_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_va_challenge(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hashing_algorithm(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_signing_algorithm(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_data_to_sign(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

StartCsrResponse::StartCsrResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.StartCsrResponse)
}
StartCsrResponse::StartCsrResponse(const StartCsrResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  StartCsrResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.invalidation_topic_){}
    , decltype(_impl_.va_challenge_){}
    , decltype(_impl_.data_to_sign_){}
    , decltype(_impl_.signing_algorithm_){}
    , decltype(_impl_.hashing_algorithm_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.invalidation_topic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.invalidation_topic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_invalidation_topic()) {
    _this->_impl_.invalidation_topic_.Set(from._internal_invalidation_topic(), 
      _this->GetArenaForAllocation());
  }
  _impl_.va_challenge_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.va_challenge_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_va_challenge()) {
    _this->_impl_.va_challenge_.Set(from._internal_va_challenge(), 
      _this->GetArenaForAllocation());
  }
  _impl_.data_to_sign_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_to_sign_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data_to_sign()) {
    _this->_impl_.data_to_sign_.Set(from._internal_data_to_sign(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.signing_algorithm_, &from._impl_.signing_algorithm_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hashing_algorithm_) -
    reinterpret_cast<char*>(&_impl_.signing_algorithm_)) + sizeof(_impl_.hashing_algorithm_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.StartCsrResponse)
}

inline void StartCsrResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.invalidation_topic_){}
    , decltype(_impl_.va_challenge_){}
    , decltype(_impl_.data_to_sign_){}
    , decltype(_impl_.signing_algorithm_){0}
    , decltype(_impl_.hashing_algorithm_){0}
  };
  _impl_.invalidation_topic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.invalidation_topic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.va_challenge_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.va_challenge_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_to_sign_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_to_sign_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StartCsrResponse::~StartCsrResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.StartCsrResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StartCsrResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.invalidation_topic_.Destroy();
  _impl_.va_challenge_.Destroy();
  _impl_.data_to_sign_.Destroy();
}

void StartCsrResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StartCsrResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.StartCsrResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.invalidation_topic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.va_challenge_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.data_to_sign_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.signing_algorithm_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hashing_algorithm_) -
        reinterpret_cast<char*>(&_impl_.signing_algorithm_)) + sizeof(_impl_.hashing_algorithm_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StartCsrResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string invalidation_topic = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_invalidation_topic();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes va_challenge = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_va_challenge();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.SigningAlgorithm signing_algorithm = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::SigningAlgorithm_IsValid(val))) {
            _internal_set_signing_algorithm(static_cast<::enterprise_management::SigningAlgorithm>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes data_to_sign = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_data_to_sign();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.HashingAlgorithm hashing_algorithm = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::HashingAlgorithm_IsValid(val))) {
            _internal_set_hashing_algorithm(static_cast<::enterprise_management::HashingAlgorithm>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StartCsrResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.StartCsrResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string invalidation_topic = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_invalidation_topic(), target);
  }

  // optional bytes va_challenge = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_va_challenge(), target);
  }

  // optional .enterprise_management.SigningAlgorithm signing_algorithm = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_signing_algorithm(), target);
  }

  // optional bytes data_to_sign = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_data_to_sign(), target);
  }

  // optional .enterprise_management.HashingAlgorithm hashing_algorithm = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_hashing_algorithm(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.StartCsrResponse)
  return target;
}

size_t StartCsrResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.StartCsrResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string invalidation_topic = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_invalidation_topic());
    }

    // optional bytes va_challenge = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_va_challenge());
    }

    // optional bytes data_to_sign = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data_to_sign());
    }

    // optional .enterprise_management.SigningAlgorithm signing_algorithm = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_signing_algorithm());
    }

    // optional .enterprise_management.HashingAlgorithm hashing_algorithm = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_hashing_algorithm());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StartCsrResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StartCsrResponse*>(
      &from));
}

void StartCsrResponse::MergeFrom(const StartCsrResponse& from) {
  StartCsrResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.StartCsrResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_invalidation_topic(from._internal_invalidation_topic());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_va_challenge(from._internal_va_challenge());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_data_to_sign(from._internal_data_to_sign());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.signing_algorithm_ = from._impl_.signing_algorithm_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.hashing_algorithm_ = from._impl_.hashing_algorithm_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StartCsrResponse::CopyFrom(const StartCsrResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.StartCsrResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartCsrResponse::IsInitialized() const {
  return true;
}

void StartCsrResponse::InternalSwap(StartCsrResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.invalidation_topic_, lhs_arena,
      &other->_impl_.invalidation_topic_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.va_challenge_, lhs_arena,
      &other->_impl_.va_challenge_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_to_sign_, lhs_arena,
      &other->_impl_.data_to_sign_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StartCsrResponse, _impl_.hashing_algorithm_)
      + sizeof(StartCsrResponse::_impl_.hashing_algorithm_)
      - PROTOBUF_FIELD_OFFSET(StartCsrResponse, _impl_.signing_algorithm_)>(
          reinterpret_cast<char*>(&_impl_.signing_algorithm_),
          reinterpret_cast<char*>(&other->_impl_.signing_algorithm_));
}

std::string StartCsrResponse::GetTypeName() const {
  return "enterprise_management.StartCsrResponse";
}


// ===================================================================

class FinishCsrRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<FinishCsrRequest>()._impl_._has_bits_);
  static void set_has_va_challenge_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FinishCsrRequest::FinishCsrRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.FinishCsrRequest)
}
FinishCsrRequest::FinishCsrRequest(const FinishCsrRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FinishCsrRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.va_challenge_response_){}
    , decltype(_impl_.signature_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.va_challenge_response_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.va_challenge_response_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_va_challenge_response()) {
    _this->_impl_.va_challenge_response_.Set(from._internal_va_challenge_response(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.FinishCsrRequest)
}

inline void FinishCsrRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.va_challenge_response_){}
    , decltype(_impl_.signature_){}
  };
  _impl_.va_challenge_response_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.va_challenge_response_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FinishCsrRequest::~FinishCsrRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.FinishCsrRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FinishCsrRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.va_challenge_response_.Destroy();
  _impl_.signature_.Destroy();
}

void FinishCsrRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FinishCsrRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.FinishCsrRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.va_challenge_response_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.signature_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FinishCsrRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes va_challenge_response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_va_challenge_response();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes signature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FinishCsrRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.FinishCsrRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes va_challenge_response = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_va_challenge_response(), target);
  }

  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.FinishCsrRequest)
  return target;
}

size_t FinishCsrRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.FinishCsrRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes va_challenge_response = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_va_challenge_response());
    }

    // optional bytes signature = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_signature());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FinishCsrRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FinishCsrRequest*>(
      &from));
}

void FinishCsrRequest::MergeFrom(const FinishCsrRequest& from) {
  FinishCsrRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.FinishCsrRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_va_challenge_response(from._internal_va_challenge_response());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_signature(from._internal_signature());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FinishCsrRequest::CopyFrom(const FinishCsrRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.FinishCsrRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FinishCsrRequest::IsInitialized() const {
  return true;
}

void FinishCsrRequest::InternalSwap(FinishCsrRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.va_challenge_response_, lhs_arena,
      &other->_impl_.va_challenge_response_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
}

std::string FinishCsrRequest::GetTypeName() const {
  return "enterprise_management.FinishCsrRequest";
}


// ===================================================================

class FinishCsrResponse::_Internal {
 public:
};

FinishCsrResponse::FinishCsrResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.FinishCsrResponse)
}
FinishCsrResponse::FinishCsrResponse(const FinishCsrResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FinishCsrResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.FinishCsrResponse)
}

inline void FinishCsrResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

FinishCsrResponse::~FinishCsrResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.FinishCsrResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FinishCsrResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FinishCsrResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FinishCsrResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.FinishCsrResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* FinishCsrResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FinishCsrResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.FinishCsrResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.FinishCsrResponse)
  return target;
}

size_t FinishCsrResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.FinishCsrResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FinishCsrResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FinishCsrResponse*>(
      &from));
}

void FinishCsrResponse::MergeFrom(const FinishCsrResponse& from) {
  FinishCsrResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.FinishCsrResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FinishCsrResponse::CopyFrom(const FinishCsrResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.FinishCsrResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FinishCsrResponse::IsInitialized() const {
  return true;
}

void FinishCsrResponse::InternalSwap(FinishCsrResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string FinishCsrResponse::GetTypeName() const {
  return "enterprise_management.FinishCsrResponse";
}


// ===================================================================

class DownloadCertRequest::_Internal {
 public:
};

DownloadCertRequest::DownloadCertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DownloadCertRequest)
}
DownloadCertRequest::DownloadCertRequest(const DownloadCertRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DownloadCertRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DownloadCertRequest)
}

inline void DownloadCertRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

DownloadCertRequest::~DownloadCertRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.DownloadCertRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DownloadCertRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DownloadCertRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DownloadCertRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DownloadCertRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* DownloadCertRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DownloadCertRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DownloadCertRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DownloadCertRequest)
  return target;
}

size_t DownloadCertRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DownloadCertRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DownloadCertRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DownloadCertRequest*>(
      &from));
}

void DownloadCertRequest::MergeFrom(const DownloadCertRequest& from) {
  DownloadCertRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DownloadCertRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DownloadCertRequest::CopyFrom(const DownloadCertRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DownloadCertRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownloadCertRequest::IsInitialized() const {
  return true;
}

void DownloadCertRequest::InternalSwap(DownloadCertRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string DownloadCertRequest::GetTypeName() const {
  return "enterprise_management.DownloadCertRequest";
}


// ===================================================================

class DownloadCertResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<DownloadCertResponse>()._impl_._has_bits_);
  static void set_has_pem_encoded_certificate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DownloadCertResponse::DownloadCertResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DownloadCertResponse)
}
DownloadCertResponse::DownloadCertResponse(const DownloadCertResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DownloadCertResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pem_encoded_certificate_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.pem_encoded_certificate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pem_encoded_certificate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pem_encoded_certificate()) {
    _this->_impl_.pem_encoded_certificate_.Set(from._internal_pem_encoded_certificate(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DownloadCertResponse)
}

inline void DownloadCertResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pem_encoded_certificate_){}
  };
  _impl_.pem_encoded_certificate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pem_encoded_certificate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DownloadCertResponse::~DownloadCertResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.DownloadCertResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DownloadCertResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pem_encoded_certificate_.Destroy();
}

void DownloadCertResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DownloadCertResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DownloadCertResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.pem_encoded_certificate_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DownloadCertResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string pem_encoded_certificate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_pem_encoded_certificate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DownloadCertResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DownloadCertResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string pem_encoded_certificate = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_pem_encoded_certificate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DownloadCertResponse)
  return target;
}

size_t DownloadCertResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DownloadCertResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string pem_encoded_certificate = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_pem_encoded_certificate());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DownloadCertResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DownloadCertResponse*>(
      &from));
}

void DownloadCertResponse::MergeFrom(const DownloadCertResponse& from) {
  DownloadCertResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DownloadCertResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pem_encoded_certificate()) {
    _this->_internal_set_pem_encoded_certificate(from._internal_pem_encoded_certificate());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DownloadCertResponse::CopyFrom(const DownloadCertResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DownloadCertResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownloadCertResponse::IsInitialized() const {
  return true;
}

void DownloadCertResponse::InternalSwap(DownloadCertResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pem_encoded_certificate_, lhs_arena,
      &other->_impl_.pem_encoded_certificate_, rhs_arena
  );
}

std::string DownloadCertResponse::GetTypeName() const {
  return "enterprise_management.DownloadCertResponse";
}


// ===================================================================

class CertProvStartOrContinueRequest::_Internal {
 public:
};

CertProvStartOrContinueRequest::CertProvStartOrContinueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CertProvStartOrContinueRequest)
}
CertProvStartOrContinueRequest::CertProvStartOrContinueRequest(const CertProvStartOrContinueRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CertProvStartOrContinueRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CertProvStartOrContinueRequest)
}

inline void CertProvStartOrContinueRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

CertProvStartOrContinueRequest::~CertProvStartOrContinueRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.CertProvStartOrContinueRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CertProvStartOrContinueRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CertProvStartOrContinueRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CertProvStartOrContinueRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CertProvStartOrContinueRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CertProvStartOrContinueRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CertProvStartOrContinueRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CertProvStartOrContinueRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CertProvStartOrContinueRequest)
  return target;
}

size_t CertProvStartOrContinueRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CertProvStartOrContinueRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertProvStartOrContinueRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CertProvStartOrContinueRequest*>(
      &from));
}

void CertProvStartOrContinueRequest::MergeFrom(const CertProvStartOrContinueRequest& from) {
  CertProvStartOrContinueRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CertProvStartOrContinueRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CertProvStartOrContinueRequest::CopyFrom(const CertProvStartOrContinueRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CertProvStartOrContinueRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertProvStartOrContinueRequest::IsInitialized() const {
  return true;
}

void CertProvStartOrContinueRequest::InternalSwap(CertProvStartOrContinueRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CertProvStartOrContinueRequest::GetTypeName() const {
  return "enterprise_management.CertProvStartOrContinueRequest";
}


// ===================================================================

class CertProvAuthorizeRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CertProvAuthorizeRequest>()._impl_._has_bits_);
  static void set_has_va_challenge_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CertProvAuthorizeRequest::CertProvAuthorizeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CertProvAuthorizeRequest)
}
CertProvAuthorizeRequest::CertProvAuthorizeRequest(const CertProvAuthorizeRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CertProvAuthorizeRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.va_challenge_response_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.va_challenge_response_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.va_challenge_response_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_va_challenge_response()) {
    _this->_impl_.va_challenge_response_.Set(from._internal_va_challenge_response(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CertProvAuthorizeRequest)
}

inline void CertProvAuthorizeRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.va_challenge_response_){}
  };
  _impl_.va_challenge_response_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.va_challenge_response_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CertProvAuthorizeRequest::~CertProvAuthorizeRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.CertProvAuthorizeRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CertProvAuthorizeRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.va_challenge_response_.Destroy();
}

void CertProvAuthorizeRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CertProvAuthorizeRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CertProvAuthorizeRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.va_challenge_response_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CertProvAuthorizeRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes va_challenge_response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_va_challenge_response();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CertProvAuthorizeRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CertProvAuthorizeRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes va_challenge_response = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_va_challenge_response(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CertProvAuthorizeRequest)
  return target;
}

size_t CertProvAuthorizeRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CertProvAuthorizeRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes va_challenge_response = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_va_challenge_response());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertProvAuthorizeRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CertProvAuthorizeRequest*>(
      &from));
}

void CertProvAuthorizeRequest::MergeFrom(const CertProvAuthorizeRequest& from) {
  CertProvAuthorizeRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CertProvAuthorizeRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_va_challenge_response()) {
    _this->_internal_set_va_challenge_response(from._internal_va_challenge_response());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CertProvAuthorizeRequest::CopyFrom(const CertProvAuthorizeRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CertProvAuthorizeRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertProvAuthorizeRequest::IsInitialized() const {
  return true;
}

void CertProvAuthorizeRequest::InternalSwap(CertProvAuthorizeRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.va_challenge_response_, lhs_arena,
      &other->_impl_.va_challenge_response_, rhs_arena
  );
}

std::string CertProvAuthorizeRequest::GetTypeName() const {
  return "enterprise_management.CertProvAuthorizeRequest";
}


// ===================================================================

class CertProvUploadProofOfPossessionRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CertProvUploadProofOfPossessionRequest>()._impl_._has_bits_);
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CertProvUploadProofOfPossessionRequest::CertProvUploadProofOfPossessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CertProvUploadProofOfPossessionRequest)
}
CertProvUploadProofOfPossessionRequest::CertProvUploadProofOfPossessionRequest(const CertProvUploadProofOfPossessionRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CertProvUploadProofOfPossessionRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signature_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CertProvUploadProofOfPossessionRequest)
}

inline void CertProvUploadProofOfPossessionRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signature_){}
  };
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CertProvUploadProofOfPossessionRequest::~CertProvUploadProofOfPossessionRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.CertProvUploadProofOfPossessionRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CertProvUploadProofOfPossessionRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.signature_.Destroy();
}

void CertProvUploadProofOfPossessionRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CertProvUploadProofOfPossessionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CertProvUploadProofOfPossessionRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.signature_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CertProvUploadProofOfPossessionRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes signature = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CertProvUploadProofOfPossessionRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CertProvUploadProofOfPossessionRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes signature = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CertProvUploadProofOfPossessionRequest)
  return target;
}

size_t CertProvUploadProofOfPossessionRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CertProvUploadProofOfPossessionRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes signature = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertProvUploadProofOfPossessionRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CertProvUploadProofOfPossessionRequest*>(
      &from));
}

void CertProvUploadProofOfPossessionRequest::MergeFrom(const CertProvUploadProofOfPossessionRequest& from) {
  CertProvUploadProofOfPossessionRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CertProvUploadProofOfPossessionRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_signature()) {
    _this->_internal_set_signature(from._internal_signature());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CertProvUploadProofOfPossessionRequest::CopyFrom(const CertProvUploadProofOfPossessionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CertProvUploadProofOfPossessionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertProvUploadProofOfPossessionRequest::IsInitialized() const {
  return true;
}

void CertProvUploadProofOfPossessionRequest::InternalSwap(CertProvUploadProofOfPossessionRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
}

std::string CertProvUploadProofOfPossessionRequest::GetTypeName() const {
  return "enterprise_management.CertProvUploadProofOfPossessionRequest";
}


// ===================================================================

class CertProvTryLaterInstruction::_Internal {
 public:
  using HasBits = decltype(std::declval<CertProvTryLaterInstruction>()._impl_._has_bits_);
  static void set_has_delay_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CertProvTryLaterInstruction::CertProvTryLaterInstruction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CertProvTryLaterInstruction)
}
CertProvTryLaterInstruction::CertProvTryLaterInstruction(const CertProvTryLaterInstruction& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CertProvTryLaterInstruction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.delay_ms_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.delay_ms_ = from._impl_.delay_ms_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CertProvTryLaterInstruction)
}

inline void CertProvTryLaterInstruction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.delay_ms_){int64_t{0}}
  };
}

CertProvTryLaterInstruction::~CertProvTryLaterInstruction() {
  // @@protoc_insertion_point(destructor:enterprise_management.CertProvTryLaterInstruction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CertProvTryLaterInstruction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CertProvTryLaterInstruction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CertProvTryLaterInstruction::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CertProvTryLaterInstruction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.delay_ms_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CertProvTryLaterInstruction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 delay_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_delay_ms(&has_bits);
          _impl_.delay_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CertProvTryLaterInstruction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CertProvTryLaterInstruction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 delay_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_delay_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CertProvTryLaterInstruction)
  return target;
}

size_t CertProvTryLaterInstruction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CertProvTryLaterInstruction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int64 delay_ms = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_delay_ms());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertProvTryLaterInstruction::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CertProvTryLaterInstruction*>(
      &from));
}

void CertProvTryLaterInstruction::MergeFrom(const CertProvTryLaterInstruction& from) {
  CertProvTryLaterInstruction* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CertProvTryLaterInstruction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_delay_ms()) {
    _this->_internal_set_delay_ms(from._internal_delay_ms());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CertProvTryLaterInstruction::CopyFrom(const CertProvTryLaterInstruction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CertProvTryLaterInstruction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertProvTryLaterInstruction::IsInitialized() const {
  return true;
}

void CertProvTryLaterInstruction::InternalSwap(CertProvTryLaterInstruction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.delay_ms_, other->_impl_.delay_ms_);
}

std::string CertProvTryLaterInstruction::GetTypeName() const {
  return "enterprise_management.CertProvTryLaterInstruction";
}


// ===================================================================

class CertProvAuthorizeInstruction::_Internal {
 public:
  using HasBits = decltype(std::declval<CertProvAuthorizeInstruction>()._impl_._has_bits_);
  static void set_has_va_challenge(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CertProvAuthorizeInstruction::CertProvAuthorizeInstruction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CertProvAuthorizeInstruction)
}
CertProvAuthorizeInstruction::CertProvAuthorizeInstruction(const CertProvAuthorizeInstruction& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CertProvAuthorizeInstruction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.va_challenge_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.va_challenge_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.va_challenge_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_va_challenge()) {
    _this->_impl_.va_challenge_.Set(from._internal_va_challenge(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CertProvAuthorizeInstruction)
}

inline void CertProvAuthorizeInstruction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.va_challenge_){}
  };
  _impl_.va_challenge_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.va_challenge_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CertProvAuthorizeInstruction::~CertProvAuthorizeInstruction() {
  // @@protoc_insertion_point(destructor:enterprise_management.CertProvAuthorizeInstruction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CertProvAuthorizeInstruction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.va_challenge_.Destroy();
}

void CertProvAuthorizeInstruction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CertProvAuthorizeInstruction::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CertProvAuthorizeInstruction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.va_challenge_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CertProvAuthorizeInstruction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes va_challenge = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_va_challenge();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CertProvAuthorizeInstruction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CertProvAuthorizeInstruction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes va_challenge = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_va_challenge(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CertProvAuthorizeInstruction)
  return target;
}

size_t CertProvAuthorizeInstruction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CertProvAuthorizeInstruction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes va_challenge = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_va_challenge());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertProvAuthorizeInstruction::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CertProvAuthorizeInstruction*>(
      &from));
}

void CertProvAuthorizeInstruction::MergeFrom(const CertProvAuthorizeInstruction& from) {
  CertProvAuthorizeInstruction* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CertProvAuthorizeInstruction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_va_challenge()) {
    _this->_internal_set_va_challenge(from._internal_va_challenge());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CertProvAuthorizeInstruction::CopyFrom(const CertProvAuthorizeInstruction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CertProvAuthorizeInstruction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertProvAuthorizeInstruction::IsInitialized() const {
  return true;
}

void CertProvAuthorizeInstruction::InternalSwap(CertProvAuthorizeInstruction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.va_challenge_, lhs_arena,
      &other->_impl_.va_challenge_, rhs_arena
  );
}

std::string CertProvAuthorizeInstruction::GetTypeName() const {
  return "enterprise_management.CertProvAuthorizeInstruction";
}


// ===================================================================

class CertProvProofOfPossessionInstruction::_Internal {
 public:
  using HasBits = decltype(std::declval<CertProvProofOfPossessionInstruction>()._impl_._has_bits_);
  static void set_has_data_to_sign(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CertProvProofOfPossessionInstruction::CertProvProofOfPossessionInstruction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CertProvProofOfPossessionInstruction)
}
CertProvProofOfPossessionInstruction::CertProvProofOfPossessionInstruction(const CertProvProofOfPossessionInstruction& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CertProvProofOfPossessionInstruction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_to_sign_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.data_to_sign_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_to_sign_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data_to_sign()) {
    _this->_impl_.data_to_sign_.Set(from._internal_data_to_sign(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CertProvProofOfPossessionInstruction)
}

inline void CertProvProofOfPossessionInstruction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_to_sign_){}
  };
  _impl_.data_to_sign_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_to_sign_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CertProvProofOfPossessionInstruction::~CertProvProofOfPossessionInstruction() {
  // @@protoc_insertion_point(destructor:enterprise_management.CertProvProofOfPossessionInstruction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CertProvProofOfPossessionInstruction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_to_sign_.Destroy();
}

void CertProvProofOfPossessionInstruction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CertProvProofOfPossessionInstruction::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CertProvProofOfPossessionInstruction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.data_to_sign_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CertProvProofOfPossessionInstruction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes data_to_sign = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_data_to_sign();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CertProvProofOfPossessionInstruction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CertProvProofOfPossessionInstruction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes data_to_sign = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data_to_sign(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CertProvProofOfPossessionInstruction)
  return target;
}

size_t CertProvProofOfPossessionInstruction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CertProvProofOfPossessionInstruction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes data_to_sign = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data_to_sign());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertProvProofOfPossessionInstruction::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CertProvProofOfPossessionInstruction*>(
      &from));
}

void CertProvProofOfPossessionInstruction::MergeFrom(const CertProvProofOfPossessionInstruction& from) {
  CertProvProofOfPossessionInstruction* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CertProvProofOfPossessionInstruction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_data_to_sign()) {
    _this->_internal_set_data_to_sign(from._internal_data_to_sign());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CertProvProofOfPossessionInstruction::CopyFrom(const CertProvProofOfPossessionInstruction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CertProvProofOfPossessionInstruction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertProvProofOfPossessionInstruction::IsInitialized() const {
  return true;
}

void CertProvProofOfPossessionInstruction::InternalSwap(CertProvProofOfPossessionInstruction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_to_sign_, lhs_arena,
      &other->_impl_.data_to_sign_, rhs_arena
  );
}

std::string CertProvProofOfPossessionInstruction::GetTypeName() const {
  return "enterprise_management.CertProvProofOfPossessionInstruction";
}


// ===================================================================

class CertProvImportCertificateInstruction::_Internal {
 public:
  using HasBits = decltype(std::declval<CertProvImportCertificateInstruction>()._impl_._has_bits_);
  static void set_has_pem_encoded_certificate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CertProvImportCertificateInstruction::CertProvImportCertificateInstruction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CertProvImportCertificateInstruction)
}
CertProvImportCertificateInstruction::CertProvImportCertificateInstruction(const CertProvImportCertificateInstruction& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CertProvImportCertificateInstruction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pem_encoded_certificate_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.pem_encoded_certificate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pem_encoded_certificate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pem_encoded_certificate()) {
    _this->_impl_.pem_encoded_certificate_.Set(from._internal_pem_encoded_certificate(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CertProvImportCertificateInstruction)
}

inline void CertProvImportCertificateInstruction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pem_encoded_certificate_){}
  };
  _impl_.pem_encoded_certificate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pem_encoded_certificate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CertProvImportCertificateInstruction::~CertProvImportCertificateInstruction() {
  // @@protoc_insertion_point(destructor:enterprise_management.CertProvImportCertificateInstruction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CertProvImportCertificateInstruction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pem_encoded_certificate_.Destroy();
}

void CertProvImportCertificateInstruction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CertProvImportCertificateInstruction::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CertProvImportCertificateInstruction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.pem_encoded_certificate_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CertProvImportCertificateInstruction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string pem_encoded_certificate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_pem_encoded_certificate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CertProvImportCertificateInstruction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CertProvImportCertificateInstruction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string pem_encoded_certificate = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_pem_encoded_certificate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CertProvImportCertificateInstruction)
  return target;
}

size_t CertProvImportCertificateInstruction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CertProvImportCertificateInstruction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string pem_encoded_certificate = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_pem_encoded_certificate());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertProvImportCertificateInstruction::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CertProvImportCertificateInstruction*>(
      &from));
}

void CertProvImportCertificateInstruction::MergeFrom(const CertProvImportCertificateInstruction& from) {
  CertProvImportCertificateInstruction* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CertProvImportCertificateInstruction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pem_encoded_certificate()) {
    _this->_internal_set_pem_encoded_certificate(from._internal_pem_encoded_certificate());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CertProvImportCertificateInstruction::CopyFrom(const CertProvImportCertificateInstruction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CertProvImportCertificateInstruction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertProvImportCertificateInstruction::IsInitialized() const {
  return true;
}

void CertProvImportCertificateInstruction::InternalSwap(CertProvImportCertificateInstruction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pem_encoded_certificate_, lhs_arena,
      &other->_impl_.pem_encoded_certificate_, rhs_arena
  );
}

std::string CertProvImportCertificateInstruction::GetTypeName() const {
  return "enterprise_management.CertProvImportCertificateInstruction";
}


// ===================================================================

class CertProvNextActionResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CertProvNextActionResponse>()._impl_._has_bits_);
  static void set_has_invalidation_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::enterprise_management::CertProvTryLaterInstruction& try_later_instruction(const CertProvNextActionResponse* msg);
  static const ::enterprise_management::CertProvAuthorizeInstruction& authorize_instruction(const CertProvNextActionResponse* msg);
  static const ::enterprise_management::CertProvProofOfPossessionInstruction& proof_of_possession_instruction(const CertProvNextActionResponse* msg);
  static const ::enterprise_management::CertProvImportCertificateInstruction& import_certificate_instruction(const CertProvNextActionResponse* msg);
};

const ::enterprise_management::CertProvTryLaterInstruction&
CertProvNextActionResponse::_Internal::try_later_instruction(const CertProvNextActionResponse* msg) {
  return *msg->_impl_.instruction_.try_later_instruction_;
}
const ::enterprise_management::CertProvAuthorizeInstruction&
CertProvNextActionResponse::_Internal::authorize_instruction(const CertProvNextActionResponse* msg) {
  return *msg->_impl_.instruction_.authorize_instruction_;
}
const ::enterprise_management::CertProvProofOfPossessionInstruction&
CertProvNextActionResponse::_Internal::proof_of_possession_instruction(const CertProvNextActionResponse* msg) {
  return *msg->_impl_.instruction_.proof_of_possession_instruction_;
}
const ::enterprise_management::CertProvImportCertificateInstruction&
CertProvNextActionResponse::_Internal::import_certificate_instruction(const CertProvNextActionResponse* msg) {
  return *msg->_impl_.instruction_.import_certificate_instruction_;
}
void CertProvNextActionResponse::set_allocated_try_later_instruction(::enterprise_management::CertProvTryLaterInstruction* try_later_instruction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_instruction();
  if (try_later_instruction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(try_later_instruction);
    if (message_arena != submessage_arena) {
      try_later_instruction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, try_later_instruction, submessage_arena);
    }
    set_has_try_later_instruction();
    _impl_.instruction_.try_later_instruction_ = try_later_instruction;
  }
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CertProvNextActionResponse.try_later_instruction)
}
void CertProvNextActionResponse::set_allocated_authorize_instruction(::enterprise_management::CertProvAuthorizeInstruction* authorize_instruction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_instruction();
  if (authorize_instruction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(authorize_instruction);
    if (message_arena != submessage_arena) {
      authorize_instruction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authorize_instruction, submessage_arena);
    }
    set_has_authorize_instruction();
    _impl_.instruction_.authorize_instruction_ = authorize_instruction;
  }
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CertProvNextActionResponse.authorize_instruction)
}
void CertProvNextActionResponse::set_allocated_proof_of_possession_instruction(::enterprise_management::CertProvProofOfPossessionInstruction* proof_of_possession_instruction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_instruction();
  if (proof_of_possession_instruction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(proof_of_possession_instruction);
    if (message_arena != submessage_arena) {
      proof_of_possession_instruction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proof_of_possession_instruction, submessage_arena);
    }
    set_has_proof_of_possession_instruction();
    _impl_.instruction_.proof_of_possession_instruction_ = proof_of_possession_instruction;
  }
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CertProvNextActionResponse.proof_of_possession_instruction)
}
void CertProvNextActionResponse::set_allocated_import_certificate_instruction(::enterprise_management::CertProvImportCertificateInstruction* import_certificate_instruction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_instruction();
  if (import_certificate_instruction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(import_certificate_instruction);
    if (message_arena != submessage_arena) {
      import_certificate_instruction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, import_certificate_instruction, submessage_arena);
    }
    set_has_import_certificate_instruction();
    _impl_.instruction_.import_certificate_instruction_ = import_certificate_instruction;
  }
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.CertProvNextActionResponse.import_certificate_instruction)
}
CertProvNextActionResponse::CertProvNextActionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.CertProvNextActionResponse)
}
CertProvNextActionResponse::CertProvNextActionResponse(const CertProvNextActionResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CertProvNextActionResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.invalidation_topic_){}
    , decltype(_impl_.instruction_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.invalidation_topic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.invalidation_topic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_invalidation_topic()) {
    _this->_impl_.invalidation_topic_.Set(from._internal_invalidation_topic(), 
      _this->GetArenaForAllocation());
  }
  clear_has_instruction();
  switch (from.instruction_case()) {
    case kTryLaterInstruction: {
      _this->_internal_mutable_try_later_instruction()->::enterprise_management::CertProvTryLaterInstruction::MergeFrom(
          from._internal_try_later_instruction());
      break;
    }
    case kAuthorizeInstruction: {
      _this->_internal_mutable_authorize_instruction()->::enterprise_management::CertProvAuthorizeInstruction::MergeFrom(
          from._internal_authorize_instruction());
      break;
    }
    case kProofOfPossessionInstruction: {
      _this->_internal_mutable_proof_of_possession_instruction()->::enterprise_management::CertProvProofOfPossessionInstruction::MergeFrom(
          from._internal_proof_of_possession_instruction());
      break;
    }
    case kImportCertificateInstruction: {
      _this->_internal_mutable_import_certificate_instruction()->::enterprise_management::CertProvImportCertificateInstruction::MergeFrom(
          from._internal_import_certificate_instruction());
      break;
    }
    case INSTRUCTION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.CertProvNextActionResponse)
}

inline void CertProvNextActionResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.invalidation_topic_){}
    , decltype(_impl_.instruction_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.invalidation_topic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.invalidation_topic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_instruction();
}

CertProvNextActionResponse::~CertProvNextActionResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.CertProvNextActionResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CertProvNextActionResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.invalidation_topic_.Destroy();
  if (has_instruction()) {
    clear_instruction();
  }
}

void CertProvNextActionResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CertProvNextActionResponse::clear_instruction() {
// @@protoc_insertion_point(one_of_clear_start:enterprise_management.CertProvNextActionResponse)
  switch (instruction_case()) {
    case kTryLaterInstruction: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.instruction_.try_later_instruction_;
      }
      break;
    }
    case kAuthorizeInstruction: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.instruction_.authorize_instruction_;
      }
      break;
    }
    case kProofOfPossessionInstruction: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.instruction_.proof_of_possession_instruction_;
      }
      break;
    }
    case kImportCertificateInstruction: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.instruction_.import_certificate_instruction_;
      }
      break;
    }
    case INSTRUCTION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = INSTRUCTION_NOT_SET;
}


void CertProvNextActionResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.CertProvNextActionResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.invalidation_topic_.ClearNonDefaultToEmpty();
  }
  clear_instruction();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CertProvNextActionResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string invalidation_topic = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_invalidation_topic();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .enterprise_management.CertProvAuthorizeInstruction authorize_instruction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_authorize_instruction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .enterprise_management.CertProvProofOfPossessionInstruction proof_of_possession_instruction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_proof_of_possession_instruction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .enterprise_management.CertProvImportCertificateInstruction import_certificate_instruction = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_import_certificate_instruction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .enterprise_management.CertProvTryLaterInstruction try_later_instruction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_try_later_instruction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CertProvNextActionResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.CertProvNextActionResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string invalidation_topic = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_invalidation_topic(), target);
  }

  switch (instruction_case()) {
    case kAuthorizeInstruction: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::authorize_instruction(this),
          _Internal::authorize_instruction(this).GetCachedSize(), target, stream);
      break;
    }
    case kProofOfPossessionInstruction: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::proof_of_possession_instruction(this),
          _Internal::proof_of_possession_instruction(this).GetCachedSize(), target, stream);
      break;
    }
    case kImportCertificateInstruction: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::import_certificate_instruction(this),
          _Internal::import_certificate_instruction(this).GetCachedSize(), target, stream);
      break;
    }
    case kTryLaterInstruction: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::try_later_instruction(this),
          _Internal::try_later_instruction(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.CertProvNextActionResponse)
  return target;
}

size_t CertProvNextActionResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.CertProvNextActionResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string invalidation_topic = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_invalidation_topic());
  }

  switch (instruction_case()) {
    // .enterprise_management.CertProvTryLaterInstruction try_later_instruction = 5;
    case kTryLaterInstruction: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.instruction_.try_later_instruction_);
      break;
    }
    // .enterprise_management.CertProvAuthorizeInstruction authorize_instruction = 2;
    case kAuthorizeInstruction: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.instruction_.authorize_instruction_);
      break;
    }
    // .enterprise_management.CertProvProofOfPossessionInstruction proof_of_possession_instruction = 3;
    case kProofOfPossessionInstruction: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.instruction_.proof_of_possession_instruction_);
      break;
    }
    // .enterprise_management.CertProvImportCertificateInstruction import_certificate_instruction = 4;
    case kImportCertificateInstruction: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.instruction_.import_certificate_instruction_);
      break;
    }
    case INSTRUCTION_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertProvNextActionResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CertProvNextActionResponse*>(
      &from));
}

void CertProvNextActionResponse::MergeFrom(const CertProvNextActionResponse& from) {
  CertProvNextActionResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.CertProvNextActionResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_invalidation_topic()) {
    _this->_internal_set_invalidation_topic(from._internal_invalidation_topic());
  }
  switch (from.instruction_case()) {
    case kTryLaterInstruction: {
      _this->_internal_mutable_try_later_instruction()->::enterprise_management::CertProvTryLaterInstruction::MergeFrom(
          from._internal_try_later_instruction());
      break;
    }
    case kAuthorizeInstruction: {
      _this->_internal_mutable_authorize_instruction()->::enterprise_management::CertProvAuthorizeInstruction::MergeFrom(
          from._internal_authorize_instruction());
      break;
    }
    case kProofOfPossessionInstruction: {
      _this->_internal_mutable_proof_of_possession_instruction()->::enterprise_management::CertProvProofOfPossessionInstruction::MergeFrom(
          from._internal_proof_of_possession_instruction());
      break;
    }
    case kImportCertificateInstruction: {
      _this->_internal_mutable_import_certificate_instruction()->::enterprise_management::CertProvImportCertificateInstruction::MergeFrom(
          from._internal_import_certificate_instruction());
      break;
    }
    case INSTRUCTION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CertProvNextActionResponse::CopyFrom(const CertProvNextActionResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.CertProvNextActionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertProvNextActionResponse::IsInitialized() const {
  return true;
}

void CertProvNextActionResponse::InternalSwap(CertProvNextActionResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.invalidation_topic_, lhs_arena,
      &other->_impl_.invalidation_topic_, rhs_arena
  );
  swap(_impl_.instruction_, other->_impl_.instruction_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string CertProvNextActionResponse::GetTypeName() const {
  return "enterprise_management.CertProvNextActionResponse";
}


// ===================================================================

class ClientCertificateProvisioningRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientCertificateProvisioningRequest>()._impl_._has_bits_);
  static void set_has_certificate_scope(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cert_profile_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_public_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_device_dm_token(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::enterprise_management::StartCsrRequest& start_csr_request(const ClientCertificateProvisioningRequest* msg);
  static const ::enterprise_management::FinishCsrRequest& finish_csr_request(const ClientCertificateProvisioningRequest* msg);
  static const ::enterprise_management::DownloadCertRequest& download_cert_request(const ClientCertificateProvisioningRequest* msg);
  static const ::enterprise_management::CertProvStartOrContinueRequest& start_or_continue_request(const ClientCertificateProvisioningRequest* msg);
  static const ::enterprise_management::CertProvAuthorizeRequest& authorize_request(const ClientCertificateProvisioningRequest* msg);
  static const ::enterprise_management::CertProvUploadProofOfPossessionRequest& upload_proof_of_possession_request(const ClientCertificateProvisioningRequest* msg);
  static void set_has_policy_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::enterprise_management::StartCsrRequest&
ClientCertificateProvisioningRequest::_Internal::start_csr_request(const ClientCertificateProvisioningRequest* msg) {
  return *msg->_impl_.request_.start_csr_request_;
}
const ::enterprise_management::FinishCsrRequest&
ClientCertificateProvisioningRequest::_Internal::finish_csr_request(const ClientCertificateProvisioningRequest* msg) {
  return *msg->_impl_.request_.finish_csr_request_;
}
const ::enterprise_management::DownloadCertRequest&
ClientCertificateProvisioningRequest::_Internal::download_cert_request(const ClientCertificateProvisioningRequest* msg) {
  return *msg->_impl_.request_.download_cert_request_;
}
const ::enterprise_management::CertProvStartOrContinueRequest&
ClientCertificateProvisioningRequest::_Internal::start_or_continue_request(const ClientCertificateProvisioningRequest* msg) {
  return *msg->_impl_.request_.start_or_continue_request_;
}
const ::enterprise_management::CertProvAuthorizeRequest&
ClientCertificateProvisioningRequest::_Internal::authorize_request(const ClientCertificateProvisioningRequest* msg) {
  return *msg->_impl_.request_.authorize_request_;
}
const ::enterprise_management::CertProvUploadProofOfPossessionRequest&
ClientCertificateProvisioningRequest::_Internal::upload_proof_of_possession_request(const ClientCertificateProvisioningRequest* msg) {
  return *msg->_impl_.request_.upload_proof_of_possession_request_;
}
void ClientCertificateProvisioningRequest::set_allocated_start_csr_request(::enterprise_management::StartCsrRequest* start_csr_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request();
  if (start_csr_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(start_csr_request);
    if (message_arena != submessage_arena) {
      start_csr_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_csr_request, submessage_arena);
    }
    set_has_start_csr_request();
    _impl_.request_.start_csr_request_ = start_csr_request;
  }
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.start_csr_request)
}
void ClientCertificateProvisioningRequest::set_allocated_finish_csr_request(::enterprise_management::FinishCsrRequest* finish_csr_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request();
  if (finish_csr_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(finish_csr_request);
    if (message_arena != submessage_arena) {
      finish_csr_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, finish_csr_request, submessage_arena);
    }
    set_has_finish_csr_request();
    _impl_.request_.finish_csr_request_ = finish_csr_request;
  }
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.finish_csr_request)
}
void ClientCertificateProvisioningRequest::set_allocated_download_cert_request(::enterprise_management::DownloadCertRequest* download_cert_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request();
  if (download_cert_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(download_cert_request);
    if (message_arena != submessage_arena) {
      download_cert_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, download_cert_request, submessage_arena);
    }
    set_has_download_cert_request();
    _impl_.request_.download_cert_request_ = download_cert_request;
  }
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.download_cert_request)
}
void ClientCertificateProvisioningRequest::set_allocated_start_or_continue_request(::enterprise_management::CertProvStartOrContinueRequest* start_or_continue_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request();
  if (start_or_continue_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(start_or_continue_request);
    if (message_arena != submessage_arena) {
      start_or_continue_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_or_continue_request, submessage_arena);
    }
    set_has_start_or_continue_request();
    _impl_.request_.start_or_continue_request_ = start_or_continue_request;
  }
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.start_or_continue_request)
}
void ClientCertificateProvisioningRequest::set_allocated_authorize_request(::enterprise_management::CertProvAuthorizeRequest* authorize_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request();
  if (authorize_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(authorize_request);
    if (message_arena != submessage_arena) {
      authorize_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authorize_request, submessage_arena);
    }
    set_has_authorize_request();
    _impl_.request_.authorize_request_ = authorize_request;
  }
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.authorize_request)
}
void ClientCertificateProvisioningRequest::set_allocated_upload_proof_of_possession_request(::enterprise_management::CertProvUploadProofOfPossessionRequest* upload_proof_of_possession_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request();
  if (upload_proof_of_possession_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(upload_proof_of_possession_request);
    if (message_arena != submessage_arena) {
      upload_proof_of_possession_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upload_proof_of_possession_request, submessage_arena);
    }
    set_has_upload_proof_of_possession_request();
    _impl_.request_.upload_proof_of_possession_request_ = upload_proof_of_possession_request;
  }
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningRequest.upload_proof_of_possession_request)
}
ClientCertificateProvisioningRequest::ClientCertificateProvisioningRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ClientCertificateProvisioningRequest)
}
ClientCertificateProvisioningRequest::ClientCertificateProvisioningRequest(const ClientCertificateProvisioningRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientCertificateProvisioningRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.certificate_scope_){}
    , decltype(_impl_.cert_profile_id_){}
    , decltype(_impl_.public_key_){}
    , decltype(_impl_.device_dm_token_){}
    , decltype(_impl_.policy_version_){}
    , decltype(_impl_.request_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.certificate_scope_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.certificate_scope_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_certificate_scope()) {
    _this->_impl_.certificate_scope_.Set(from._internal_certificate_scope(), 
      _this->GetArenaForAllocation());
  }
  _impl_.cert_profile_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cert_profile_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cert_profile_id()) {
    _this->_impl_.cert_profile_id_.Set(from._internal_cert_profile_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_public_key()) {
    _this->_impl_.public_key_.Set(from._internal_public_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.device_dm_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_dm_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_dm_token()) {
    _this->_impl_.device_dm_token_.Set(from._internal_device_dm_token(), 
      _this->GetArenaForAllocation());
  }
  _impl_.policy_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_policy_version()) {
    _this->_impl_.policy_version_.Set(from._internal_policy_version(), 
      _this->GetArenaForAllocation());
  }
  clear_has_request();
  switch (from.request_case()) {
    case kStartCsrRequest: {
      _this->_internal_mutable_start_csr_request()->::enterprise_management::StartCsrRequest::MergeFrom(
          from._internal_start_csr_request());
      break;
    }
    case kFinishCsrRequest: {
      _this->_internal_mutable_finish_csr_request()->::enterprise_management::FinishCsrRequest::MergeFrom(
          from._internal_finish_csr_request());
      break;
    }
    case kDownloadCertRequest: {
      _this->_internal_mutable_download_cert_request()->::enterprise_management::DownloadCertRequest::MergeFrom(
          from._internal_download_cert_request());
      break;
    }
    case kStartOrContinueRequest: {
      _this->_internal_mutable_start_or_continue_request()->::enterprise_management::CertProvStartOrContinueRequest::MergeFrom(
          from._internal_start_or_continue_request());
      break;
    }
    case kAuthorizeRequest: {
      _this->_internal_mutable_authorize_request()->::enterprise_management::CertProvAuthorizeRequest::MergeFrom(
          from._internal_authorize_request());
      break;
    }
    case kUploadProofOfPossessionRequest: {
      _this->_internal_mutable_upload_proof_of_possession_request()->::enterprise_management::CertProvUploadProofOfPossessionRequest::MergeFrom(
          from._internal_upload_proof_of_possession_request());
      break;
    }
    case REQUEST_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ClientCertificateProvisioningRequest)
}

inline void ClientCertificateProvisioningRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.certificate_scope_){}
    , decltype(_impl_.cert_profile_id_){}
    , decltype(_impl_.public_key_){}
    , decltype(_impl_.device_dm_token_){}
    , decltype(_impl_.policy_version_){}
    , decltype(_impl_.request_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.certificate_scope_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.certificate_scope_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cert_profile_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cert_profile_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.device_dm_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_dm_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.policy_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.policy_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_request();
}

ClientCertificateProvisioningRequest::~ClientCertificateProvisioningRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.ClientCertificateProvisioningRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientCertificateProvisioningRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.certificate_scope_.Destroy();
  _impl_.cert_profile_id_.Destroy();
  _impl_.public_key_.Destroy();
  _impl_.device_dm_token_.Destroy();
  _impl_.policy_version_.Destroy();
  if (has_request()) {
    clear_request();
  }
}

void ClientCertificateProvisioningRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientCertificateProvisioningRequest::clear_request() {
// @@protoc_insertion_point(one_of_clear_start:enterprise_management.ClientCertificateProvisioningRequest)
  switch (request_case()) {
    case kStartCsrRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.request_.start_csr_request_;
      }
      break;
    }
    case kFinishCsrRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.request_.finish_csr_request_;
      }
      break;
    }
    case kDownloadCertRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.request_.download_cert_request_;
      }
      break;
    }
    case kStartOrContinueRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.request_.start_or_continue_request_;
      }
      break;
    }
    case kAuthorizeRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.request_.authorize_request_;
      }
      break;
    }
    case kUploadProofOfPossessionRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.request_.upload_proof_of_possession_request_;
      }
      break;
    }
    case REQUEST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = REQUEST_NOT_SET;
}


void ClientCertificateProvisioningRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ClientCertificateProvisioningRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.certificate_scope_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.cert_profile_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.public_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.device_dm_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.policy_version_.ClearNonDefaultToEmpty();
    }
  }
  clear_request();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientCertificateProvisioningRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string certificate_scope = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_certificate_scope();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string cert_profile_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_cert_profile_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes public_key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_public_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string device_dm_token = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_device_dm_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .enterprise_management.StartCsrRequest start_csr_request = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_start_csr_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .enterprise_management.FinishCsrRequest finish_csr_request = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_finish_csr_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .enterprise_management.DownloadCertRequest download_cert_request = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_download_cert_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes policy_version = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_policy_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .enterprise_management.CertProvStartOrContinueRequest start_or_continue_request = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_start_or_continue_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .enterprise_management.CertProvAuthorizeRequest authorize_request = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_authorize_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .enterprise_management.CertProvUploadProofOfPossessionRequest upload_proof_of_possession_request = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_upload_proof_of_possession_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientCertificateProvisioningRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ClientCertificateProvisioningRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string certificate_scope = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_certificate_scope(), target);
  }

  // optional string cert_profile_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_cert_profile_id(), target);
  }

  // optional bytes public_key = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_public_key(), target);
  }

  // optional string device_dm_token = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_device_dm_token(), target);
  }

  switch (request_case()) {
    case kStartCsrRequest: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::start_csr_request(this),
          _Internal::start_csr_request(this).GetCachedSize(), target, stream);
      break;
    }
    case kFinishCsrRequest: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::finish_csr_request(this),
          _Internal::finish_csr_request(this).GetCachedSize(), target, stream);
      break;
    }
    case kDownloadCertRequest: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::download_cert_request(this),
          _Internal::download_cert_request(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  // optional bytes policy_version = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_policy_version(), target);
  }

  switch (request_case()) {
    case kStartOrContinueRequest: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::start_or_continue_request(this),
          _Internal::start_or_continue_request(this).GetCachedSize(), target, stream);
      break;
    }
    case kAuthorizeRequest: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::authorize_request(this),
          _Internal::authorize_request(this).GetCachedSize(), target, stream);
      break;
    }
    case kUploadProofOfPossessionRequest: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::upload_proof_of_possession_request(this),
          _Internal::upload_proof_of_possession_request(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ClientCertificateProvisioningRequest)
  return target;
}

size_t ClientCertificateProvisioningRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ClientCertificateProvisioningRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string certificate_scope = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_certificate_scope());
    }

    // optional string cert_profile_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cert_profile_id());
    }

    // optional bytes public_key = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_public_key());
    }

    // optional string device_dm_token = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_dm_token());
    }

    // optional bytes policy_version = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_policy_version());
    }

  }
  switch (request_case()) {
    // .enterprise_management.StartCsrRequest start_csr_request = 5;
    case kStartCsrRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_.start_csr_request_);
      break;
    }
    // .enterprise_management.FinishCsrRequest finish_csr_request = 6;
    case kFinishCsrRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_.finish_csr_request_);
      break;
    }
    // .enterprise_management.DownloadCertRequest download_cert_request = 7;
    case kDownloadCertRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_.download_cert_request_);
      break;
    }
    // .enterprise_management.CertProvStartOrContinueRequest start_or_continue_request = 9;
    case kStartOrContinueRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_.start_or_continue_request_);
      break;
    }
    // .enterprise_management.CertProvAuthorizeRequest authorize_request = 10;
    case kAuthorizeRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_.authorize_request_);
      break;
    }
    // .enterprise_management.CertProvUploadProofOfPossessionRequest upload_proof_of_possession_request = 11;
    case kUploadProofOfPossessionRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_.upload_proof_of_possession_request_);
      break;
    }
    case REQUEST_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientCertificateProvisioningRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientCertificateProvisioningRequest*>(
      &from));
}

void ClientCertificateProvisioningRequest::MergeFrom(const ClientCertificateProvisioningRequest& from) {
  ClientCertificateProvisioningRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ClientCertificateProvisioningRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_certificate_scope(from._internal_certificate_scope());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_cert_profile_id(from._internal_cert_profile_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_public_key(from._internal_public_key());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_device_dm_token(from._internal_device_dm_token());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_policy_version(from._internal_policy_version());
    }
  }
  switch (from.request_case()) {
    case kStartCsrRequest: {
      _this->_internal_mutable_start_csr_request()->::enterprise_management::StartCsrRequest::MergeFrom(
          from._internal_start_csr_request());
      break;
    }
    case kFinishCsrRequest: {
      _this->_internal_mutable_finish_csr_request()->::enterprise_management::FinishCsrRequest::MergeFrom(
          from._internal_finish_csr_request());
      break;
    }
    case kDownloadCertRequest: {
      _this->_internal_mutable_download_cert_request()->::enterprise_management::DownloadCertRequest::MergeFrom(
          from._internal_download_cert_request());
      break;
    }
    case kStartOrContinueRequest: {
      _this->_internal_mutable_start_or_continue_request()->::enterprise_management::CertProvStartOrContinueRequest::MergeFrom(
          from._internal_start_or_continue_request());
      break;
    }
    case kAuthorizeRequest: {
      _this->_internal_mutable_authorize_request()->::enterprise_management::CertProvAuthorizeRequest::MergeFrom(
          from._internal_authorize_request());
      break;
    }
    case kUploadProofOfPossessionRequest: {
      _this->_internal_mutable_upload_proof_of_possession_request()->::enterprise_management::CertProvUploadProofOfPossessionRequest::MergeFrom(
          from._internal_upload_proof_of_possession_request());
      break;
    }
    case REQUEST_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientCertificateProvisioningRequest::CopyFrom(const ClientCertificateProvisioningRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ClientCertificateProvisioningRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientCertificateProvisioningRequest::IsInitialized() const {
  return true;
}

void ClientCertificateProvisioningRequest::InternalSwap(ClientCertificateProvisioningRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.certificate_scope_, lhs_arena,
      &other->_impl_.certificate_scope_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cert_profile_id_, lhs_arena,
      &other->_impl_.cert_profile_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.public_key_, lhs_arena,
      &other->_impl_.public_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_dm_token_, lhs_arena,
      &other->_impl_.device_dm_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.policy_version_, lhs_arena,
      &other->_impl_.policy_version_, rhs_arena
  );
  swap(_impl_.request_, other->_impl_.request_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string ClientCertificateProvisioningRequest::GetTypeName() const {
  return "enterprise_management.ClientCertificateProvisioningRequest";
}


// ===================================================================

class ClientCertificateProvisioningResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientCertificateProvisioningResponse>()._impl_._has_bits_);
  static void set_has_try_again_later(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::enterprise_management::StartCsrResponse& start_csr_response(const ClientCertificateProvisioningResponse* msg);
  static const ::enterprise_management::FinishCsrResponse& finish_csr_response(const ClientCertificateProvisioningResponse* msg);
  static const ::enterprise_management::DownloadCertResponse& download_cert_response(const ClientCertificateProvisioningResponse* msg);
  static const ::enterprise_management::CertProvNextActionResponse& next_action_response(const ClientCertificateProvisioningResponse* msg);
};

const ::enterprise_management::StartCsrResponse&
ClientCertificateProvisioningResponse::_Internal::start_csr_response(const ClientCertificateProvisioningResponse* msg) {
  return *msg->_impl_.response_.start_csr_response_;
}
const ::enterprise_management::FinishCsrResponse&
ClientCertificateProvisioningResponse::_Internal::finish_csr_response(const ClientCertificateProvisioningResponse* msg) {
  return *msg->_impl_.response_.finish_csr_response_;
}
const ::enterprise_management::DownloadCertResponse&
ClientCertificateProvisioningResponse::_Internal::download_cert_response(const ClientCertificateProvisioningResponse* msg) {
  return *msg->_impl_.response_.download_cert_response_;
}
const ::enterprise_management::CertProvNextActionResponse&
ClientCertificateProvisioningResponse::_Internal::next_action_response(const ClientCertificateProvisioningResponse* msg) {
  return *msg->_impl_.response_.next_action_response_;
}
void ClientCertificateProvisioningResponse::set_allocated_start_csr_response(::enterprise_management::StartCsrResponse* start_csr_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (start_csr_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(start_csr_response);
    if (message_arena != submessage_arena) {
      start_csr_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_csr_response, submessage_arena);
    }
    set_has_start_csr_response();
    _impl_.response_.start_csr_response_ = start_csr_response;
  }
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningResponse.start_csr_response)
}
void ClientCertificateProvisioningResponse::set_allocated_finish_csr_response(::enterprise_management::FinishCsrResponse* finish_csr_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (finish_csr_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(finish_csr_response);
    if (message_arena != submessage_arena) {
      finish_csr_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, finish_csr_response, submessage_arena);
    }
    set_has_finish_csr_response();
    _impl_.response_.finish_csr_response_ = finish_csr_response;
  }
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningResponse.finish_csr_response)
}
void ClientCertificateProvisioningResponse::set_allocated_download_cert_response(::enterprise_management::DownloadCertResponse* download_cert_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (download_cert_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(download_cert_response);
    if (message_arena != submessage_arena) {
      download_cert_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, download_cert_response, submessage_arena);
    }
    set_has_download_cert_response();
    _impl_.response_.download_cert_response_ = download_cert_response;
  }
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningResponse.download_cert_response)
}
void ClientCertificateProvisioningResponse::set_allocated_next_action_response(::enterprise_management::CertProvNextActionResponse* next_action_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response();
  if (next_action_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(next_action_response);
    if (message_arena != submessage_arena) {
      next_action_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, next_action_response, submessage_arena);
    }
    set_has_next_action_response();
    _impl_.response_.next_action_response_ = next_action_response;
  }
  // @@protoc_insertion_point(field_set_allocated:enterprise_management.ClientCertificateProvisioningResponse.next_action_response)
}
ClientCertificateProvisioningResponse::ClientCertificateProvisioningResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.ClientCertificateProvisioningResponse)
}
ClientCertificateProvisioningResponse::ClientCertificateProvisioningResponse(const ClientCertificateProvisioningResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientCertificateProvisioningResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.try_again_later_){}
    , decltype(_impl_.response_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.try_again_later_ = from._impl_.try_again_later_;
  clear_has_response();
  switch (from.response_case()) {
    case kError: {
      _this->_internal_set_error(from._internal_error());
      break;
    }
    case kStartCsrResponse: {
      _this->_internal_mutable_start_csr_response()->::enterprise_management::StartCsrResponse::MergeFrom(
          from._internal_start_csr_response());
      break;
    }
    case kFinishCsrResponse: {
      _this->_internal_mutable_finish_csr_response()->::enterprise_management::FinishCsrResponse::MergeFrom(
          from._internal_finish_csr_response());
      break;
    }
    case kDownloadCertResponse: {
      _this->_internal_mutable_download_cert_response()->::enterprise_management::DownloadCertResponse::MergeFrom(
          from._internal_download_cert_response());
      break;
    }
    case kNextActionResponse: {
      _this->_internal_mutable_next_action_response()->::enterprise_management::CertProvNextActionResponse::MergeFrom(
          from._internal_next_action_response());
      break;
    }
    case RESPONSE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.ClientCertificateProvisioningResponse)
}

inline void ClientCertificateProvisioningResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.try_again_later_){int64_t{0}}
    , decltype(_impl_.response_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_response();
}

ClientCertificateProvisioningResponse::~ClientCertificateProvisioningResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.ClientCertificateProvisioningResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientCertificateProvisioningResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_response()) {
    clear_response();
  }
}

void ClientCertificateProvisioningResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientCertificateProvisioningResponse::clear_response() {
// @@protoc_insertion_point(one_of_clear_start:enterprise_management.ClientCertificateProvisioningResponse)
  switch (response_case()) {
    case kError: {
      // No need to clear
      break;
    }
    case kStartCsrResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.start_csr_response_;
      }
      break;
    }
    case kFinishCsrResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.finish_csr_response_;
      }
      break;
    }
    case kDownloadCertResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.download_cert_response_;
      }
      break;
    }
    case kNextActionResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_.next_action_response_;
      }
      break;
    }
    case RESPONSE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}


void ClientCertificateProvisioningResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.ClientCertificateProvisioningResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.try_again_later_ = int64_t{0};
  clear_response();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientCertificateProvisioningResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 try_again_later = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_try_again_later(&has_bits);
          _impl_.try_again_later_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .enterprise_management.ClientCertificateProvisioningResponse.Error error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::ClientCertificateProvisioningResponse_Error_IsValid(val))) {
            _internal_set_error(static_cast<::enterprise_management::ClientCertificateProvisioningResponse_Error>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // .enterprise_management.StartCsrResponse start_csr_response = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_start_csr_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .enterprise_management.FinishCsrResponse finish_csr_response = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_finish_csr_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .enterprise_management.DownloadCertResponse download_cert_response = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_download_cert_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .enterprise_management.CertProvNextActionResponse next_action_response = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_next_action_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientCertificateProvisioningResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.ClientCertificateProvisioningResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 try_again_later = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_try_again_later(), target);
  }

  switch (response_case()) {
    case kError: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_error(), target);
      break;
    }
    case kStartCsrResponse: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::start_csr_response(this),
          _Internal::start_csr_response(this).GetCachedSize(), target, stream);
      break;
    }
    case kFinishCsrResponse: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::finish_csr_response(this),
          _Internal::finish_csr_response(this).GetCachedSize(), target, stream);
      break;
    }
    case kDownloadCertResponse: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::download_cert_response(this),
          _Internal::download_cert_response(this).GetCachedSize(), target, stream);
      break;
    }
    case kNextActionResponse: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::next_action_response(this),
          _Internal::next_action_response(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.ClientCertificateProvisioningResponse)
  return target;
}

size_t ClientCertificateProvisioningResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.ClientCertificateProvisioningResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int64 try_again_later = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_try_again_later());
  }

  switch (response_case()) {
    // .enterprise_management.ClientCertificateProvisioningResponse.Error error = 2;
    case kError: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
      break;
    }
    // .enterprise_management.StartCsrResponse start_csr_response = 3;
    case kStartCsrResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.start_csr_response_);
      break;
    }
    // .enterprise_management.FinishCsrResponse finish_csr_response = 4;
    case kFinishCsrResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.finish_csr_response_);
      break;
    }
    // .enterprise_management.DownloadCertResponse download_cert_response = 5;
    case kDownloadCertResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.download_cert_response_);
      break;
    }
    // .enterprise_management.CertProvNextActionResponse next_action_response = 6;
    case kNextActionResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_.next_action_response_);
      break;
    }
    case RESPONSE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientCertificateProvisioningResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientCertificateProvisioningResponse*>(
      &from));
}

void ClientCertificateProvisioningResponse::MergeFrom(const ClientCertificateProvisioningResponse& from) {
  ClientCertificateProvisioningResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.ClientCertificateProvisioningResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_try_again_later()) {
    _this->_internal_set_try_again_later(from._internal_try_again_later());
  }
  switch (from.response_case()) {
    case kError: {
      _this->_internal_set_error(from._internal_error());
      break;
    }
    case kStartCsrResponse: {
      _this->_internal_mutable_start_csr_response()->::enterprise_management::StartCsrResponse::MergeFrom(
          from._internal_start_csr_response());
      break;
    }
    case kFinishCsrResponse: {
      _this->_internal_mutable_finish_csr_response()->::enterprise_management::FinishCsrResponse::MergeFrom(
          from._internal_finish_csr_response());
      break;
    }
    case kDownloadCertResponse: {
      _this->_internal_mutable_download_cert_response()->::enterprise_management::DownloadCertResponse::MergeFrom(
          from._internal_download_cert_response());
      break;
    }
    case kNextActionResponse: {
      _this->_internal_mutable_next_action_response()->::enterprise_management::CertProvNextActionResponse::MergeFrom(
          from._internal_next_action_response());
      break;
    }
    case RESPONSE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientCertificateProvisioningResponse::CopyFrom(const ClientCertificateProvisioningResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.ClientCertificateProvisioningResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientCertificateProvisioningResponse::IsInitialized() const {
  return true;
}

void ClientCertificateProvisioningResponse::InternalSwap(ClientCertificateProvisioningResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.try_again_later_, other->_impl_.try_again_later_);
  swap(_impl_.response_, other->_impl_.response_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string ClientCertificateProvisioningResponse::GetTypeName() const {
  return "enterprise_management.ClientCertificateProvisioningResponse";
}


// ===================================================================

class BrowserPublicKeyUploadRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<BrowserPublicKeyUploadRequest>()._impl_._has_bits_);
  static void set_has_public_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_key_trust_level(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_key_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

BrowserPublicKeyUploadRequest::BrowserPublicKeyUploadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.BrowserPublicKeyUploadRequest)
}
BrowserPublicKeyUploadRequest::BrowserPublicKeyUploadRequest(const BrowserPublicKeyUploadRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BrowserPublicKeyUploadRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.public_key_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.key_trust_level_){}
    , decltype(_impl_.key_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_public_key()) {
    _this->_impl_.public_key_.Set(from._internal_public_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.key_trust_level_, &from._impl_.key_trust_level_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.key_type_) -
    reinterpret_cast<char*>(&_impl_.key_trust_level_)) + sizeof(_impl_.key_type_));
  // @@protoc_insertion_point(copy_constructor:enterprise_management.BrowserPublicKeyUploadRequest)
}

inline void BrowserPublicKeyUploadRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.public_key_){}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.key_trust_level_){0}
    , decltype(_impl_.key_type_){0}
  };
  _impl_.public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BrowserPublicKeyUploadRequest::~BrowserPublicKeyUploadRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.BrowserPublicKeyUploadRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BrowserPublicKeyUploadRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.public_key_.Destroy();
  _impl_.signature_.Destroy();
}

void BrowserPublicKeyUploadRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BrowserPublicKeyUploadRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.BrowserPublicKeyUploadRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.public_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.signature_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.key_trust_level_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.key_type_) -
        reinterpret_cast<char*>(&_impl_.key_trust_level_)) + sizeof(_impl_.key_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BrowserPublicKeyUploadRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes public_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_public_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes signature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BrowserPublicKeyUploadRequest.KeyTrustLevel key_trust_level = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::BrowserPublicKeyUploadRequest_KeyTrustLevel_IsValid(val))) {
            _internal_set_key_trust_level(static_cast<::enterprise_management::BrowserPublicKeyUploadRequest_KeyTrustLevel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BrowserPublicKeyUploadRequest.KeyType key_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::BrowserPublicKeyUploadRequest_KeyType_IsValid(val))) {
            _internal_set_key_type(static_cast<::enterprise_management::BrowserPublicKeyUploadRequest_KeyType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BrowserPublicKeyUploadRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.BrowserPublicKeyUploadRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes public_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_public_key(), target);
  }

  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_signature(), target);
  }

  // optional .enterprise_management.BrowserPublicKeyUploadRequest.KeyTrustLevel key_trust_level = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_key_trust_level(), target);
  }

  // optional .enterprise_management.BrowserPublicKeyUploadRequest.KeyType key_type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_key_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.BrowserPublicKeyUploadRequest)
  return target;
}

size_t BrowserPublicKeyUploadRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.BrowserPublicKeyUploadRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes public_key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_public_key());
    }

    // optional bytes signature = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_signature());
    }

    // optional .enterprise_management.BrowserPublicKeyUploadRequest.KeyTrustLevel key_trust_level = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_key_trust_level());
    }

    // optional .enterprise_management.BrowserPublicKeyUploadRequest.KeyType key_type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_key_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BrowserPublicKeyUploadRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BrowserPublicKeyUploadRequest*>(
      &from));
}

void BrowserPublicKeyUploadRequest::MergeFrom(const BrowserPublicKeyUploadRequest& from) {
  BrowserPublicKeyUploadRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.BrowserPublicKeyUploadRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_public_key(from._internal_public_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.key_trust_level_ = from._impl_.key_trust_level_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.key_type_ = from._impl_.key_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BrowserPublicKeyUploadRequest::CopyFrom(const BrowserPublicKeyUploadRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.BrowserPublicKeyUploadRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BrowserPublicKeyUploadRequest::IsInitialized() const {
  return true;
}

void BrowserPublicKeyUploadRequest::InternalSwap(BrowserPublicKeyUploadRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.public_key_, lhs_arena,
      &other->_impl_.public_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BrowserPublicKeyUploadRequest, _impl_.key_type_)
      + sizeof(BrowserPublicKeyUploadRequest::_impl_.key_type_)
      - PROTOBUF_FIELD_OFFSET(BrowserPublicKeyUploadRequest, _impl_.key_trust_level_)>(
          reinterpret_cast<char*>(&_impl_.key_trust_level_),
          reinterpret_cast<char*>(&other->_impl_.key_trust_level_));
}

std::string BrowserPublicKeyUploadRequest::GetTypeName() const {
  return "enterprise_management.BrowserPublicKeyUploadRequest";
}


// ===================================================================

class BrowserPublicKeyUploadResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<BrowserPublicKeyUploadResponse>()._impl_._has_bits_);
  static void set_has_response_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BrowserPublicKeyUploadResponse::BrowserPublicKeyUploadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.BrowserPublicKeyUploadResponse)
}
BrowserPublicKeyUploadResponse::BrowserPublicKeyUploadResponse(const BrowserPublicKeyUploadResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BrowserPublicKeyUploadResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_code_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.response_code_ = from._impl_.response_code_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.BrowserPublicKeyUploadResponse)
}

inline void BrowserPublicKeyUploadResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_code_){0}
  };
}

BrowserPublicKeyUploadResponse::~BrowserPublicKeyUploadResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.BrowserPublicKeyUploadResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BrowserPublicKeyUploadResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BrowserPublicKeyUploadResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BrowserPublicKeyUploadResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.BrowserPublicKeyUploadResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.response_code_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BrowserPublicKeyUploadResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.BrowserPublicKeyUploadResponse.ResponseCode response_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_management::BrowserPublicKeyUploadResponse_ResponseCode_IsValid(val))) {
            _internal_set_response_code(static_cast<::enterprise_management::BrowserPublicKeyUploadResponse_ResponseCode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BrowserPublicKeyUploadResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.BrowserPublicKeyUploadResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.BrowserPublicKeyUploadResponse.ResponseCode response_code = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_response_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.BrowserPublicKeyUploadResponse)
  return target;
}

size_t BrowserPublicKeyUploadResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.BrowserPublicKeyUploadResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .enterprise_management.BrowserPublicKeyUploadResponse.ResponseCode response_code = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_response_code());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BrowserPublicKeyUploadResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BrowserPublicKeyUploadResponse*>(
      &from));
}

void BrowserPublicKeyUploadResponse::MergeFrom(const BrowserPublicKeyUploadResponse& from) {
  BrowserPublicKeyUploadResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.BrowserPublicKeyUploadResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_response_code()) {
    _this->_internal_set_response_code(from._internal_response_code());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BrowserPublicKeyUploadResponse::CopyFrom(const BrowserPublicKeyUploadResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.BrowserPublicKeyUploadResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BrowserPublicKeyUploadResponse::IsInitialized() const {
  return true;
}

void BrowserPublicKeyUploadResponse::InternalSwap(BrowserPublicKeyUploadResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.response_code_, other->_impl_.response_code_);
}

std::string BrowserPublicKeyUploadResponse::GetTypeName() const {
  return "enterprise_management.BrowserPublicKeyUploadResponse";
}


// ===================================================================

class DeviceManagementRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceManagementRequest>()._impl_._has_bits_);
  static const ::enterprise_management::DeviceRegisterRequest& register_request(const DeviceManagementRequest* msg);
  static void set_has_register_request(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::enterprise_management::DeviceUnregisterRequest& unregister_request(const DeviceManagementRequest* msg);
  static void set_has_unregister_request(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::enterprise_management::DevicePolicyRequest& policy_request(const DeviceManagementRequest* msg);
  static void set_has_policy_request(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::enterprise_management::DeviceStatusReportRequest& device_status_report_request(const DeviceManagementRequest* msg);
  static void set_has_device_status_report_request(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::enterprise_management::SessionStatusReportRequest& session_status_report_request(const DeviceManagementRequest* msg);
  static void set_has_session_status_report_request(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::enterprise_management::ChildStatusReportRequest& child_status_report_request(const DeviceManagementRequest* msg);
  static void set_has_child_status_report_request(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static const ::enterprise_management::DeviceAutoEnrollmentRequest& auto_enrollment_request(const DeviceManagementRequest* msg);
  static void set_has_auto_enrollment_request(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::enterprise_management::DeviceCertUploadRequest& cert_upload_request(const DeviceManagementRequest* msg);
  static void set_has_cert_upload_request(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::enterprise_management::DeviceServiceApiAccessRequest& service_api_access_request(const DeviceManagementRequest* msg);
  static void set_has_service_api_access_request(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::enterprise_management::DeviceStateRetrievalRequest& device_state_retrieval_request(const DeviceManagementRequest* msg);
  static void set_has_device_state_retrieval_request(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::enterprise_management::DeviceStateKeyUpdateRequest& device_state_key_update_request(const DeviceManagementRequest* msg);
  static void set_has_device_state_key_update_request(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::enterprise_management::DevicePairingRequest& device_pairing_request(const DeviceManagementRequest* msg);
  static void set_has_device_pairing_request(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::enterprise_management::CheckDevicePairingRequest& check_device_pairing_request(const DeviceManagementRequest* msg);
  static void set_has_check_device_pairing_request(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::enterprise_management::DeviceRemoteCommandRequest& remote_command_request(const DeviceManagementRequest* msg);
  static void set_has_remote_command_request(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::enterprise_management::DeviceAttributeUpdatePermissionRequest& device_attribute_update_permission_request(const DeviceManagementRequest* msg);
  static void set_has_device_attribute_update_permission_request(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::enterprise_management::DeviceAttributeUpdateRequest& device_attribute_update_request(const DeviceManagementRequest* msg);
  static void set_has_device_attribute_update_request(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::enterprise_management::GcmIdUpdateRequest& gcm_id_update_request(const DeviceManagementRequest* msg);
  static void set_has_gcm_id_update_request(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::enterprise_management::CheckAndroidManagementRequest& check_android_management_request(const DeviceManagementRequest* msg);
  static void set_has_check_android_management_request(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::enterprise_management::CertificateBasedDeviceRegisterRequest& certificate_based_register_request(const DeviceManagementRequest* msg);
  static void set_has_certificate_based_register_request(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest& active_directory_enroll_play_user_request(const DeviceManagementRequest* msg);
  static void set_has_active_directory_enroll_play_user_request(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::enterprise_management::ActiveDirectoryPlayActivityRequest& active_directory_play_activity_request(const DeviceManagementRequest* msg);
  static void set_has_active_directory_play_activity_request(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::enterprise_management::CheckDeviceLicenseRequest& check_device_license_request_deprecated(const DeviceManagementRequest* msg);
  static void set_has_check_device_license_request_deprecated(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::enterprise_management::ActiveDirectoryUserSigninRequest& active_directory_user_signin_request(const DeviceManagementRequest* msg);
  static void set_has_active_directory_user_signin_request(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::enterprise_management::RegisterBrowserRequest& register_browser_request(const DeviceManagementRequest* msg);
  static void set_has_register_browser_request(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static const ::enterprise_management::AppInstallReportRequest& app_install_report_request(const DeviceManagementRequest* msg);
  static void set_has_app_install_report_request(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static const ::enterprise_management::ChromeDesktopReportRequest& chrome_desktop_report_request(const DeviceManagementRequest* msg);
  static void set_has_chrome_desktop_report_request(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static const ::enterprise_management::PolicyValidationReportRequest& policy_validation_report_request(const DeviceManagementRequest* msg);
  static void set_has_policy_validation_report_request(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static const ::enterprise_management::DeviceInitialEnrollmentStateRequest& device_initial_enrollment_state_request(const DeviceManagementRequest* msg);
  static void set_has_device_initial_enrollment_state_request(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static const ::enterprise_management::RefreshAccountRequest& refresh_account_request(const DeviceManagementRequest* msg);
  static void set_has_refresh_account_request(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static const ::enterprise_management::RsuLookupKeyUploadRequest& rsu_lookup_key_upload_request(const DeviceManagementRequest* msg);
  static void set_has_rsu_lookup_key_upload_request(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static const ::enterprise_management::PublicSamlUserRequest& public_saml_user_request(const DeviceManagementRequest* msg);
  static void set_has_public_saml_user_request(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static const ::enterprise_management::ChromeOsUserReportRequest& chrome_os_user_report_request(const DeviceManagementRequest* msg);
  static void set_has_chrome_os_user_report_request(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static const ::enterprise_management::ClientCertificateProvisioningRequest& client_certificate_provisioning_request(const DeviceManagementRequest* msg);
  static void set_has_client_certificate_provisioning_request(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static const ::enterprise_management::ExtensionInstallReportRequest& extension_install_report_request(const DeviceManagementRequest* msg);
  static void set_has_extension_install_report_request(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static const ::enterprise_management::CheckUserAccountRequest& check_user_account_request(const DeviceManagementRequest* msg);
  static void set_has_check_user_account_request(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static const ::enterprise_management::PrivateSetMembershipRequest& private_set_membership_request(const DeviceManagementRequest* msg);
  static void set_has_private_set_membership_request(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static const ::enterprise_management::BrowserPublicKeyUploadRequest& browser_public_key_upload_request(const DeviceManagementRequest* msg);
  static void set_has_browser_public_key_upload_request(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static const ::enterprise_management::UploadEuiccInfoRequest& upload_euicc_info_request(const DeviceManagementRequest* msg);
  static void set_has_upload_euicc_info_request(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static const ::enterprise_management::ChromeProfileReportRequest& chrome_profile_report_request(const DeviceManagementRequest* msg);
  static void set_has_chrome_profile_report_request(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
};

const ::enterprise_management::DeviceRegisterRequest&
DeviceManagementRequest::_Internal::register_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.register_request_;
}
const ::enterprise_management::DeviceUnregisterRequest&
DeviceManagementRequest::_Internal::unregister_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.unregister_request_;
}
const ::enterprise_management::DevicePolicyRequest&
DeviceManagementRequest::_Internal::policy_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.policy_request_;
}
const ::enterprise_management::DeviceStatusReportRequest&
DeviceManagementRequest::_Internal::device_status_report_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.device_status_report_request_;
}
const ::enterprise_management::SessionStatusReportRequest&
DeviceManagementRequest::_Internal::session_status_report_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.session_status_report_request_;
}
const ::enterprise_management::ChildStatusReportRequest&
DeviceManagementRequest::_Internal::child_status_report_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.child_status_report_request_;
}
const ::enterprise_management::DeviceAutoEnrollmentRequest&
DeviceManagementRequest::_Internal::auto_enrollment_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.auto_enrollment_request_;
}
const ::enterprise_management::DeviceCertUploadRequest&
DeviceManagementRequest::_Internal::cert_upload_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.cert_upload_request_;
}
const ::enterprise_management::DeviceServiceApiAccessRequest&
DeviceManagementRequest::_Internal::service_api_access_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.service_api_access_request_;
}
const ::enterprise_management::DeviceStateRetrievalRequest&
DeviceManagementRequest::_Internal::device_state_retrieval_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.device_state_retrieval_request_;
}
const ::enterprise_management::DeviceStateKeyUpdateRequest&
DeviceManagementRequest::_Internal::device_state_key_update_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.device_state_key_update_request_;
}
const ::enterprise_management::DevicePairingRequest&
DeviceManagementRequest::_Internal::device_pairing_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.device_pairing_request_;
}
const ::enterprise_management::CheckDevicePairingRequest&
DeviceManagementRequest::_Internal::check_device_pairing_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.check_device_pairing_request_;
}
const ::enterprise_management::DeviceRemoteCommandRequest&
DeviceManagementRequest::_Internal::remote_command_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.remote_command_request_;
}
const ::enterprise_management::DeviceAttributeUpdatePermissionRequest&
DeviceManagementRequest::_Internal::device_attribute_update_permission_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.device_attribute_update_permission_request_;
}
const ::enterprise_management::DeviceAttributeUpdateRequest&
DeviceManagementRequest::_Internal::device_attribute_update_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.device_attribute_update_request_;
}
const ::enterprise_management::GcmIdUpdateRequest&
DeviceManagementRequest::_Internal::gcm_id_update_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.gcm_id_update_request_;
}
const ::enterprise_management::CheckAndroidManagementRequest&
DeviceManagementRequest::_Internal::check_android_management_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.check_android_management_request_;
}
const ::enterprise_management::CertificateBasedDeviceRegisterRequest&
DeviceManagementRequest::_Internal::certificate_based_register_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.certificate_based_register_request_;
}
const ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest&
DeviceManagementRequest::_Internal::active_directory_enroll_play_user_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.active_directory_enroll_play_user_request_;
}
const ::enterprise_management::ActiveDirectoryPlayActivityRequest&
DeviceManagementRequest::_Internal::active_directory_play_activity_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.active_directory_play_activity_request_;
}
const ::enterprise_management::CheckDeviceLicenseRequest&
DeviceManagementRequest::_Internal::check_device_license_request_deprecated(const DeviceManagementRequest* msg) {
  return *msg->_impl_.check_device_license_request_deprecated_;
}
const ::enterprise_management::ActiveDirectoryUserSigninRequest&
DeviceManagementRequest::_Internal::active_directory_user_signin_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.active_directory_user_signin_request_;
}
const ::enterprise_management::RegisterBrowserRequest&
DeviceManagementRequest::_Internal::register_browser_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.register_browser_request_;
}
const ::enterprise_management::AppInstallReportRequest&
DeviceManagementRequest::_Internal::app_install_report_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.app_install_report_request_;
}
const ::enterprise_management::ChromeDesktopReportRequest&
DeviceManagementRequest::_Internal::chrome_desktop_report_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.chrome_desktop_report_request_;
}
const ::enterprise_management::PolicyValidationReportRequest&
DeviceManagementRequest::_Internal::policy_validation_report_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.policy_validation_report_request_;
}
const ::enterprise_management::DeviceInitialEnrollmentStateRequest&
DeviceManagementRequest::_Internal::device_initial_enrollment_state_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.device_initial_enrollment_state_request_;
}
const ::enterprise_management::RefreshAccountRequest&
DeviceManagementRequest::_Internal::refresh_account_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.refresh_account_request_;
}
const ::enterprise_management::RsuLookupKeyUploadRequest&
DeviceManagementRequest::_Internal::rsu_lookup_key_upload_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.rsu_lookup_key_upload_request_;
}
const ::enterprise_management::PublicSamlUserRequest&
DeviceManagementRequest::_Internal::public_saml_user_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.public_saml_user_request_;
}
const ::enterprise_management::ChromeOsUserReportRequest&
DeviceManagementRequest::_Internal::chrome_os_user_report_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.chrome_os_user_report_request_;
}
const ::enterprise_management::ClientCertificateProvisioningRequest&
DeviceManagementRequest::_Internal::client_certificate_provisioning_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.client_certificate_provisioning_request_;
}
const ::enterprise_management::ExtensionInstallReportRequest&
DeviceManagementRequest::_Internal::extension_install_report_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.extension_install_report_request_;
}
const ::enterprise_management::CheckUserAccountRequest&
DeviceManagementRequest::_Internal::check_user_account_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.check_user_account_request_;
}
const ::enterprise_management::PrivateSetMembershipRequest&
DeviceManagementRequest::_Internal::private_set_membership_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.private_set_membership_request_;
}
const ::enterprise_management::BrowserPublicKeyUploadRequest&
DeviceManagementRequest::_Internal::browser_public_key_upload_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.browser_public_key_upload_request_;
}
const ::enterprise_management::UploadEuiccInfoRequest&
DeviceManagementRequest::_Internal::upload_euicc_info_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.upload_euicc_info_request_;
}
const ::enterprise_management::ChromeProfileReportRequest&
DeviceManagementRequest::_Internal::chrome_profile_report_request(const DeviceManagementRequest* msg) {
  return *msg->_impl_.chrome_profile_report_request_;
}
DeviceManagementRequest::DeviceManagementRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceManagementRequest)
}
DeviceManagementRequest::DeviceManagementRequest(const DeviceManagementRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceManagementRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.register_request_){nullptr}
    , decltype(_impl_.unregister_request_){nullptr}
    , decltype(_impl_.policy_request_){nullptr}
    , decltype(_impl_.device_status_report_request_){nullptr}
    , decltype(_impl_.session_status_report_request_){nullptr}
    , decltype(_impl_.auto_enrollment_request_){nullptr}
    , decltype(_impl_.cert_upload_request_){nullptr}
    , decltype(_impl_.service_api_access_request_){nullptr}
    , decltype(_impl_.device_state_retrieval_request_){nullptr}
    , decltype(_impl_.device_state_key_update_request_){nullptr}
    , decltype(_impl_.device_pairing_request_){nullptr}
    , decltype(_impl_.check_device_pairing_request_){nullptr}
    , decltype(_impl_.remote_command_request_){nullptr}
    , decltype(_impl_.device_attribute_update_permission_request_){nullptr}
    , decltype(_impl_.device_attribute_update_request_){nullptr}
    , decltype(_impl_.gcm_id_update_request_){nullptr}
    , decltype(_impl_.check_android_management_request_){nullptr}
    , decltype(_impl_.certificate_based_register_request_){nullptr}
    , decltype(_impl_.active_directory_enroll_play_user_request_){nullptr}
    , decltype(_impl_.active_directory_play_activity_request_){nullptr}
    , decltype(_impl_.check_device_license_request_deprecated_){nullptr}
    , decltype(_impl_.active_directory_user_signin_request_){nullptr}
    , decltype(_impl_.register_browser_request_){nullptr}
    , decltype(_impl_.app_install_report_request_){nullptr}
    , decltype(_impl_.chrome_desktop_report_request_){nullptr}
    , decltype(_impl_.policy_validation_report_request_){nullptr}
    , decltype(_impl_.device_initial_enrollment_state_request_){nullptr}
    , decltype(_impl_.refresh_account_request_){nullptr}
    , decltype(_impl_.child_status_report_request_){nullptr}
    , decltype(_impl_.rsu_lookup_key_upload_request_){nullptr}
    , decltype(_impl_.public_saml_user_request_){nullptr}
    , decltype(_impl_.chrome_os_user_report_request_){nullptr}
    , decltype(_impl_.client_certificate_provisioning_request_){nullptr}
    , decltype(_impl_.extension_install_report_request_){nullptr}
    , decltype(_impl_.check_user_account_request_){nullptr}
    , decltype(_impl_.private_set_membership_request_){nullptr}
    , decltype(_impl_.browser_public_key_upload_request_){nullptr}
    , decltype(_impl_.upload_euicc_info_request_){nullptr}
    , decltype(_impl_.chrome_profile_report_request_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_register_request()) {
    _this->_impl_.register_request_ = new ::enterprise_management::DeviceRegisterRequest(*from._impl_.register_request_);
  }
  if (from._internal_has_unregister_request()) {
    _this->_impl_.unregister_request_ = new ::enterprise_management::DeviceUnregisterRequest(*from._impl_.unregister_request_);
  }
  if (from._internal_has_policy_request()) {
    _this->_impl_.policy_request_ = new ::enterprise_management::DevicePolicyRequest(*from._impl_.policy_request_);
  }
  if (from._internal_has_device_status_report_request()) {
    _this->_impl_.device_status_report_request_ = new ::enterprise_management::DeviceStatusReportRequest(*from._impl_.device_status_report_request_);
  }
  if (from._internal_has_session_status_report_request()) {
    _this->_impl_.session_status_report_request_ = new ::enterprise_management::SessionStatusReportRequest(*from._impl_.session_status_report_request_);
  }
  if (from._internal_has_auto_enrollment_request()) {
    _this->_impl_.auto_enrollment_request_ = new ::enterprise_management::DeviceAutoEnrollmentRequest(*from._impl_.auto_enrollment_request_);
  }
  if (from._internal_has_cert_upload_request()) {
    _this->_impl_.cert_upload_request_ = new ::enterprise_management::DeviceCertUploadRequest(*from._impl_.cert_upload_request_);
  }
  if (from._internal_has_service_api_access_request()) {
    _this->_impl_.service_api_access_request_ = new ::enterprise_management::DeviceServiceApiAccessRequest(*from._impl_.service_api_access_request_);
  }
  if (from._internal_has_device_state_retrieval_request()) {
    _this->_impl_.device_state_retrieval_request_ = new ::enterprise_management::DeviceStateRetrievalRequest(*from._impl_.device_state_retrieval_request_);
  }
  if (from._internal_has_device_state_key_update_request()) {
    _this->_impl_.device_state_key_update_request_ = new ::enterprise_management::DeviceStateKeyUpdateRequest(*from._impl_.device_state_key_update_request_);
  }
  if (from._internal_has_device_pairing_request()) {
    _this->_impl_.device_pairing_request_ = new ::enterprise_management::DevicePairingRequest(*from._impl_.device_pairing_request_);
  }
  if (from._internal_has_check_device_pairing_request()) {
    _this->_impl_.check_device_pairing_request_ = new ::enterprise_management::CheckDevicePairingRequest(*from._impl_.check_device_pairing_request_);
  }
  if (from._internal_has_remote_command_request()) {
    _this->_impl_.remote_command_request_ = new ::enterprise_management::DeviceRemoteCommandRequest(*from._impl_.remote_command_request_);
  }
  if (from._internal_has_device_attribute_update_permission_request()) {
    _this->_impl_.device_attribute_update_permission_request_ = new ::enterprise_management::DeviceAttributeUpdatePermissionRequest(*from._impl_.device_attribute_update_permission_request_);
  }
  if (from._internal_has_device_attribute_update_request()) {
    _this->_impl_.device_attribute_update_request_ = new ::enterprise_management::DeviceAttributeUpdateRequest(*from._impl_.device_attribute_update_request_);
  }
  if (from._internal_has_gcm_id_update_request()) {
    _this->_impl_.gcm_id_update_request_ = new ::enterprise_management::GcmIdUpdateRequest(*from._impl_.gcm_id_update_request_);
  }
  if (from._internal_has_check_android_management_request()) {
    _this->_impl_.check_android_management_request_ = new ::enterprise_management::CheckAndroidManagementRequest(*from._impl_.check_android_management_request_);
  }
  if (from._internal_has_certificate_based_register_request()) {
    _this->_impl_.certificate_based_register_request_ = new ::enterprise_management::CertificateBasedDeviceRegisterRequest(*from._impl_.certificate_based_register_request_);
  }
  if (from._internal_has_active_directory_enroll_play_user_request()) {
    _this->_impl_.active_directory_enroll_play_user_request_ = new ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest(*from._impl_.active_directory_enroll_play_user_request_);
  }
  if (from._internal_has_active_directory_play_activity_request()) {
    _this->_impl_.active_directory_play_activity_request_ = new ::enterprise_management::ActiveDirectoryPlayActivityRequest(*from._impl_.active_directory_play_activity_request_);
  }
  if (from._internal_has_check_device_license_request_deprecated()) {
    _this->_impl_.check_device_license_request_deprecated_ = new ::enterprise_management::CheckDeviceLicenseRequest(*from._impl_.check_device_license_request_deprecated_);
  }
  if (from._internal_has_active_directory_user_signin_request()) {
    _this->_impl_.active_directory_user_signin_request_ = new ::enterprise_management::ActiveDirectoryUserSigninRequest(*from._impl_.active_directory_user_signin_request_);
  }
  if (from._internal_has_register_browser_request()) {
    _this->_impl_.register_browser_request_ = new ::enterprise_management::RegisterBrowserRequest(*from._impl_.register_browser_request_);
  }
  if (from._internal_has_app_install_report_request()) {
    _this->_impl_.app_install_report_request_ = new ::enterprise_management::AppInstallReportRequest(*from._impl_.app_install_report_request_);
  }
  if (from._internal_has_chrome_desktop_report_request()) {
    _this->_impl_.chrome_desktop_report_request_ = new ::enterprise_management::ChromeDesktopReportRequest(*from._impl_.chrome_desktop_report_request_);
  }
  if (from._internal_has_policy_validation_report_request()) {
    _this->_impl_.policy_validation_report_request_ = new ::enterprise_management::PolicyValidationReportRequest(*from._impl_.policy_validation_report_request_);
  }
  if (from._internal_has_device_initial_enrollment_state_request()) {
    _this->_impl_.device_initial_enrollment_state_request_ = new ::enterprise_management::DeviceInitialEnrollmentStateRequest(*from._impl_.device_initial_enrollment_state_request_);
  }
  if (from._internal_has_refresh_account_request()) {
    _this->_impl_.refresh_account_request_ = new ::enterprise_management::RefreshAccountRequest(*from._impl_.refresh_account_request_);
  }
  if (from._internal_has_child_status_report_request()) {
    _this->_impl_.child_status_report_request_ = new ::enterprise_management::ChildStatusReportRequest(*from._impl_.child_status_report_request_);
  }
  if (from._internal_has_rsu_lookup_key_upload_request()) {
    _this->_impl_.rsu_lookup_key_upload_request_ = new ::enterprise_management::RsuLookupKeyUploadRequest(*from._impl_.rsu_lookup_key_upload_request_);
  }
  if (from._internal_has_public_saml_user_request()) {
    _this->_impl_.public_saml_user_request_ = new ::enterprise_management::PublicSamlUserRequest(*from._impl_.public_saml_user_request_);
  }
  if (from._internal_has_chrome_os_user_report_request()) {
    _this->_impl_.chrome_os_user_report_request_ = new ::enterprise_management::ChromeOsUserReportRequest(*from._impl_.chrome_os_user_report_request_);
  }
  if (from._internal_has_client_certificate_provisioning_request()) {
    _this->_impl_.client_certificate_provisioning_request_ = new ::enterprise_management::ClientCertificateProvisioningRequest(*from._impl_.client_certificate_provisioning_request_);
  }
  if (from._internal_has_extension_install_report_request()) {
    _this->_impl_.extension_install_report_request_ = new ::enterprise_management::ExtensionInstallReportRequest(*from._impl_.extension_install_report_request_);
  }
  if (from._internal_has_check_user_account_request()) {
    _this->_impl_.check_user_account_request_ = new ::enterprise_management::CheckUserAccountRequest(*from._impl_.check_user_account_request_);
  }
  if (from._internal_has_private_set_membership_request()) {
    _this->_impl_.private_set_membership_request_ = new ::enterprise_management::PrivateSetMembershipRequest(*from._impl_.private_set_membership_request_);
  }
  if (from._internal_has_browser_public_key_upload_request()) {
    _this->_impl_.browser_public_key_upload_request_ = new ::enterprise_management::BrowserPublicKeyUploadRequest(*from._impl_.browser_public_key_upload_request_);
  }
  if (from._internal_has_upload_euicc_info_request()) {
    _this->_impl_.upload_euicc_info_request_ = new ::enterprise_management::UploadEuiccInfoRequest(*from._impl_.upload_euicc_info_request_);
  }
  if (from._internal_has_chrome_profile_report_request()) {
    _this->_impl_.chrome_profile_report_request_ = new ::enterprise_management::ChromeProfileReportRequest(*from._impl_.chrome_profile_report_request_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceManagementRequest)
}

inline void DeviceManagementRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.register_request_){nullptr}
    , decltype(_impl_.unregister_request_){nullptr}
    , decltype(_impl_.policy_request_){nullptr}
    , decltype(_impl_.device_status_report_request_){nullptr}
    , decltype(_impl_.session_status_report_request_){nullptr}
    , decltype(_impl_.auto_enrollment_request_){nullptr}
    , decltype(_impl_.cert_upload_request_){nullptr}
    , decltype(_impl_.service_api_access_request_){nullptr}
    , decltype(_impl_.device_state_retrieval_request_){nullptr}
    , decltype(_impl_.device_state_key_update_request_){nullptr}
    , decltype(_impl_.device_pairing_request_){nullptr}
    , decltype(_impl_.check_device_pairing_request_){nullptr}
    , decltype(_impl_.remote_command_request_){nullptr}
    , decltype(_impl_.device_attribute_update_permission_request_){nullptr}
    , decltype(_impl_.device_attribute_update_request_){nullptr}
    , decltype(_impl_.gcm_id_update_request_){nullptr}
    , decltype(_impl_.check_android_management_request_){nullptr}
    , decltype(_impl_.certificate_based_register_request_){nullptr}
    , decltype(_impl_.active_directory_enroll_play_user_request_){nullptr}
    , decltype(_impl_.active_directory_play_activity_request_){nullptr}
    , decltype(_impl_.check_device_license_request_deprecated_){nullptr}
    , decltype(_impl_.active_directory_user_signin_request_){nullptr}
    , decltype(_impl_.register_browser_request_){nullptr}
    , decltype(_impl_.app_install_report_request_){nullptr}
    , decltype(_impl_.chrome_desktop_report_request_){nullptr}
    , decltype(_impl_.policy_validation_report_request_){nullptr}
    , decltype(_impl_.device_initial_enrollment_state_request_){nullptr}
    , decltype(_impl_.refresh_account_request_){nullptr}
    , decltype(_impl_.child_status_report_request_){nullptr}
    , decltype(_impl_.rsu_lookup_key_upload_request_){nullptr}
    , decltype(_impl_.public_saml_user_request_){nullptr}
    , decltype(_impl_.chrome_os_user_report_request_){nullptr}
    , decltype(_impl_.client_certificate_provisioning_request_){nullptr}
    , decltype(_impl_.extension_install_report_request_){nullptr}
    , decltype(_impl_.check_user_account_request_){nullptr}
    , decltype(_impl_.private_set_membership_request_){nullptr}
    , decltype(_impl_.browser_public_key_upload_request_){nullptr}
    , decltype(_impl_.upload_euicc_info_request_){nullptr}
    , decltype(_impl_.chrome_profile_report_request_){nullptr}
  };
}

DeviceManagementRequest::~DeviceManagementRequest() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceManagementRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceManagementRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.register_request_;
  if (this != internal_default_instance()) delete _impl_.unregister_request_;
  if (this != internal_default_instance()) delete _impl_.policy_request_;
  if (this != internal_default_instance()) delete _impl_.device_status_report_request_;
  if (this != internal_default_instance()) delete _impl_.session_status_report_request_;
  if (this != internal_default_instance()) delete _impl_.auto_enrollment_request_;
  if (this != internal_default_instance()) delete _impl_.cert_upload_request_;
  if (this != internal_default_instance()) delete _impl_.service_api_access_request_;
  if (this != internal_default_instance()) delete _impl_.device_state_retrieval_request_;
  if (this != internal_default_instance()) delete _impl_.device_state_key_update_request_;
  if (this != internal_default_instance()) delete _impl_.device_pairing_request_;
  if (this != internal_default_instance()) delete _impl_.check_device_pairing_request_;
  if (this != internal_default_instance()) delete _impl_.remote_command_request_;
  if (this != internal_default_instance()) delete _impl_.device_attribute_update_permission_request_;
  if (this != internal_default_instance()) delete _impl_.device_attribute_update_request_;
  if (this != internal_default_instance()) delete _impl_.gcm_id_update_request_;
  if (this != internal_default_instance()) delete _impl_.check_android_management_request_;
  if (this != internal_default_instance()) delete _impl_.certificate_based_register_request_;
  if (this != internal_default_instance()) delete _impl_.active_directory_enroll_play_user_request_;
  if (this != internal_default_instance()) delete _impl_.active_directory_play_activity_request_;
  if (this != internal_default_instance()) delete _impl_.check_device_license_request_deprecated_;
  if (this != internal_default_instance()) delete _impl_.active_directory_user_signin_request_;
  if (this != internal_default_instance()) delete _impl_.register_browser_request_;
  if (this != internal_default_instance()) delete _impl_.app_install_report_request_;
  if (this != internal_default_instance()) delete _impl_.chrome_desktop_report_request_;
  if (this != internal_default_instance()) delete _impl_.policy_validation_report_request_;
  if (this != internal_default_instance()) delete _impl_.device_initial_enrollment_state_request_;
  if (this != internal_default_instance()) delete _impl_.refresh_account_request_;
  if (this != internal_default_instance()) delete _impl_.child_status_report_request_;
  if (this != internal_default_instance()) delete _impl_.rsu_lookup_key_upload_request_;
  if (this != internal_default_instance()) delete _impl_.public_saml_user_request_;
  if (this != internal_default_instance()) delete _impl_.chrome_os_user_report_request_;
  if (this != internal_default_instance()) delete _impl_.client_certificate_provisioning_request_;
  if (this != internal_default_instance()) delete _impl_.extension_install_report_request_;
  if (this != internal_default_instance()) delete _impl_.check_user_account_request_;
  if (this != internal_default_instance()) delete _impl_.private_set_membership_request_;
  if (this != internal_default_instance()) delete _impl_.browser_public_key_upload_request_;
  if (this != internal_default_instance()) delete _impl_.upload_euicc_info_request_;
  if (this != internal_default_instance()) delete _impl_.chrome_profile_report_request_;
}

void DeviceManagementRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceManagementRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceManagementRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.register_request_ != nullptr);
      _impl_.register_request_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.unregister_request_ != nullptr);
      _impl_.unregister_request_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.policy_request_ != nullptr);
      _impl_.policy_request_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.device_status_report_request_ != nullptr);
      _impl_.device_status_report_request_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.session_status_report_request_ != nullptr);
      _impl_.session_status_report_request_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.auto_enrollment_request_ != nullptr);
      _impl_.auto_enrollment_request_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.cert_upload_request_ != nullptr);
      _impl_.cert_upload_request_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.service_api_access_request_ != nullptr);
      _impl_.service_api_access_request_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.device_state_retrieval_request_ != nullptr);
      _impl_.device_state_retrieval_request_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.device_state_key_update_request_ != nullptr);
      _impl_.device_state_key_update_request_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.device_pairing_request_ != nullptr);
      _impl_.device_pairing_request_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.check_device_pairing_request_ != nullptr);
      _impl_.check_device_pairing_request_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.remote_command_request_ != nullptr);
      _impl_.remote_command_request_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.device_attribute_update_permission_request_ != nullptr);
      _impl_.device_attribute_update_permission_request_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.device_attribute_update_request_ != nullptr);
      _impl_.device_attribute_update_request_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(_impl_.gcm_id_update_request_ != nullptr);
      _impl_.gcm_id_update_request_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(_impl_.check_android_management_request_ != nullptr);
      _impl_.check_android_management_request_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(_impl_.certificate_based_register_request_ != nullptr);
      _impl_.certificate_based_register_request_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(_impl_.active_directory_enroll_play_user_request_ != nullptr);
      _impl_.active_directory_enroll_play_user_request_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(_impl_.active_directory_play_activity_request_ != nullptr);
      _impl_.active_directory_play_activity_request_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(_impl_.check_device_license_request_deprecated_ != nullptr);
      _impl_.check_device_license_request_deprecated_->Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      GOOGLE_DCHECK(_impl_.active_directory_user_signin_request_ != nullptr);
      _impl_.active_directory_user_signin_request_->Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      GOOGLE_DCHECK(_impl_.register_browser_request_ != nullptr);
      _impl_.register_browser_request_->Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      GOOGLE_DCHECK(_impl_.app_install_report_request_ != nullptr);
      _impl_.app_install_report_request_->Clear();
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      GOOGLE_DCHECK(_impl_.chrome_desktop_report_request_ != nullptr);
      _impl_.chrome_desktop_report_request_->Clear();
    }
    if (cached_has_bits & 0x02000000u) {
      GOOGLE_DCHECK(_impl_.policy_validation_report_request_ != nullptr);
      _impl_.policy_validation_report_request_->Clear();
    }
    if (cached_has_bits & 0x04000000u) {
      GOOGLE_DCHECK(_impl_.device_initial_enrollment_state_request_ != nullptr);
      _impl_.device_initial_enrollment_state_request_->Clear();
    }
    if (cached_has_bits & 0x08000000u) {
      GOOGLE_DCHECK(_impl_.refresh_account_request_ != nullptr);
      _impl_.refresh_account_request_->Clear();
    }
    if (cached_has_bits & 0x10000000u) {
      GOOGLE_DCHECK(_impl_.child_status_report_request_ != nullptr);
      _impl_.child_status_report_request_->Clear();
    }
    if (cached_has_bits & 0x20000000u) {
      GOOGLE_DCHECK(_impl_.rsu_lookup_key_upload_request_ != nullptr);
      _impl_.rsu_lookup_key_upload_request_->Clear();
    }
    if (cached_has_bits & 0x40000000u) {
      GOOGLE_DCHECK(_impl_.public_saml_user_request_ != nullptr);
      _impl_.public_saml_user_request_->Clear();
    }
    if (cached_has_bits & 0x80000000u) {
      GOOGLE_DCHECK(_impl_.chrome_os_user_report_request_ != nullptr);
      _impl_.chrome_os_user_report_request_->Clear();
    }
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.client_certificate_provisioning_request_ != nullptr);
      _impl_.client_certificate_provisioning_request_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.extension_install_report_request_ != nullptr);
      _impl_.extension_install_report_request_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.check_user_account_request_ != nullptr);
      _impl_.check_user_account_request_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.private_set_membership_request_ != nullptr);
      _impl_.private_set_membership_request_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.browser_public_key_upload_request_ != nullptr);
      _impl_.browser_public_key_upload_request_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.upload_euicc_info_request_ != nullptr);
      _impl_.upload_euicc_info_request_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.chrome_profile_report_request_ != nullptr);
      _impl_.chrome_profile_report_request_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceManagementRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_management.DeviceRegisterRequest register_request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_register_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceUnregisterRequest unregister_request = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_unregister_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DevicePolicyRequest policy_request = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_policy_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceStatusReportRequest device_status_report_request = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_status_report_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.SessionStatusReportRequest session_status_report_request = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_session_status_report_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceAutoEnrollmentRequest auto_enrollment_request = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_auto_enrollment_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceCertUploadRequest cert_upload_request = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_cert_upload_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceServiceApiAccessRequest service_api_access_request = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_service_api_access_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceStateRetrievalRequest device_state_retrieval_request = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_state_retrieval_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceStateKeyUpdateRequest device_state_key_update_request = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_state_key_update_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DevicePairingRequest device_pairing_request = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_pairing_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.CheckDevicePairingRequest check_device_pairing_request = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_check_device_pairing_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceRemoteCommandRequest remote_command_request = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_remote_command_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceAttributeUpdatePermissionRequest device_attribute_update_permission_request = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_attribute_update_permission_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceAttributeUpdateRequest device_attribute_update_request = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_attribute_update_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.GcmIdUpdateRequest gcm_id_update_request = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_gcm_id_update_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.CheckAndroidManagementRequest check_android_management_request = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_check_android_management_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.CertificateBasedDeviceRegisterRequest certificate_based_register_request = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_certificate_based_register_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ActiveDirectoryEnrollPlayUserRequest active_directory_enroll_play_user_request = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_active_directory_enroll_play_user_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ActiveDirectoryPlayActivityRequest active_directory_play_activity_request = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_active_directory_play_activity_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.CheckDeviceLicenseRequest check_device_license_request_deprecated = 21 [deprecated = true];
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_check_device_license_request_deprecated(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ActiveDirectoryUserSigninRequest active_directory_user_signin_request = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_active_directory_user_signin_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.RegisterBrowserRequest register_browser_request = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_register_browser_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AppInstallReportRequest app_install_report_request = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_app_install_report_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ChromeDesktopReportRequest chrome_desktop_report_request = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_chrome_desktop_report_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyValidationReportRequest policy_validation_report_request = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_policy_validation_report_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceInitialEnrollmentStateRequest device_initial_enrollment_state_request = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_initial_enrollment_state_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.RefreshAccountRequest refresh_account_request = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_refresh_account_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ChildStatusReportRequest child_status_report_request = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_child_status_report_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.RsuLookupKeyUploadRequest rsu_lookup_key_upload_request = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_rsu_lookup_key_upload_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PublicSamlUserRequest public_saml_user_request = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_public_saml_user_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ChromeOsUserReportRequest chrome_os_user_report_request = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_chrome_os_user_report_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ClientCertificateProvisioningRequest client_certificate_provisioning_request = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_certificate_provisioning_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ExtensionInstallReportRequest extension_install_report_request = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_extension_install_report_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.CheckUserAccountRequest check_user_account_request = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_check_user_account_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PrivateSetMembershipRequest private_set_membership_request = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_private_set_membership_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BrowserPublicKeyUploadRequest browser_public_key_upload_request = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_browser_public_key_upload_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.UploadEuiccInfoRequest upload_euicc_info_request = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_upload_euicc_info_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ChromeProfileReportRequest chrome_profile_report_request = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_chrome_profile_report_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceManagementRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceManagementRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .enterprise_management.DeviceRegisterRequest register_request = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::register_request(this),
        _Internal::register_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceUnregisterRequest unregister_request = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::unregister_request(this),
        _Internal::unregister_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DevicePolicyRequest policy_request = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::policy_request(this),
        _Internal::policy_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceStatusReportRequest device_status_report_request = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::device_status_report_request(this),
        _Internal::device_status_report_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.SessionStatusReportRequest session_status_report_request = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::session_status_report_request(this),
        _Internal::session_status_report_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceAutoEnrollmentRequest auto_enrollment_request = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::auto_enrollment_request(this),
        _Internal::auto_enrollment_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceCertUploadRequest cert_upload_request = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::cert_upload_request(this),
        _Internal::cert_upload_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceServiceApiAccessRequest service_api_access_request = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::service_api_access_request(this),
        _Internal::service_api_access_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceStateRetrievalRequest device_state_retrieval_request = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::device_state_retrieval_request(this),
        _Internal::device_state_retrieval_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceStateKeyUpdateRequest device_state_key_update_request = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::device_state_key_update_request(this),
        _Internal::device_state_key_update_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DevicePairingRequest device_pairing_request = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::device_pairing_request(this),
        _Internal::device_pairing_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.CheckDevicePairingRequest check_device_pairing_request = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::check_device_pairing_request(this),
        _Internal::check_device_pairing_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceRemoteCommandRequest remote_command_request = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::remote_command_request(this),
        _Internal::remote_command_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceAttributeUpdatePermissionRequest device_attribute_update_permission_request = 14;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::device_attribute_update_permission_request(this),
        _Internal::device_attribute_update_permission_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceAttributeUpdateRequest device_attribute_update_request = 15;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::device_attribute_update_request(this),
        _Internal::device_attribute_update_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.GcmIdUpdateRequest gcm_id_update_request = 16;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::gcm_id_update_request(this),
        _Internal::gcm_id_update_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.CheckAndroidManagementRequest check_android_management_request = 17;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::check_android_management_request(this),
        _Internal::check_android_management_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.CertificateBasedDeviceRegisterRequest certificate_based_register_request = 18;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::certificate_based_register_request(this),
        _Internal::certificate_based_register_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ActiveDirectoryEnrollPlayUserRequest active_directory_enroll_play_user_request = 19;
  if (cached_has_bits & 0x00040000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::active_directory_enroll_play_user_request(this),
        _Internal::active_directory_enroll_play_user_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ActiveDirectoryPlayActivityRequest active_directory_play_activity_request = 20;
  if (cached_has_bits & 0x00080000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::active_directory_play_activity_request(this),
        _Internal::active_directory_play_activity_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.CheckDeviceLicenseRequest check_device_license_request_deprecated = 21 [deprecated = true];
  if (cached_has_bits & 0x00100000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::check_device_license_request_deprecated(this),
        _Internal::check_device_license_request_deprecated(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ActiveDirectoryUserSigninRequest active_directory_user_signin_request = 22;
  if (cached_has_bits & 0x00200000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::active_directory_user_signin_request(this),
        _Internal::active_directory_user_signin_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.RegisterBrowserRequest register_browser_request = 23;
  if (cached_has_bits & 0x00400000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::register_browser_request(this),
        _Internal::register_browser_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.AppInstallReportRequest app_install_report_request = 25;
  if (cached_has_bits & 0x00800000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::app_install_report_request(this),
        _Internal::app_install_report_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ChromeDesktopReportRequest chrome_desktop_report_request = 26;
  if (cached_has_bits & 0x01000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(26, _Internal::chrome_desktop_report_request(this),
        _Internal::chrome_desktop_report_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.PolicyValidationReportRequest policy_validation_report_request = 27;
  if (cached_has_bits & 0x02000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(27, _Internal::policy_validation_report_request(this),
        _Internal::policy_validation_report_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceInitialEnrollmentStateRequest device_initial_enrollment_state_request = 28;
  if (cached_has_bits & 0x04000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(28, _Internal::device_initial_enrollment_state_request(this),
        _Internal::device_initial_enrollment_state_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.RefreshAccountRequest refresh_account_request = 29;
  if (cached_has_bits & 0x08000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(29, _Internal::refresh_account_request(this),
        _Internal::refresh_account_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ChildStatusReportRequest child_status_report_request = 30;
  if (cached_has_bits & 0x10000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(30, _Internal::child_status_report_request(this),
        _Internal::child_status_report_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.RsuLookupKeyUploadRequest rsu_lookup_key_upload_request = 31;
  if (cached_has_bits & 0x20000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(31, _Internal::rsu_lookup_key_upload_request(this),
        _Internal::rsu_lookup_key_upload_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.PublicSamlUserRequest public_saml_user_request = 32;
  if (cached_has_bits & 0x40000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(32, _Internal::public_saml_user_request(this),
        _Internal::public_saml_user_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ChromeOsUserReportRequest chrome_os_user_report_request = 33;
  if (cached_has_bits & 0x80000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(33, _Internal::chrome_os_user_report_request(this),
        _Internal::chrome_os_user_report_request(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional .enterprise_management.ClientCertificateProvisioningRequest client_certificate_provisioning_request = 34;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(34, _Internal::client_certificate_provisioning_request(this),
        _Internal::client_certificate_provisioning_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ExtensionInstallReportRequest extension_install_report_request = 35;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(35, _Internal::extension_install_report_request(this),
        _Internal::extension_install_report_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.CheckUserAccountRequest check_user_account_request = 36;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(36, _Internal::check_user_account_request(this),
        _Internal::check_user_account_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.PrivateSetMembershipRequest private_set_membership_request = 37;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(37, _Internal::private_set_membership_request(this),
        _Internal::private_set_membership_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.BrowserPublicKeyUploadRequest browser_public_key_upload_request = 38;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(38, _Internal::browser_public_key_upload_request(this),
        _Internal::browser_public_key_upload_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.UploadEuiccInfoRequest upload_euicc_info_request = 39;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(39, _Internal::upload_euicc_info_request(this),
        _Internal::upload_euicc_info_request(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ChromeProfileReportRequest chrome_profile_report_request = 40;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(40, _Internal::chrome_profile_report_request(this),
        _Internal::chrome_profile_report_request(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceManagementRequest)
  return target;
}

size_t DeviceManagementRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceManagementRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .enterprise_management.DeviceRegisterRequest register_request = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.register_request_);
    }

    // optional .enterprise_management.DeviceUnregisterRequest unregister_request = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.unregister_request_);
    }

    // optional .enterprise_management.DevicePolicyRequest policy_request = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.policy_request_);
    }

    // optional .enterprise_management.DeviceStatusReportRequest device_status_report_request = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_status_report_request_);
    }

    // optional .enterprise_management.SessionStatusReportRequest session_status_report_request = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.session_status_report_request_);
    }

    // optional .enterprise_management.DeviceAutoEnrollmentRequest auto_enrollment_request = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.auto_enrollment_request_);
    }

    // optional .enterprise_management.DeviceCertUploadRequest cert_upload_request = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cert_upload_request_);
    }

    // optional .enterprise_management.DeviceServiceApiAccessRequest service_api_access_request = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.service_api_access_request_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .enterprise_management.DeviceStateRetrievalRequest device_state_retrieval_request = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_state_retrieval_request_);
    }

    // optional .enterprise_management.DeviceStateKeyUpdateRequest device_state_key_update_request = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_state_key_update_request_);
    }

    // optional .enterprise_management.DevicePairingRequest device_pairing_request = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_pairing_request_);
    }

    // optional .enterprise_management.CheckDevicePairingRequest check_device_pairing_request = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.check_device_pairing_request_);
    }

    // optional .enterprise_management.DeviceRemoteCommandRequest remote_command_request = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.remote_command_request_);
    }

    // optional .enterprise_management.DeviceAttributeUpdatePermissionRequest device_attribute_update_permission_request = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_attribute_update_permission_request_);
    }

    // optional .enterprise_management.DeviceAttributeUpdateRequest device_attribute_update_request = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_attribute_update_request_);
    }

    // optional .enterprise_management.GcmIdUpdateRequest gcm_id_update_request = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.gcm_id_update_request_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .enterprise_management.CheckAndroidManagementRequest check_android_management_request = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.check_android_management_request_);
    }

    // optional .enterprise_management.CertificateBasedDeviceRegisterRequest certificate_based_register_request = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.certificate_based_register_request_);
    }

    // optional .enterprise_management.ActiveDirectoryEnrollPlayUserRequest active_directory_enroll_play_user_request = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.active_directory_enroll_play_user_request_);
    }

    // optional .enterprise_management.ActiveDirectoryPlayActivityRequest active_directory_play_activity_request = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.active_directory_play_activity_request_);
    }

    // optional .enterprise_management.CheckDeviceLicenseRequest check_device_license_request_deprecated = 21 [deprecated = true];
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.check_device_license_request_deprecated_);
    }

    // optional .enterprise_management.ActiveDirectoryUserSigninRequest active_directory_user_signin_request = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.active_directory_user_signin_request_);
    }

    // optional .enterprise_management.RegisterBrowserRequest register_browser_request = 23;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.register_browser_request_);
    }

    // optional .enterprise_management.AppInstallReportRequest app_install_report_request = 25;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.app_install_report_request_);
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional .enterprise_management.ChromeDesktopReportRequest chrome_desktop_report_request = 26;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chrome_desktop_report_request_);
    }

    // optional .enterprise_management.PolicyValidationReportRequest policy_validation_report_request = 27;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.policy_validation_report_request_);
    }

    // optional .enterprise_management.DeviceInitialEnrollmentStateRequest device_initial_enrollment_state_request = 28;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_initial_enrollment_state_request_);
    }

    // optional .enterprise_management.RefreshAccountRequest refresh_account_request = 29;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.refresh_account_request_);
    }

    // optional .enterprise_management.ChildStatusReportRequest child_status_report_request = 30;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.child_status_report_request_);
    }

    // optional .enterprise_management.RsuLookupKeyUploadRequest rsu_lookup_key_upload_request = 31;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rsu_lookup_key_upload_request_);
    }

    // optional .enterprise_management.PublicSamlUserRequest public_saml_user_request = 32;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.public_saml_user_request_);
    }

    // optional .enterprise_management.ChromeOsUserReportRequest chrome_os_user_report_request = 33;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chrome_os_user_report_request_);
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x0000007fu) {
    // optional .enterprise_management.ClientCertificateProvisioningRequest client_certificate_provisioning_request = 34;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.client_certificate_provisioning_request_);
    }

    // optional .enterprise_management.ExtensionInstallReportRequest extension_install_report_request = 35;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.extension_install_report_request_);
    }

    // optional .enterprise_management.CheckUserAccountRequest check_user_account_request = 36;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.check_user_account_request_);
    }

    // optional .enterprise_management.PrivateSetMembershipRequest private_set_membership_request = 37;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.private_set_membership_request_);
    }

    // optional .enterprise_management.BrowserPublicKeyUploadRequest browser_public_key_upload_request = 38;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.browser_public_key_upload_request_);
    }

    // optional .enterprise_management.UploadEuiccInfoRequest upload_euicc_info_request = 39;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.upload_euicc_info_request_);
    }

    // optional .enterprise_management.ChromeProfileReportRequest chrome_profile_report_request = 40;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chrome_profile_report_request_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceManagementRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceManagementRequest*>(
      &from));
}

void DeviceManagementRequest::MergeFrom(const DeviceManagementRequest& from) {
  DeviceManagementRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceManagementRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_register_request()->::enterprise_management::DeviceRegisterRequest::MergeFrom(
          from._internal_register_request());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_unregister_request()->::enterprise_management::DeviceUnregisterRequest::MergeFrom(
          from._internal_unregister_request());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_policy_request()->::enterprise_management::DevicePolicyRequest::MergeFrom(
          from._internal_policy_request());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_device_status_report_request()->::enterprise_management::DeviceStatusReportRequest::MergeFrom(
          from._internal_device_status_report_request());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_session_status_report_request()->::enterprise_management::SessionStatusReportRequest::MergeFrom(
          from._internal_session_status_report_request());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_auto_enrollment_request()->::enterprise_management::DeviceAutoEnrollmentRequest::MergeFrom(
          from._internal_auto_enrollment_request());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_cert_upload_request()->::enterprise_management::DeviceCertUploadRequest::MergeFrom(
          from._internal_cert_upload_request());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_service_api_access_request()->::enterprise_management::DeviceServiceApiAccessRequest::MergeFrom(
          from._internal_service_api_access_request());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_device_state_retrieval_request()->::enterprise_management::DeviceStateRetrievalRequest::MergeFrom(
          from._internal_device_state_retrieval_request());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_device_state_key_update_request()->::enterprise_management::DeviceStateKeyUpdateRequest::MergeFrom(
          from._internal_device_state_key_update_request());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_device_pairing_request()->::enterprise_management::DevicePairingRequest::MergeFrom(
          from._internal_device_pairing_request());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_check_device_pairing_request()->::enterprise_management::CheckDevicePairingRequest::MergeFrom(
          from._internal_check_device_pairing_request());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_remote_command_request()->::enterprise_management::DeviceRemoteCommandRequest::MergeFrom(
          from._internal_remote_command_request());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_device_attribute_update_permission_request()->::enterprise_management::DeviceAttributeUpdatePermissionRequest::MergeFrom(
          from._internal_device_attribute_update_permission_request());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_device_attribute_update_request()->::enterprise_management::DeviceAttributeUpdateRequest::MergeFrom(
          from._internal_device_attribute_update_request());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_gcm_id_update_request()->::enterprise_management::GcmIdUpdateRequest::MergeFrom(
          from._internal_gcm_id_update_request());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_internal_mutable_check_android_management_request()->::enterprise_management::CheckAndroidManagementRequest::MergeFrom(
          from._internal_check_android_management_request());
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_internal_mutable_certificate_based_register_request()->::enterprise_management::CertificateBasedDeviceRegisterRequest::MergeFrom(
          from._internal_certificate_based_register_request());
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_internal_mutable_active_directory_enroll_play_user_request()->::enterprise_management::ActiveDirectoryEnrollPlayUserRequest::MergeFrom(
          from._internal_active_directory_enroll_play_user_request());
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_internal_mutable_active_directory_play_activity_request()->::enterprise_management::ActiveDirectoryPlayActivityRequest::MergeFrom(
          from._internal_active_directory_play_activity_request());
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_internal_mutable_check_device_license_request_deprecated()->::enterprise_management::CheckDeviceLicenseRequest::MergeFrom(
          from._internal_check_device_license_request_deprecated());
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_internal_mutable_active_directory_user_signin_request()->::enterprise_management::ActiveDirectoryUserSigninRequest::MergeFrom(
          from._internal_active_directory_user_signin_request());
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_internal_mutable_register_browser_request()->::enterprise_management::RegisterBrowserRequest::MergeFrom(
          from._internal_register_browser_request());
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_internal_mutable_app_install_report_request()->::enterprise_management::AppInstallReportRequest::MergeFrom(
          from._internal_app_install_report_request());
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_internal_mutable_chrome_desktop_report_request()->::enterprise_management::ChromeDesktopReportRequest::MergeFrom(
          from._internal_chrome_desktop_report_request());
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_internal_mutable_policy_validation_report_request()->::enterprise_management::PolicyValidationReportRequest::MergeFrom(
          from._internal_policy_validation_report_request());
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_internal_mutable_device_initial_enrollment_state_request()->::enterprise_management::DeviceInitialEnrollmentStateRequest::MergeFrom(
          from._internal_device_initial_enrollment_state_request());
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_internal_mutable_refresh_account_request()->::enterprise_management::RefreshAccountRequest::MergeFrom(
          from._internal_refresh_account_request());
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_internal_mutable_child_status_report_request()->::enterprise_management::ChildStatusReportRequest::MergeFrom(
          from._internal_child_status_report_request());
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_internal_mutable_rsu_lookup_key_upload_request()->::enterprise_management::RsuLookupKeyUploadRequest::MergeFrom(
          from._internal_rsu_lookup_key_upload_request());
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_internal_mutable_public_saml_user_request()->::enterprise_management::PublicSamlUserRequest::MergeFrom(
          from._internal_public_saml_user_request());
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_internal_mutable_chrome_os_user_report_request()->::enterprise_management::ChromeOsUserReportRequest::MergeFrom(
          from._internal_chrome_os_user_report_request());
    }
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_client_certificate_provisioning_request()->::enterprise_management::ClientCertificateProvisioningRequest::MergeFrom(
          from._internal_client_certificate_provisioning_request());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_extension_install_report_request()->::enterprise_management::ExtensionInstallReportRequest::MergeFrom(
          from._internal_extension_install_report_request());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_check_user_account_request()->::enterprise_management::CheckUserAccountRequest::MergeFrom(
          from._internal_check_user_account_request());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_private_set_membership_request()->::enterprise_management::PrivateSetMembershipRequest::MergeFrom(
          from._internal_private_set_membership_request());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_browser_public_key_upload_request()->::enterprise_management::BrowserPublicKeyUploadRequest::MergeFrom(
          from._internal_browser_public_key_upload_request());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_upload_euicc_info_request()->::enterprise_management::UploadEuiccInfoRequest::MergeFrom(
          from._internal_upload_euicc_info_request());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_chrome_profile_report_request()->::enterprise_management::ChromeProfileReportRequest::MergeFrom(
          from._internal_chrome_profile_report_request());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceManagementRequest::CopyFrom(const DeviceManagementRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceManagementRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceManagementRequest::IsInitialized() const {
  if (_internal_has_device_status_report_request()) {
    if (!_impl_.device_status_report_request_->IsInitialized()) return false;
  }
  return true;
}

void DeviceManagementRequest::InternalSwap(DeviceManagementRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceManagementRequest, _impl_.chrome_profile_report_request_)
      + sizeof(DeviceManagementRequest::_impl_.chrome_profile_report_request_)
      - PROTOBUF_FIELD_OFFSET(DeviceManagementRequest, _impl_.register_request_)>(
          reinterpret_cast<char*>(&_impl_.register_request_),
          reinterpret_cast<char*>(&other->_impl_.register_request_));
}

std::string DeviceManagementRequest::GetTypeName() const {
  return "enterprise_management.DeviceManagementRequest";
}


// ===================================================================

class DeviceManagementResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceManagementResponse>()._impl_._has_bits_);
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::enterprise_management::DeviceRegisterResponse& register_response(const DeviceManagementResponse* msg);
  static void set_has_register_response(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::enterprise_management::DeviceUnregisterResponse& unregister_response(const DeviceManagementResponse* msg);
  static void set_has_unregister_response(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::enterprise_management::DevicePolicyResponse& policy_response(const DeviceManagementResponse* msg);
  static void set_has_policy_response(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::enterprise_management::DeviceStatusReportResponse& device_status_report_response(const DeviceManagementResponse* msg);
  static void set_has_device_status_report_response(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::enterprise_management::SessionStatusReportResponse& session_status_report_response(const DeviceManagementResponse* msg);
  static void set_has_session_status_report_response(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::enterprise_management::ChildStatusReportResponse& child_status_report_response(const DeviceManagementResponse* msg);
  static void set_has_child_status_report_response(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static const ::enterprise_management::DeviceAutoEnrollmentResponse& auto_enrollment_response(const DeviceManagementResponse* msg);
  static void set_has_auto_enrollment_response(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::enterprise_management::DeviceCertUploadResponse& cert_upload_response(const DeviceManagementResponse* msg);
  static void set_has_cert_upload_response(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::enterprise_management::DeviceServiceApiAccessResponse& service_api_access_response(const DeviceManagementResponse* msg);
  static void set_has_service_api_access_response(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::enterprise_management::DeviceStateRetrievalResponse& device_state_retrieval_response(const DeviceManagementResponse* msg);
  static void set_has_device_state_retrieval_response(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::enterprise_management::DevicePairingResponse& device_pairing_response(const DeviceManagementResponse* msg);
  static void set_has_device_pairing_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::enterprise_management::CheckDevicePairingResponse& check_device_pairing_response(const DeviceManagementResponse* msg);
  static void set_has_check_device_pairing_response(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::enterprise_management::DeviceRemoteCommandResponse& remote_command_response(const DeviceManagementResponse* msg);
  static void set_has_remote_command_response(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::enterprise_management::DeviceAttributeUpdatePermissionResponse& device_attribute_update_permission_response(const DeviceManagementResponse* msg);
  static void set_has_device_attribute_update_permission_response(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::enterprise_management::DeviceAttributeUpdateResponse& device_attribute_update_response(const DeviceManagementResponse* msg);
  static void set_has_device_attribute_update_response(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::enterprise_management::GcmIdUpdateResponse& gcm_id_update_response(const DeviceManagementResponse* msg);
  static void set_has_gcm_id_update_response(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::enterprise_management::CheckAndroidManagementResponse& check_android_management_response(const DeviceManagementResponse* msg);
  static void set_has_check_android_management_response(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse& active_directory_enroll_play_user_response(const DeviceManagementResponse* msg);
  static void set_has_active_directory_enroll_play_user_response(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::enterprise_management::ActiveDirectoryPlayActivityResponse& active_directory_play_activity_response(const DeviceManagementResponse* msg);
  static void set_has_active_directory_play_activity_response(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::enterprise_management::CheckDeviceLicenseResponse& check_device_license_response_deprecated(const DeviceManagementResponse* msg);
  static void set_has_check_device_license_response_deprecated(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::enterprise_management::ActiveDirectoryUserSigninResponse& active_directory_user_signin_response(const DeviceManagementResponse* msg);
  static void set_has_active_directory_user_signin_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::enterprise_management::ChromeDesktopReportResponse& chrome_desktop_report_response(const DeviceManagementResponse* msg);
  static void set_has_chrome_desktop_report_response(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::enterprise_management::AppInstallReportResponse& app_install_report_response(const DeviceManagementResponse* msg);
  static void set_has_app_install_report_response(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static const ::enterprise_management::PolicyValidationReportResponse& policy_validation_report_response(const DeviceManagementResponse* msg);
  static void set_has_policy_validation_report_response(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static const ::enterprise_management::DeviceInitialEnrollmentStateResponse& device_initial_enrollment_state_response(const DeviceManagementResponse* msg);
  static void set_has_device_initial_enrollment_state_response(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static const ::enterprise_management::RefreshAccountResponse& refresh_account_response(const DeviceManagementResponse* msg);
  static void set_has_refresh_account_response(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static const ::enterprise_management::RsuLookupKeyUploadResponse& rsu_lookup_key_upload_response(const DeviceManagementResponse* msg);
  static void set_has_rsu_lookup_key_upload_response(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static const ::enterprise_management::PublicSamlUserResponse& public_saml_user_response(const DeviceManagementResponse* msg);
  static void set_has_public_saml_user_response(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static const ::enterprise_management::ChromeOsUserReportResponse& chrome_os_user_report_response(const DeviceManagementResponse* msg);
  static void set_has_chrome_os_user_report_response(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static const ::enterprise_management::ClientCertificateProvisioningResponse& client_certificate_provisioning_response(const DeviceManagementResponse* msg);
  static void set_has_client_certificate_provisioning_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static const ::enterprise_management::CheckUserAccountResponse& check_user_account_response(const DeviceManagementResponse* msg);
  static void set_has_check_user_account_response(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static const ::enterprise_management::PrivateSetMembershipResponse& private_set_membership_response(const DeviceManagementResponse* msg);
  static void set_has_private_set_membership_response(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static const ::enterprise_management::BrowserPublicKeyUploadResponse& browser_public_key_upload_response(const DeviceManagementResponse* msg);
  static void set_has_browser_public_key_upload_response(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static const ::enterprise_management::UploadEuiccInfoResponse& upload_euicc_info_response(const DeviceManagementResponse* msg);
  static void set_has_upload_euicc_info_response(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static const ::enterprise_management::ChromeProfileReportResponse& chrome_profile_report_response(const DeviceManagementResponse* msg);
  static void set_has_chrome_profile_report_response(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
};

const ::enterprise_management::DeviceRegisterResponse&
DeviceManagementResponse::_Internal::register_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.register_response_;
}
const ::enterprise_management::DeviceUnregisterResponse&
DeviceManagementResponse::_Internal::unregister_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.unregister_response_;
}
const ::enterprise_management::DevicePolicyResponse&
DeviceManagementResponse::_Internal::policy_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.policy_response_;
}
const ::enterprise_management::DeviceStatusReportResponse&
DeviceManagementResponse::_Internal::device_status_report_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.device_status_report_response_;
}
const ::enterprise_management::SessionStatusReportResponse&
DeviceManagementResponse::_Internal::session_status_report_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.session_status_report_response_;
}
const ::enterprise_management::ChildStatusReportResponse&
DeviceManagementResponse::_Internal::child_status_report_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.child_status_report_response_;
}
const ::enterprise_management::DeviceAutoEnrollmentResponse&
DeviceManagementResponse::_Internal::auto_enrollment_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.auto_enrollment_response_;
}
const ::enterprise_management::DeviceCertUploadResponse&
DeviceManagementResponse::_Internal::cert_upload_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.cert_upload_response_;
}
const ::enterprise_management::DeviceServiceApiAccessResponse&
DeviceManagementResponse::_Internal::service_api_access_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.service_api_access_response_;
}
const ::enterprise_management::DeviceStateRetrievalResponse&
DeviceManagementResponse::_Internal::device_state_retrieval_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.device_state_retrieval_response_;
}
const ::enterprise_management::DevicePairingResponse&
DeviceManagementResponse::_Internal::device_pairing_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.device_pairing_response_;
}
const ::enterprise_management::CheckDevicePairingResponse&
DeviceManagementResponse::_Internal::check_device_pairing_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.check_device_pairing_response_;
}
const ::enterprise_management::DeviceRemoteCommandResponse&
DeviceManagementResponse::_Internal::remote_command_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.remote_command_response_;
}
const ::enterprise_management::DeviceAttributeUpdatePermissionResponse&
DeviceManagementResponse::_Internal::device_attribute_update_permission_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.device_attribute_update_permission_response_;
}
const ::enterprise_management::DeviceAttributeUpdateResponse&
DeviceManagementResponse::_Internal::device_attribute_update_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.device_attribute_update_response_;
}
const ::enterprise_management::GcmIdUpdateResponse&
DeviceManagementResponse::_Internal::gcm_id_update_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.gcm_id_update_response_;
}
const ::enterprise_management::CheckAndroidManagementResponse&
DeviceManagementResponse::_Internal::check_android_management_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.check_android_management_response_;
}
const ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse&
DeviceManagementResponse::_Internal::active_directory_enroll_play_user_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.active_directory_enroll_play_user_response_;
}
const ::enterprise_management::ActiveDirectoryPlayActivityResponse&
DeviceManagementResponse::_Internal::active_directory_play_activity_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.active_directory_play_activity_response_;
}
const ::enterprise_management::CheckDeviceLicenseResponse&
DeviceManagementResponse::_Internal::check_device_license_response_deprecated(const DeviceManagementResponse* msg) {
  return *msg->_impl_.check_device_license_response_deprecated_;
}
const ::enterprise_management::ActiveDirectoryUserSigninResponse&
DeviceManagementResponse::_Internal::active_directory_user_signin_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.active_directory_user_signin_response_;
}
const ::enterprise_management::ChromeDesktopReportResponse&
DeviceManagementResponse::_Internal::chrome_desktop_report_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.chrome_desktop_report_response_;
}
const ::enterprise_management::AppInstallReportResponse&
DeviceManagementResponse::_Internal::app_install_report_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.app_install_report_response_;
}
const ::enterprise_management::PolicyValidationReportResponse&
DeviceManagementResponse::_Internal::policy_validation_report_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.policy_validation_report_response_;
}
const ::enterprise_management::DeviceInitialEnrollmentStateResponse&
DeviceManagementResponse::_Internal::device_initial_enrollment_state_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.device_initial_enrollment_state_response_;
}
const ::enterprise_management::RefreshAccountResponse&
DeviceManagementResponse::_Internal::refresh_account_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.refresh_account_response_;
}
const ::enterprise_management::RsuLookupKeyUploadResponse&
DeviceManagementResponse::_Internal::rsu_lookup_key_upload_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.rsu_lookup_key_upload_response_;
}
const ::enterprise_management::PublicSamlUserResponse&
DeviceManagementResponse::_Internal::public_saml_user_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.public_saml_user_response_;
}
const ::enterprise_management::ChromeOsUserReportResponse&
DeviceManagementResponse::_Internal::chrome_os_user_report_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.chrome_os_user_report_response_;
}
const ::enterprise_management::ClientCertificateProvisioningResponse&
DeviceManagementResponse::_Internal::client_certificate_provisioning_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.client_certificate_provisioning_response_;
}
const ::enterprise_management::CheckUserAccountResponse&
DeviceManagementResponse::_Internal::check_user_account_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.check_user_account_response_;
}
const ::enterprise_management::PrivateSetMembershipResponse&
DeviceManagementResponse::_Internal::private_set_membership_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.private_set_membership_response_;
}
const ::enterprise_management::BrowserPublicKeyUploadResponse&
DeviceManagementResponse::_Internal::browser_public_key_upload_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.browser_public_key_upload_response_;
}
const ::enterprise_management::UploadEuiccInfoResponse&
DeviceManagementResponse::_Internal::upload_euicc_info_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.upload_euicc_info_response_;
}
const ::enterprise_management::ChromeProfileReportResponse&
DeviceManagementResponse::_Internal::chrome_profile_report_response(const DeviceManagementResponse* msg) {
  return *msg->_impl_.chrome_profile_report_response_;
}
DeviceManagementResponse::DeviceManagementResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceManagementResponse)
}
DeviceManagementResponse::DeviceManagementResponse(const DeviceManagementResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceManagementResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_detail_){from._impl_.error_detail_}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.register_response_){nullptr}
    , decltype(_impl_.unregister_response_){nullptr}
    , decltype(_impl_.policy_response_){nullptr}
    , decltype(_impl_.device_status_report_response_){nullptr}
    , decltype(_impl_.session_status_report_response_){nullptr}
    , decltype(_impl_.auto_enrollment_response_){nullptr}
    , decltype(_impl_.cert_upload_response_){nullptr}
    , decltype(_impl_.service_api_access_response_){nullptr}
    , decltype(_impl_.device_state_retrieval_response_){nullptr}
    , decltype(_impl_.device_pairing_response_){nullptr}
    , decltype(_impl_.check_device_pairing_response_){nullptr}
    , decltype(_impl_.remote_command_response_){nullptr}
    , decltype(_impl_.device_attribute_update_permission_response_){nullptr}
    , decltype(_impl_.device_attribute_update_response_){nullptr}
    , decltype(_impl_.gcm_id_update_response_){nullptr}
    , decltype(_impl_.check_android_management_response_){nullptr}
    , decltype(_impl_.active_directory_enroll_play_user_response_){nullptr}
    , decltype(_impl_.active_directory_play_activity_response_){nullptr}
    , decltype(_impl_.check_device_license_response_deprecated_){nullptr}
    , decltype(_impl_.active_directory_user_signin_response_){nullptr}
    , decltype(_impl_.chrome_desktop_report_response_){nullptr}
    , decltype(_impl_.app_install_report_response_){nullptr}
    , decltype(_impl_.policy_validation_report_response_){nullptr}
    , decltype(_impl_.device_initial_enrollment_state_response_){nullptr}
    , decltype(_impl_.refresh_account_response_){nullptr}
    , decltype(_impl_.child_status_report_response_){nullptr}
    , decltype(_impl_.rsu_lookup_key_upload_response_){nullptr}
    , decltype(_impl_.public_saml_user_response_){nullptr}
    , decltype(_impl_.chrome_os_user_report_response_){nullptr}
    , decltype(_impl_.client_certificate_provisioning_response_){nullptr}
    , decltype(_impl_.check_user_account_response_){nullptr}
    , decltype(_impl_.private_set_membership_response_){nullptr}
    , decltype(_impl_.browser_public_key_upload_response_){nullptr}
    , decltype(_impl_.upload_euicc_info_response_){nullptr}
    , decltype(_impl_.chrome_profile_report_response_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error_message()) {
    _this->_impl_.error_message_.Set(from._internal_error_message(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_register_response()) {
    _this->_impl_.register_response_ = new ::enterprise_management::DeviceRegisterResponse(*from._impl_.register_response_);
  }
  if (from._internal_has_unregister_response()) {
    _this->_impl_.unregister_response_ = new ::enterprise_management::DeviceUnregisterResponse(*from._impl_.unregister_response_);
  }
  if (from._internal_has_policy_response()) {
    _this->_impl_.policy_response_ = new ::enterprise_management::DevicePolicyResponse(*from._impl_.policy_response_);
  }
  if (from._internal_has_device_status_report_response()) {
    _this->_impl_.device_status_report_response_ = new ::enterprise_management::DeviceStatusReportResponse(*from._impl_.device_status_report_response_);
  }
  if (from._internal_has_session_status_report_response()) {
    _this->_impl_.session_status_report_response_ = new ::enterprise_management::SessionStatusReportResponse(*from._impl_.session_status_report_response_);
  }
  if (from._internal_has_auto_enrollment_response()) {
    _this->_impl_.auto_enrollment_response_ = new ::enterprise_management::DeviceAutoEnrollmentResponse(*from._impl_.auto_enrollment_response_);
  }
  if (from._internal_has_cert_upload_response()) {
    _this->_impl_.cert_upload_response_ = new ::enterprise_management::DeviceCertUploadResponse(*from._impl_.cert_upload_response_);
  }
  if (from._internal_has_service_api_access_response()) {
    _this->_impl_.service_api_access_response_ = new ::enterprise_management::DeviceServiceApiAccessResponse(*from._impl_.service_api_access_response_);
  }
  if (from._internal_has_device_state_retrieval_response()) {
    _this->_impl_.device_state_retrieval_response_ = new ::enterprise_management::DeviceStateRetrievalResponse(*from._impl_.device_state_retrieval_response_);
  }
  if (from._internal_has_device_pairing_response()) {
    _this->_impl_.device_pairing_response_ = new ::enterprise_management::DevicePairingResponse(*from._impl_.device_pairing_response_);
  }
  if (from._internal_has_check_device_pairing_response()) {
    _this->_impl_.check_device_pairing_response_ = new ::enterprise_management::CheckDevicePairingResponse(*from._impl_.check_device_pairing_response_);
  }
  if (from._internal_has_remote_command_response()) {
    _this->_impl_.remote_command_response_ = new ::enterprise_management::DeviceRemoteCommandResponse(*from._impl_.remote_command_response_);
  }
  if (from._internal_has_device_attribute_update_permission_response()) {
    _this->_impl_.device_attribute_update_permission_response_ = new ::enterprise_management::DeviceAttributeUpdatePermissionResponse(*from._impl_.device_attribute_update_permission_response_);
  }
  if (from._internal_has_device_attribute_update_response()) {
    _this->_impl_.device_attribute_update_response_ = new ::enterprise_management::DeviceAttributeUpdateResponse(*from._impl_.device_attribute_update_response_);
  }
  if (from._internal_has_gcm_id_update_response()) {
    _this->_impl_.gcm_id_update_response_ = new ::enterprise_management::GcmIdUpdateResponse(*from._impl_.gcm_id_update_response_);
  }
  if (from._internal_has_check_android_management_response()) {
    _this->_impl_.check_android_management_response_ = new ::enterprise_management::CheckAndroidManagementResponse(*from._impl_.check_android_management_response_);
  }
  if (from._internal_has_active_directory_enroll_play_user_response()) {
    _this->_impl_.active_directory_enroll_play_user_response_ = new ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse(*from._impl_.active_directory_enroll_play_user_response_);
  }
  if (from._internal_has_active_directory_play_activity_response()) {
    _this->_impl_.active_directory_play_activity_response_ = new ::enterprise_management::ActiveDirectoryPlayActivityResponse(*from._impl_.active_directory_play_activity_response_);
  }
  if (from._internal_has_check_device_license_response_deprecated()) {
    _this->_impl_.check_device_license_response_deprecated_ = new ::enterprise_management::CheckDeviceLicenseResponse(*from._impl_.check_device_license_response_deprecated_);
  }
  if (from._internal_has_active_directory_user_signin_response()) {
    _this->_impl_.active_directory_user_signin_response_ = new ::enterprise_management::ActiveDirectoryUserSigninResponse(*from._impl_.active_directory_user_signin_response_);
  }
  if (from._internal_has_chrome_desktop_report_response()) {
    _this->_impl_.chrome_desktop_report_response_ = new ::enterprise_management::ChromeDesktopReportResponse(*from._impl_.chrome_desktop_report_response_);
  }
  if (from._internal_has_app_install_report_response()) {
    _this->_impl_.app_install_report_response_ = new ::enterprise_management::AppInstallReportResponse(*from._impl_.app_install_report_response_);
  }
  if (from._internal_has_policy_validation_report_response()) {
    _this->_impl_.policy_validation_report_response_ = new ::enterprise_management::PolicyValidationReportResponse(*from._impl_.policy_validation_report_response_);
  }
  if (from._internal_has_device_initial_enrollment_state_response()) {
    _this->_impl_.device_initial_enrollment_state_response_ = new ::enterprise_management::DeviceInitialEnrollmentStateResponse(*from._impl_.device_initial_enrollment_state_response_);
  }
  if (from._internal_has_refresh_account_response()) {
    _this->_impl_.refresh_account_response_ = new ::enterprise_management::RefreshAccountResponse(*from._impl_.refresh_account_response_);
  }
  if (from._internal_has_child_status_report_response()) {
    _this->_impl_.child_status_report_response_ = new ::enterprise_management::ChildStatusReportResponse(*from._impl_.child_status_report_response_);
  }
  if (from._internal_has_rsu_lookup_key_upload_response()) {
    _this->_impl_.rsu_lookup_key_upload_response_ = new ::enterprise_management::RsuLookupKeyUploadResponse(*from._impl_.rsu_lookup_key_upload_response_);
  }
  if (from._internal_has_public_saml_user_response()) {
    _this->_impl_.public_saml_user_response_ = new ::enterprise_management::PublicSamlUserResponse(*from._impl_.public_saml_user_response_);
  }
  if (from._internal_has_chrome_os_user_report_response()) {
    _this->_impl_.chrome_os_user_report_response_ = new ::enterprise_management::ChromeOsUserReportResponse(*from._impl_.chrome_os_user_report_response_);
  }
  if (from._internal_has_client_certificate_provisioning_response()) {
    _this->_impl_.client_certificate_provisioning_response_ = new ::enterprise_management::ClientCertificateProvisioningResponse(*from._impl_.client_certificate_provisioning_response_);
  }
  if (from._internal_has_check_user_account_response()) {
    _this->_impl_.check_user_account_response_ = new ::enterprise_management::CheckUserAccountResponse(*from._impl_.check_user_account_response_);
  }
  if (from._internal_has_private_set_membership_response()) {
    _this->_impl_.private_set_membership_response_ = new ::enterprise_management::PrivateSetMembershipResponse(*from._impl_.private_set_membership_response_);
  }
  if (from._internal_has_browser_public_key_upload_response()) {
    _this->_impl_.browser_public_key_upload_response_ = new ::enterprise_management::BrowserPublicKeyUploadResponse(*from._impl_.browser_public_key_upload_response_);
  }
  if (from._internal_has_upload_euicc_info_response()) {
    _this->_impl_.upload_euicc_info_response_ = new ::enterprise_management::UploadEuiccInfoResponse(*from._impl_.upload_euicc_info_response_);
  }
  if (from._internal_has_chrome_profile_report_response()) {
    _this->_impl_.chrome_profile_report_response_ = new ::enterprise_management::ChromeProfileReportResponse(*from._impl_.chrome_profile_report_response_);
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceManagementResponse)
}

inline void DeviceManagementResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_detail_){arena}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.register_response_){nullptr}
    , decltype(_impl_.unregister_response_){nullptr}
    , decltype(_impl_.policy_response_){nullptr}
    , decltype(_impl_.device_status_report_response_){nullptr}
    , decltype(_impl_.session_status_report_response_){nullptr}
    , decltype(_impl_.auto_enrollment_response_){nullptr}
    , decltype(_impl_.cert_upload_response_){nullptr}
    , decltype(_impl_.service_api_access_response_){nullptr}
    , decltype(_impl_.device_state_retrieval_response_){nullptr}
    , decltype(_impl_.device_pairing_response_){nullptr}
    , decltype(_impl_.check_device_pairing_response_){nullptr}
    , decltype(_impl_.remote_command_response_){nullptr}
    , decltype(_impl_.device_attribute_update_permission_response_){nullptr}
    , decltype(_impl_.device_attribute_update_response_){nullptr}
    , decltype(_impl_.gcm_id_update_response_){nullptr}
    , decltype(_impl_.check_android_management_response_){nullptr}
    , decltype(_impl_.active_directory_enroll_play_user_response_){nullptr}
    , decltype(_impl_.active_directory_play_activity_response_){nullptr}
    , decltype(_impl_.check_device_license_response_deprecated_){nullptr}
    , decltype(_impl_.active_directory_user_signin_response_){nullptr}
    , decltype(_impl_.chrome_desktop_report_response_){nullptr}
    , decltype(_impl_.app_install_report_response_){nullptr}
    , decltype(_impl_.policy_validation_report_response_){nullptr}
    , decltype(_impl_.device_initial_enrollment_state_response_){nullptr}
    , decltype(_impl_.refresh_account_response_){nullptr}
    , decltype(_impl_.child_status_report_response_){nullptr}
    , decltype(_impl_.rsu_lookup_key_upload_response_){nullptr}
    , decltype(_impl_.public_saml_user_response_){nullptr}
    , decltype(_impl_.chrome_os_user_report_response_){nullptr}
    , decltype(_impl_.client_certificate_provisioning_response_){nullptr}
    , decltype(_impl_.check_user_account_response_){nullptr}
    , decltype(_impl_.private_set_membership_response_){nullptr}
    , decltype(_impl_.browser_public_key_upload_response_){nullptr}
    , decltype(_impl_.upload_euicc_info_response_){nullptr}
    , decltype(_impl_.chrome_profile_report_response_){nullptr}
  };
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceManagementResponse::~DeviceManagementResponse() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceManagementResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceManagementResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_detail_.~RepeatedField();
  _impl_.error_message_.Destroy();
  if (this != internal_default_instance()) delete _impl_.register_response_;
  if (this != internal_default_instance()) delete _impl_.unregister_response_;
  if (this != internal_default_instance()) delete _impl_.policy_response_;
  if (this != internal_default_instance()) delete _impl_.device_status_report_response_;
  if (this != internal_default_instance()) delete _impl_.session_status_report_response_;
  if (this != internal_default_instance()) delete _impl_.auto_enrollment_response_;
  if (this != internal_default_instance()) delete _impl_.cert_upload_response_;
  if (this != internal_default_instance()) delete _impl_.service_api_access_response_;
  if (this != internal_default_instance()) delete _impl_.device_state_retrieval_response_;
  if (this != internal_default_instance()) delete _impl_.device_pairing_response_;
  if (this != internal_default_instance()) delete _impl_.check_device_pairing_response_;
  if (this != internal_default_instance()) delete _impl_.remote_command_response_;
  if (this != internal_default_instance()) delete _impl_.device_attribute_update_permission_response_;
  if (this != internal_default_instance()) delete _impl_.device_attribute_update_response_;
  if (this != internal_default_instance()) delete _impl_.gcm_id_update_response_;
  if (this != internal_default_instance()) delete _impl_.check_android_management_response_;
  if (this != internal_default_instance()) delete _impl_.active_directory_enroll_play_user_response_;
  if (this != internal_default_instance()) delete _impl_.active_directory_play_activity_response_;
  if (this != internal_default_instance()) delete _impl_.check_device_license_response_deprecated_;
  if (this != internal_default_instance()) delete _impl_.active_directory_user_signin_response_;
  if (this != internal_default_instance()) delete _impl_.chrome_desktop_report_response_;
  if (this != internal_default_instance()) delete _impl_.app_install_report_response_;
  if (this != internal_default_instance()) delete _impl_.policy_validation_report_response_;
  if (this != internal_default_instance()) delete _impl_.device_initial_enrollment_state_response_;
  if (this != internal_default_instance()) delete _impl_.refresh_account_response_;
  if (this != internal_default_instance()) delete _impl_.child_status_report_response_;
  if (this != internal_default_instance()) delete _impl_.rsu_lookup_key_upload_response_;
  if (this != internal_default_instance()) delete _impl_.public_saml_user_response_;
  if (this != internal_default_instance()) delete _impl_.chrome_os_user_report_response_;
  if (this != internal_default_instance()) delete _impl_.client_certificate_provisioning_response_;
  if (this != internal_default_instance()) delete _impl_.check_user_account_response_;
  if (this != internal_default_instance()) delete _impl_.private_set_membership_response_;
  if (this != internal_default_instance()) delete _impl_.browser_public_key_upload_response_;
  if (this != internal_default_instance()) delete _impl_.upload_euicc_info_response_;
  if (this != internal_default_instance()) delete _impl_.chrome_profile_report_response_;
}

void DeviceManagementResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceManagementResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceManagementResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.error_detail_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.error_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.register_response_ != nullptr);
      _impl_.register_response_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.unregister_response_ != nullptr);
      _impl_.unregister_response_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.policy_response_ != nullptr);
      _impl_.policy_response_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.device_status_report_response_ != nullptr);
      _impl_.device_status_report_response_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.session_status_report_response_ != nullptr);
      _impl_.session_status_report_response_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.auto_enrollment_response_ != nullptr);
      _impl_.auto_enrollment_response_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.cert_upload_response_ != nullptr);
      _impl_.cert_upload_response_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.service_api_access_response_ != nullptr);
      _impl_.service_api_access_response_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.device_state_retrieval_response_ != nullptr);
      _impl_.device_state_retrieval_response_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.device_pairing_response_ != nullptr);
      _impl_.device_pairing_response_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.check_device_pairing_response_ != nullptr);
      _impl_.check_device_pairing_response_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.remote_command_response_ != nullptr);
      _impl_.remote_command_response_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.device_attribute_update_permission_response_ != nullptr);
      _impl_.device_attribute_update_permission_response_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.device_attribute_update_response_ != nullptr);
      _impl_.device_attribute_update_response_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(_impl_.gcm_id_update_response_ != nullptr);
      _impl_.gcm_id_update_response_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(_impl_.check_android_management_response_ != nullptr);
      _impl_.check_android_management_response_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(_impl_.active_directory_enroll_play_user_response_ != nullptr);
      _impl_.active_directory_enroll_play_user_response_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(_impl_.active_directory_play_activity_response_ != nullptr);
      _impl_.active_directory_play_activity_response_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(_impl_.check_device_license_response_deprecated_ != nullptr);
      _impl_.check_device_license_response_deprecated_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(_impl_.active_directory_user_signin_response_ != nullptr);
      _impl_.active_directory_user_signin_response_->Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      GOOGLE_DCHECK(_impl_.chrome_desktop_report_response_ != nullptr);
      _impl_.chrome_desktop_report_response_->Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      GOOGLE_DCHECK(_impl_.app_install_report_response_ != nullptr);
      _impl_.app_install_report_response_->Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      GOOGLE_DCHECK(_impl_.policy_validation_report_response_ != nullptr);
      _impl_.policy_validation_report_response_->Clear();
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      GOOGLE_DCHECK(_impl_.device_initial_enrollment_state_response_ != nullptr);
      _impl_.device_initial_enrollment_state_response_->Clear();
    }
    if (cached_has_bits & 0x02000000u) {
      GOOGLE_DCHECK(_impl_.refresh_account_response_ != nullptr);
      _impl_.refresh_account_response_->Clear();
    }
    if (cached_has_bits & 0x04000000u) {
      GOOGLE_DCHECK(_impl_.child_status_report_response_ != nullptr);
      _impl_.child_status_report_response_->Clear();
    }
    if (cached_has_bits & 0x08000000u) {
      GOOGLE_DCHECK(_impl_.rsu_lookup_key_upload_response_ != nullptr);
      _impl_.rsu_lookup_key_upload_response_->Clear();
    }
    if (cached_has_bits & 0x10000000u) {
      GOOGLE_DCHECK(_impl_.public_saml_user_response_ != nullptr);
      _impl_.public_saml_user_response_->Clear();
    }
    if (cached_has_bits & 0x20000000u) {
      GOOGLE_DCHECK(_impl_.chrome_os_user_report_response_ != nullptr);
      _impl_.chrome_os_user_report_response_->Clear();
    }
    if (cached_has_bits & 0x40000000u) {
      GOOGLE_DCHECK(_impl_.client_certificate_provisioning_response_ != nullptr);
      _impl_.client_certificate_provisioning_response_->Clear();
    }
    if (cached_has_bits & 0x80000000u) {
      GOOGLE_DCHECK(_impl_.check_user_account_response_ != nullptr);
      _impl_.check_user_account_response_->Clear();
    }
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.private_set_membership_response_ != nullptr);
      _impl_.private_set_membership_response_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.browser_public_key_upload_response_ != nullptr);
      _impl_.browser_public_key_upload_response_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.upload_euicc_info_response_ != nullptr);
      _impl_.upload_euicc_info_response_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.chrome_profile_report_response_ != nullptr);
      _impl_.chrome_profile_report_response_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceManagementResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string error_message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_error_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceRegisterResponse register_response = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_register_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceUnregisterResponse unregister_response = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_unregister_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DevicePolicyResponse policy_response = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_policy_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceStatusReportResponse device_status_report_response = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_status_report_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.SessionStatusReportResponse session_status_report_response = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_session_status_report_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceAutoEnrollmentResponse auto_enrollment_response = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_auto_enrollment_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceCertUploadResponse cert_upload_response = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_cert_upload_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceServiceApiAccessResponse service_api_access_response = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_service_api_access_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceStateRetrievalResponse device_state_retrieval_response = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_state_retrieval_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DevicePairingResponse device_pairing_response = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_pairing_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.CheckDevicePairingResponse check_device_pairing_response = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_check_device_pairing_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceRemoteCommandResponse remote_command_response = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_remote_command_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceAttributeUpdatePermissionResponse device_attribute_update_permission_response = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_attribute_update_permission_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceAttributeUpdateResponse device_attribute_update_response = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_attribute_update_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.GcmIdUpdateResponse gcm_id_update_response = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_gcm_id_update_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.CheckAndroidManagementResponse check_android_management_response = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_check_android_management_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ActiveDirectoryEnrollPlayUserResponse active_directory_enroll_play_user_response = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_active_directory_enroll_play_user_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ActiveDirectoryPlayActivityResponse active_directory_play_activity_response = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_active_directory_play_activity_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.CheckDeviceLicenseResponse check_device_license_response_deprecated = 21 [deprecated = true];
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_check_device_license_response_deprecated(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ActiveDirectoryUserSigninResponse active_directory_user_signin_response = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_active_directory_user_signin_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ChromeDesktopReportResponse chrome_desktop_report_response = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_chrome_desktop_report_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.AppInstallReportResponse app_install_report_response = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_app_install_report_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PolicyValidationReportResponse policy_validation_report_response = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_policy_validation_report_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.DeviceInitialEnrollmentStateResponse device_initial_enrollment_state_response = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_initial_enrollment_state_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.RefreshAccountResponse refresh_account_response = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_refresh_account_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ChildStatusReportResponse child_status_report_response = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_child_status_report_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.RsuLookupKeyUploadResponse rsu_lookup_key_upload_response = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_rsu_lookup_key_upload_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PublicSamlUserResponse public_saml_user_response = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_public_saml_user_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ChromeOsUserReportResponse chrome_os_user_report_response = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_chrome_os_user_report_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ClientCertificateProvisioningResponse client_certificate_provisioning_response = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_certificate_provisioning_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.CheckUserAccountResponse check_user_account_response = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_check_user_account_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.PrivateSetMembershipResponse private_set_membership_response = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_private_set_membership_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.BrowserPublicKeyUploadResponse browser_public_key_upload_response = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_browser_public_key_upload_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.UploadEuiccInfoResponse upload_euicc_info_response = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_upload_euicc_info_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_management.ChromeProfileReportResponse chrome_profile_report_response = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_chrome_profile_report_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_management.DeviceManagementErrorDetail error_detail = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 2;
          do {
            ptr += 2;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::enterprise_management::DeviceManagementErrorDetail_IsValid(val))) {
              _internal_add_error_detail(static_cast<::enterprise_management::DeviceManagementErrorDetail>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(39, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<312>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_error_detail(), ptr, ctx, ::enterprise_management::DeviceManagementErrorDetail_IsValid, &_internal_metadata_, 39);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceManagementResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceManagementResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string error_message = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_error_message(), target);
  }

  // optional .enterprise_management.DeviceRegisterResponse register_response = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::register_response(this),
        _Internal::register_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceUnregisterResponse unregister_response = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::unregister_response(this),
        _Internal::unregister_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DevicePolicyResponse policy_response = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::policy_response(this),
        _Internal::policy_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceStatusReportResponse device_status_report_response = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::device_status_report_response(this),
        _Internal::device_status_report_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.SessionStatusReportResponse session_status_report_response = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::session_status_report_response(this),
        _Internal::session_status_report_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceAutoEnrollmentResponse auto_enrollment_response = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::auto_enrollment_response(this),
        _Internal::auto_enrollment_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceCertUploadResponse cert_upload_response = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::cert_upload_response(this),
        _Internal::cert_upload_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceServiceApiAccessResponse service_api_access_response = 10;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::service_api_access_response(this),
        _Internal::service_api_access_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceStateRetrievalResponse device_state_retrieval_response = 11;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::device_state_retrieval_response(this),
        _Internal::device_state_retrieval_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DevicePairingResponse device_pairing_response = 12;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::device_pairing_response(this),
        _Internal::device_pairing_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.CheckDevicePairingResponse check_device_pairing_response = 13;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::check_device_pairing_response(this),
        _Internal::check_device_pairing_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceRemoteCommandResponse remote_command_response = 14;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::remote_command_response(this),
        _Internal::remote_command_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceAttributeUpdatePermissionResponse device_attribute_update_permission_response = 15;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::device_attribute_update_permission_response(this),
        _Internal::device_attribute_update_permission_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceAttributeUpdateResponse device_attribute_update_response = 16;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::device_attribute_update_response(this),
        _Internal::device_attribute_update_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.GcmIdUpdateResponse gcm_id_update_response = 17;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::gcm_id_update_response(this),
        _Internal::gcm_id_update_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.CheckAndroidManagementResponse check_android_management_response = 18;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::check_android_management_response(this),
        _Internal::check_android_management_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ActiveDirectoryEnrollPlayUserResponse active_directory_enroll_play_user_response = 19;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::active_directory_enroll_play_user_response(this),
        _Internal::active_directory_enroll_play_user_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ActiveDirectoryPlayActivityResponse active_directory_play_activity_response = 20;
  if (cached_has_bits & 0x00040000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::active_directory_play_activity_response(this),
        _Internal::active_directory_play_activity_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.CheckDeviceLicenseResponse check_device_license_response_deprecated = 21 [deprecated = true];
  if (cached_has_bits & 0x00080000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::check_device_license_response_deprecated(this),
        _Internal::check_device_license_response_deprecated(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ActiveDirectoryUserSigninResponse active_directory_user_signin_response = 22;
  if (cached_has_bits & 0x00100000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::active_directory_user_signin_response(this),
        _Internal::active_directory_user_signin_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ChromeDesktopReportResponse chrome_desktop_report_response = 23;
  if (cached_has_bits & 0x00200000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::chrome_desktop_report_response(this),
        _Internal::chrome_desktop_report_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.AppInstallReportResponse app_install_report_response = 25;
  if (cached_has_bits & 0x00400000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::app_install_report_response(this),
        _Internal::app_install_report_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.PolicyValidationReportResponse policy_validation_report_response = 26;
  if (cached_has_bits & 0x00800000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(26, _Internal::policy_validation_report_response(this),
        _Internal::policy_validation_report_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.DeviceInitialEnrollmentStateResponse device_initial_enrollment_state_response = 27;
  if (cached_has_bits & 0x01000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(27, _Internal::device_initial_enrollment_state_response(this),
        _Internal::device_initial_enrollment_state_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.RefreshAccountResponse refresh_account_response = 28;
  if (cached_has_bits & 0x02000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(28, _Internal::refresh_account_response(this),
        _Internal::refresh_account_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ChildStatusReportResponse child_status_report_response = 29;
  if (cached_has_bits & 0x04000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(29, _Internal::child_status_report_response(this),
        _Internal::child_status_report_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.RsuLookupKeyUploadResponse rsu_lookup_key_upload_response = 30;
  if (cached_has_bits & 0x08000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(30, _Internal::rsu_lookup_key_upload_response(this),
        _Internal::rsu_lookup_key_upload_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.PublicSamlUserResponse public_saml_user_response = 31;
  if (cached_has_bits & 0x10000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(31, _Internal::public_saml_user_response(this),
        _Internal::public_saml_user_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ChromeOsUserReportResponse chrome_os_user_report_response = 32;
  if (cached_has_bits & 0x20000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(32, _Internal::chrome_os_user_report_response(this),
        _Internal::chrome_os_user_report_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ClientCertificateProvisioningResponse client_certificate_provisioning_response = 33;
  if (cached_has_bits & 0x40000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(33, _Internal::client_certificate_provisioning_response(this),
        _Internal::client_certificate_provisioning_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.CheckUserAccountResponse check_user_account_response = 34;
  if (cached_has_bits & 0x80000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(34, _Internal::check_user_account_response(this),
        _Internal::check_user_account_response(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional .enterprise_management.PrivateSetMembershipResponse private_set_membership_response = 35;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(35, _Internal::private_set_membership_response(this),
        _Internal::private_set_membership_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.BrowserPublicKeyUploadResponse browser_public_key_upload_response = 36;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(36, _Internal::browser_public_key_upload_response(this),
        _Internal::browser_public_key_upload_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.UploadEuiccInfoResponse upload_euicc_info_response = 37;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(37, _Internal::upload_euicc_info_response(this),
        _Internal::upload_euicc_info_response(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_management.ChromeProfileReportResponse chrome_profile_report_response = 38;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(38, _Internal::chrome_profile_report_response(this),
        _Internal::chrome_profile_report_response(this).GetCachedSize(), target, stream);
  }

  // repeated .enterprise_management.DeviceManagementErrorDetail error_detail = 39;
  for (int i = 0, n = this->_internal_error_detail_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        39, this->_internal_error_detail(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceManagementResponse)
  return target;
}

size_t DeviceManagementResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceManagementResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_management.DeviceManagementErrorDetail error_detail = 39;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_error_detail_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_error_detail(static_cast<int>(i)));
    }
    total_size += (2UL * count) + data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string error_message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error_message());
    }

    // optional .enterprise_management.DeviceRegisterResponse register_response = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.register_response_);
    }

    // optional .enterprise_management.DeviceUnregisterResponse unregister_response = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.unregister_response_);
    }

    // optional .enterprise_management.DevicePolicyResponse policy_response = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.policy_response_);
    }

    // optional .enterprise_management.DeviceStatusReportResponse device_status_report_response = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_status_report_response_);
    }

    // optional .enterprise_management.SessionStatusReportResponse session_status_report_response = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.session_status_report_response_);
    }

    // optional .enterprise_management.DeviceAutoEnrollmentResponse auto_enrollment_response = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.auto_enrollment_response_);
    }

    // optional .enterprise_management.DeviceCertUploadResponse cert_upload_response = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cert_upload_response_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .enterprise_management.DeviceServiceApiAccessResponse service_api_access_response = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.service_api_access_response_);
    }

    // optional .enterprise_management.DeviceStateRetrievalResponse device_state_retrieval_response = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_state_retrieval_response_);
    }

    // optional .enterprise_management.DevicePairingResponse device_pairing_response = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_pairing_response_);
    }

    // optional .enterprise_management.CheckDevicePairingResponse check_device_pairing_response = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.check_device_pairing_response_);
    }

    // optional .enterprise_management.DeviceRemoteCommandResponse remote_command_response = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.remote_command_response_);
    }

    // optional .enterprise_management.DeviceAttributeUpdatePermissionResponse device_attribute_update_permission_response = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_attribute_update_permission_response_);
    }

    // optional .enterprise_management.DeviceAttributeUpdateResponse device_attribute_update_response = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_attribute_update_response_);
    }

    // optional .enterprise_management.GcmIdUpdateResponse gcm_id_update_response = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.gcm_id_update_response_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .enterprise_management.CheckAndroidManagementResponse check_android_management_response = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.check_android_management_response_);
    }

    // optional .enterprise_management.ActiveDirectoryEnrollPlayUserResponse active_directory_enroll_play_user_response = 19;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.active_directory_enroll_play_user_response_);
    }

    // optional .enterprise_management.ActiveDirectoryPlayActivityResponse active_directory_play_activity_response = 20;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.active_directory_play_activity_response_);
    }

    // optional .enterprise_management.CheckDeviceLicenseResponse check_device_license_response_deprecated = 21 [deprecated = true];
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.check_device_license_response_deprecated_);
    }

    // optional .enterprise_management.ActiveDirectoryUserSigninResponse active_directory_user_signin_response = 22;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.active_directory_user_signin_response_);
    }

    // optional .enterprise_management.ChromeDesktopReportResponse chrome_desktop_report_response = 23;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chrome_desktop_report_response_);
    }

    // optional .enterprise_management.AppInstallReportResponse app_install_report_response = 25;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.app_install_report_response_);
    }

    // optional .enterprise_management.PolicyValidationReportResponse policy_validation_report_response = 26;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.policy_validation_report_response_);
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional .enterprise_management.DeviceInitialEnrollmentStateResponse device_initial_enrollment_state_response = 27;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.device_initial_enrollment_state_response_);
    }

    // optional .enterprise_management.RefreshAccountResponse refresh_account_response = 28;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.refresh_account_response_);
    }

    // optional .enterprise_management.ChildStatusReportResponse child_status_report_response = 29;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.child_status_report_response_);
    }

    // optional .enterprise_management.RsuLookupKeyUploadResponse rsu_lookup_key_upload_response = 30;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rsu_lookup_key_upload_response_);
    }

    // optional .enterprise_management.PublicSamlUserResponse public_saml_user_response = 31;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.public_saml_user_response_);
    }

    // optional .enterprise_management.ChromeOsUserReportResponse chrome_os_user_report_response = 32;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chrome_os_user_report_response_);
    }

    // optional .enterprise_management.ClientCertificateProvisioningResponse client_certificate_provisioning_response = 33;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.client_certificate_provisioning_response_);
    }

    // optional .enterprise_management.CheckUserAccountResponse check_user_account_response = 34;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.check_user_account_response_);
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x0000000fu) {
    // optional .enterprise_management.PrivateSetMembershipResponse private_set_membership_response = 35;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.private_set_membership_response_);
    }

    // optional .enterprise_management.BrowserPublicKeyUploadResponse browser_public_key_upload_response = 36;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.browser_public_key_upload_response_);
    }

    // optional .enterprise_management.UploadEuiccInfoResponse upload_euicc_info_response = 37;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.upload_euicc_info_response_);
    }

    // optional .enterprise_management.ChromeProfileReportResponse chrome_profile_report_response = 38;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chrome_profile_report_response_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceManagementResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceManagementResponse*>(
      &from));
}

void DeviceManagementResponse::MergeFrom(const DeviceManagementResponse& from) {
  DeviceManagementResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceManagementResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.error_detail_.MergeFrom(from._impl_.error_detail_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_register_response()->::enterprise_management::DeviceRegisterResponse::MergeFrom(
          from._internal_register_response());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_unregister_response()->::enterprise_management::DeviceUnregisterResponse::MergeFrom(
          from._internal_unregister_response());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_policy_response()->::enterprise_management::DevicePolicyResponse::MergeFrom(
          from._internal_policy_response());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_device_status_report_response()->::enterprise_management::DeviceStatusReportResponse::MergeFrom(
          from._internal_device_status_report_response());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_session_status_report_response()->::enterprise_management::SessionStatusReportResponse::MergeFrom(
          from._internal_session_status_report_response());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_auto_enrollment_response()->::enterprise_management::DeviceAutoEnrollmentResponse::MergeFrom(
          from._internal_auto_enrollment_response());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_cert_upload_response()->::enterprise_management::DeviceCertUploadResponse::MergeFrom(
          from._internal_cert_upload_response());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_service_api_access_response()->::enterprise_management::DeviceServiceApiAccessResponse::MergeFrom(
          from._internal_service_api_access_response());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_device_state_retrieval_response()->::enterprise_management::DeviceStateRetrievalResponse::MergeFrom(
          from._internal_device_state_retrieval_response());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_device_pairing_response()->::enterprise_management::DevicePairingResponse::MergeFrom(
          from._internal_device_pairing_response());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_check_device_pairing_response()->::enterprise_management::CheckDevicePairingResponse::MergeFrom(
          from._internal_check_device_pairing_response());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_remote_command_response()->::enterprise_management::DeviceRemoteCommandResponse::MergeFrom(
          from._internal_remote_command_response());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_device_attribute_update_permission_response()->::enterprise_management::DeviceAttributeUpdatePermissionResponse::MergeFrom(
          from._internal_device_attribute_update_permission_response());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_device_attribute_update_response()->::enterprise_management::DeviceAttributeUpdateResponse::MergeFrom(
          from._internal_device_attribute_update_response());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_gcm_id_update_response()->::enterprise_management::GcmIdUpdateResponse::MergeFrom(
          from._internal_gcm_id_update_response());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_internal_mutable_check_android_management_response()->::enterprise_management::CheckAndroidManagementResponse::MergeFrom(
          from._internal_check_android_management_response());
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_internal_mutable_active_directory_enroll_play_user_response()->::enterprise_management::ActiveDirectoryEnrollPlayUserResponse::MergeFrom(
          from._internal_active_directory_enroll_play_user_response());
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_internal_mutable_active_directory_play_activity_response()->::enterprise_management::ActiveDirectoryPlayActivityResponse::MergeFrom(
          from._internal_active_directory_play_activity_response());
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_internal_mutable_check_device_license_response_deprecated()->::enterprise_management::CheckDeviceLicenseResponse::MergeFrom(
          from._internal_check_device_license_response_deprecated());
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_internal_mutable_active_directory_user_signin_response()->::enterprise_management::ActiveDirectoryUserSigninResponse::MergeFrom(
          from._internal_active_directory_user_signin_response());
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_internal_mutable_chrome_desktop_report_response()->::enterprise_management::ChromeDesktopReportResponse::MergeFrom(
          from._internal_chrome_desktop_report_response());
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_internal_mutable_app_install_report_response()->::enterprise_management::AppInstallReportResponse::MergeFrom(
          from._internal_app_install_report_response());
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_internal_mutable_policy_validation_report_response()->::enterprise_management::PolicyValidationReportResponse::MergeFrom(
          from._internal_policy_validation_report_response());
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_internal_mutable_device_initial_enrollment_state_response()->::enterprise_management::DeviceInitialEnrollmentStateResponse::MergeFrom(
          from._internal_device_initial_enrollment_state_response());
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_internal_mutable_refresh_account_response()->::enterprise_management::RefreshAccountResponse::MergeFrom(
          from._internal_refresh_account_response());
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_internal_mutable_child_status_report_response()->::enterprise_management::ChildStatusReportResponse::MergeFrom(
          from._internal_child_status_report_response());
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_internal_mutable_rsu_lookup_key_upload_response()->::enterprise_management::RsuLookupKeyUploadResponse::MergeFrom(
          from._internal_rsu_lookup_key_upload_response());
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_internal_mutable_public_saml_user_response()->::enterprise_management::PublicSamlUserResponse::MergeFrom(
          from._internal_public_saml_user_response());
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_internal_mutable_chrome_os_user_report_response()->::enterprise_management::ChromeOsUserReportResponse::MergeFrom(
          from._internal_chrome_os_user_report_response());
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_internal_mutable_client_certificate_provisioning_response()->::enterprise_management::ClientCertificateProvisioningResponse::MergeFrom(
          from._internal_client_certificate_provisioning_response());
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_internal_mutable_check_user_account_response()->::enterprise_management::CheckUserAccountResponse::MergeFrom(
          from._internal_check_user_account_response());
    }
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_private_set_membership_response()->::enterprise_management::PrivateSetMembershipResponse::MergeFrom(
          from._internal_private_set_membership_response());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_browser_public_key_upload_response()->::enterprise_management::BrowserPublicKeyUploadResponse::MergeFrom(
          from._internal_browser_public_key_upload_response());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_upload_euicc_info_response()->::enterprise_management::UploadEuiccInfoResponse::MergeFrom(
          from._internal_upload_euicc_info_response());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_chrome_profile_report_response()->::enterprise_management::ChromeProfileReportResponse::MergeFrom(
          from._internal_chrome_profile_report_response());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceManagementResponse::CopyFrom(const DeviceManagementResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceManagementResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceManagementResponse::IsInitialized() const {
  if (_internal_has_register_response()) {
    if (!_impl_.register_response_->IsInitialized()) return false;
  }
  return true;
}

void DeviceManagementResponse::InternalSwap(DeviceManagementResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  _impl_.error_detail_.InternalSwap(&other->_impl_.error_detail_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_message_, lhs_arena,
      &other->_impl_.error_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceManagementResponse, _impl_.chrome_profile_report_response_)
      + sizeof(DeviceManagementResponse::_impl_.chrome_profile_report_response_)
      - PROTOBUF_FIELD_OFFSET(DeviceManagementResponse, _impl_.register_response_)>(
          reinterpret_cast<char*>(&_impl_.register_response_),
          reinterpret_cast<char*>(&other->_impl_.register_response_));
}

std::string DeviceManagementResponse::GetTypeName() const {
  return "enterprise_management.DeviceManagementResponse";
}


// ===================================================================

class DeviceStateRetrievalInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceStateRetrievalInfo>()._impl_._has_bits_);
  static void set_has_has_initial_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeviceStateRetrievalInfo::DeviceStateRetrievalInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:enterprise_management.DeviceStateRetrievalInfo)
}
DeviceStateRetrievalInfo::DeviceStateRetrievalInfo(const DeviceStateRetrievalInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DeviceStateRetrievalInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.has_initial_state_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.has_initial_state_ = from._impl_.has_initial_state_;
  // @@protoc_insertion_point(copy_constructor:enterprise_management.DeviceStateRetrievalInfo)
}

inline void DeviceStateRetrievalInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.has_initial_state_){false}
  };
}

DeviceStateRetrievalInfo::~DeviceStateRetrievalInfo() {
  // @@protoc_insertion_point(destructor:enterprise_management.DeviceStateRetrievalInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceStateRetrievalInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceStateRetrievalInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceStateRetrievalInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_management.DeviceStateRetrievalInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.has_initial_state_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DeviceStateRetrievalInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool has_initial_state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_has_initial_state(&has_bits);
          _impl_.has_initial_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceStateRetrievalInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_management.DeviceStateRetrievalInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool has_initial_state = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_has_initial_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_management.DeviceStateRetrievalInfo)
  return target;
}

size_t DeviceStateRetrievalInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_management.DeviceStateRetrievalInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool has_initial_state = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceStateRetrievalInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeviceStateRetrievalInfo*>(
      &from));
}

void DeviceStateRetrievalInfo::MergeFrom(const DeviceStateRetrievalInfo& from) {
  DeviceStateRetrievalInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_management.DeviceStateRetrievalInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_has_initial_state()) {
    _this->_internal_set_has_initial_state(from._internal_has_initial_state());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceStateRetrievalInfo::CopyFrom(const DeviceStateRetrievalInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_management.DeviceStateRetrievalInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceStateRetrievalInfo::IsInitialized() const {
  return true;
}

void DeviceStateRetrievalInfo::InternalSwap(DeviceStateRetrievalInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.has_initial_state_, other->_impl_.has_initial_state_);
}

std::string DeviceStateRetrievalInfo::GetTypeName() const {
  return "enterprise_management.DeviceStateRetrievalInfo";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace enterprise_management
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::enterprise_management::LicenseType*
Arena::CreateMaybeMessage< ::enterprise_management::LicenseType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::LicenseType >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::SignedData*
Arena::CreateMaybeMessage< ::enterprise_management::SignedData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::SignedData >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CheckUserAccountRequest*
Arena::CreateMaybeMessage< ::enterprise_management::CheckUserAccountRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CheckUserAccountRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceRegisterRequest*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceRegisterRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceRegisterRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceRegisterIdentification*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceRegisterIdentification >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceRegisterIdentification >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CheckUserAccountResponse*
Arena::CreateMaybeMessage< ::enterprise_management::CheckUserAccountResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CheckUserAccountResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceRegisterResponse*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceRegisterResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceRegisterResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceUnregisterRequest*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceUnregisterRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceUnregisterRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceUnregisterResponse*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceUnregisterResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceUnregisterResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceCertUploadRequest*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceCertUploadRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceCertUploadRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceCertUploadResponse*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceCertUploadResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceCertUploadResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceServiceApiAccessRequest*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceServiceApiAccessRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceServiceApiAccessRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceServiceApiAccessResponse*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceServiceApiAccessResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceServiceApiAccessResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::BrowserDeviceIdentifier*
Arena::CreateMaybeMessage< ::enterprise_management::BrowserDeviceIdentifier >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::BrowserDeviceIdentifier >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PolicyFetchRequest*
Arena::CreateMaybeMessage< ::enterprise_management::PolicyFetchRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PolicyFetchRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DisabledState*
Arena::CreateMaybeMessage< ::enterprise_management::DisabledState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DisabledState >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceState*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceState >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CustomerLogo*
Arena::CreateMaybeMessage< ::enterprise_management::CustomerLogo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CustomerLogo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PolicyData*
Arena::CreateMaybeMessage< ::enterprise_management::PolicyData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PolicyData >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ClientActionRequired*
Arena::CreateMaybeMessage< ::enterprise_management::ClientActionRequired >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ClientActionRequired >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PolicyFetchResponse*
Arena::CreateMaybeMessage< ::enterprise_management::PolicyFetchResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PolicyFetchResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DEPRECATEDPolicyPublicKeyAndDomain*
Arena::CreateMaybeMessage< ::enterprise_management::DEPRECATEDPolicyPublicKeyAndDomain >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DEPRECATEDPolicyPublicKeyAndDomain >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PublicKeyVerificationData*
Arena::CreateMaybeMessage< ::enterprise_management::PublicKeyVerificationData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PublicKeyVerificationData >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DevicePolicyRequest*
Arena::CreateMaybeMessage< ::enterprise_management::DevicePolicyRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DevicePolicyRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DevicePolicyResponse*
Arena::CreateMaybeMessage< ::enterprise_management::DevicePolicyResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DevicePolicyResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::TimePeriod*
Arena::CreateMaybeMessage< ::enterprise_management::TimePeriod >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::TimePeriod >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ActiveTimePeriod*
Arena::CreateMaybeMessage< ::enterprise_management::ActiveTimePeriod >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ActiveTimePeriod >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::NetworkInterface*
Arena::CreateMaybeMessage< ::enterprise_management::NetworkInterface >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::NetworkInterface >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::NetworkState*
Arena::CreateMaybeMessage< ::enterprise_management::NetworkState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::NetworkState >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceUser*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceUser >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceUser >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::VolumeInfo*
Arena::CreateMaybeMessage< ::enterprise_management::VolumeInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::VolumeInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CpuUtilizationInfo*
Arena::CreateMaybeMessage< ::enterprise_management::CpuUtilizationInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CpuUtilizationInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::SystemFreeRamInfo*
Arena::CreateMaybeMessage< ::enterprise_management::SystemFreeRamInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::SystemFreeRamInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CPUTempInfo*
Arena::CreateMaybeMessage< ::enterprise_management::CPUTempInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CPUTempInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::StatefulPartitionInfo*
Arena::CreateMaybeMessage< ::enterprise_management::StatefulPartitionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::StatefulPartitionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::BatterySample*
Arena::CreateMaybeMessage< ::enterprise_management::BatterySample >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::BatterySample >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::BatteryInfo*
Arena::CreateMaybeMessage< ::enterprise_management::BatteryInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::BatteryInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PowerStatus*
Arena::CreateMaybeMessage< ::enterprise_management::PowerStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PowerStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DiskLifetimeEstimation*
Arena::CreateMaybeMessage< ::enterprise_management::DiskLifetimeEstimation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DiskLifetimeEstimation >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DiskInfo*
Arena::CreateMaybeMessage< ::enterprise_management::DiskInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DiskInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::StorageStatus*
Arena::CreateMaybeMessage< ::enterprise_management::StorageStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::StorageStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ThermalSample*
Arena::CreateMaybeMessage< ::enterprise_management::ThermalSample >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ThermalSample >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ThermalInfo*
Arena::CreateMaybeMessage< ::enterprise_management::ThermalInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ThermalInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::BoardStatus*
Arena::CreateMaybeMessage< ::enterprise_management::BoardStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::BoardStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::SystemStatus*
Arena::CreateMaybeMessage< ::enterprise_management::SystemStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::SystemStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CpuCStateInfo*
Arena::CreateMaybeMessage< ::enterprise_management::CpuCStateInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CpuCStateInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::LogicalCpuInfo*
Arena::CreateMaybeMessage< ::enterprise_management::LogicalCpuInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::LogicalCpuInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CpuInfo*
Arena::CreateMaybeMessage< ::enterprise_management::CpuInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CpuInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::GlobalCpuInfo*
Arena::CreateMaybeMessage< ::enterprise_management::GlobalCpuInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::GlobalCpuInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DisplayInfo*
Arena::CreateMaybeMessage< ::enterprise_management::DisplayInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DisplayInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::GraphicsAdapterInfo*
Arena::CreateMaybeMessage< ::enterprise_management::GraphicsAdapterInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::GraphicsAdapterInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::GraphicsStatus*
Arena::CreateMaybeMessage< ::enterprise_management::GraphicsStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::GraphicsStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CrashReportInfo*
Arena::CreateMaybeMessage< ::enterprise_management::CrashReportInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CrashReportInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::TimezoneInfo*
Arena::CreateMaybeMessage< ::enterprise_management::TimezoneInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::TimezoneInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::MemoryInfo*
Arena::CreateMaybeMessage< ::enterprise_management::MemoryInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::MemoryInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::BacklightInfo*
Arena::CreateMaybeMessage< ::enterprise_management::BacklightInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::BacklightInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::FanInfo*
Arena::CreateMaybeMessage< ::enterprise_management::FanInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::FanInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::BluetoothAdapterInfo*
Arena::CreateMaybeMessage< ::enterprise_management::BluetoothAdapterInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::BluetoothAdapterInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::SmbiosInfo*
Arena::CreateMaybeMessage< ::enterprise_management::SmbiosInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::SmbiosInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::KernelParameters*
Arena::CreateMaybeMessage< ::enterprise_management::KernelParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::KernelParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::EFIVars*
Arena::CreateMaybeMessage< ::enterprise_management::EFIVars >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::EFIVars >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::BootInfo*
Arena::CreateMaybeMessage< ::enterprise_management::BootInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::BootInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::NetworkAdapterInfo*
Arena::CreateMaybeMessage< ::enterprise_management::NetworkAdapterInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::NetworkAdapterInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::LaCrOsBrowserReport*
Arena::CreateMaybeMessage< ::enterprise_management::LaCrOsBrowserReport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::LaCrOsBrowserReport >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceStatusReportRequest*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceStatusReportRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceStatusReportRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::OsUpdateStatus*
Arena::CreateMaybeMessage< ::enterprise_management::OsUpdateStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::OsUpdateStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AppStatus*
Arena::CreateMaybeMessage< ::enterprise_management::AppStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AppStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AppInfo*
Arena::CreateMaybeMessage< ::enterprise_management::AppInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AppInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AndroidAppPermission*
Arena::CreateMaybeMessage< ::enterprise_management::AndroidAppPermission >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AndroidAppPermission >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AndroidAppInfo*
Arena::CreateMaybeMessage< ::enterprise_management::AndroidAppInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AndroidAppInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ChromeUserProfileReport*
Arena::CreateMaybeMessage< ::enterprise_management::ChromeUserProfileReport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ChromeUserProfileReport >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ChromeSignedInUser*
Arena::CreateMaybeMessage< ::enterprise_management::ChromeSignedInUser >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ChromeSignedInUser >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ExtensionRequest*
Arena::CreateMaybeMessage< ::enterprise_management::ExtensionRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ExtensionRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::Extension*
Arena::CreateMaybeMessage< ::enterprise_management::Extension >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::Extension >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::Plugin*
Arena::CreateMaybeMessage< ::enterprise_management::Plugin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::Plugin >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::Policy*
Arena::CreateMaybeMessage< ::enterprise_management::Policy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::Policy >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ExtensionPolicy*
Arena::CreateMaybeMessage< ::enterprise_management::ExtensionPolicy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ExtensionPolicy >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PolicyFetchTimestamp*
Arena::CreateMaybeMessage< ::enterprise_management::PolicyFetchTimestamp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PolicyFetchTimestamp >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ChromeUserProfileInfo*
Arena::CreateMaybeMessage< ::enterprise_management::ChromeUserProfileInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ChromeUserProfileInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::BrowserReport*
Arena::CreateMaybeMessage< ::enterprise_management::BrowserReport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::BrowserReport >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::OSReport*
Arena::CreateMaybeMessage< ::enterprise_management::OSReport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::OSReport >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ChromeDesktopReportRequest*
Arena::CreateMaybeMessage< ::enterprise_management::ChromeDesktopReportRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ChromeDesktopReportRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ChromeOsUserReportRequest*
Arena::CreateMaybeMessage< ::enterprise_management::ChromeOsUserReportRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ChromeOsUserReportRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ChromeProfileReportRequest*
Arena::CreateMaybeMessage< ::enterprise_management::ChromeProfileReportRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ChromeProfileReportRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PolicyValueValidationIssue*
Arena::CreateMaybeMessage< ::enterprise_management::PolicyValueValidationIssue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PolicyValueValidationIssue >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PolicyValidationReportRequest*
Arena::CreateMaybeMessage< ::enterprise_management::PolicyValidationReportRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PolicyValidationReportRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PolicyValidationReportResponse*
Arena::CreateMaybeMessage< ::enterprise_management::PolicyValidationReportResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PolicyValidationReportResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AndroidStatus*
Arena::CreateMaybeMessage< ::enterprise_management::AndroidStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AndroidStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CrostiniApp*
Arena::CreateMaybeMessage< ::enterprise_management::CrostiniApp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CrostiniApp >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CrostiniStatus*
Arena::CreateMaybeMessage< ::enterprise_management::CrostiniStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CrostiniStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::SessionStatusReportRequest*
Arena::CreateMaybeMessage< ::enterprise_management::SessionStatusReportRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::SessionStatusReportRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceStatusReportResponse*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceStatusReportResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceStatusReportResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ChromeDesktopReportResponse*
Arena::CreateMaybeMessage< ::enterprise_management::ChromeDesktopReportResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ChromeDesktopReportResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ChromeOsUserReportResponse*
Arena::CreateMaybeMessage< ::enterprise_management::ChromeOsUserReportResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ChromeOsUserReportResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ChromeProfileReportResponse*
Arena::CreateMaybeMessage< ::enterprise_management::ChromeProfileReportResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ChromeProfileReportResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::SessionStatusReportResponse*
Arena::CreateMaybeMessage< ::enterprise_management::SessionStatusReportResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::SessionStatusReportResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PrivateSetMembershipRequest*
Arena::CreateMaybeMessage< ::enterprise_management::PrivateSetMembershipRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PrivateSetMembershipRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PrivateSetMembershipResponse*
Arena::CreateMaybeMessage< ::enterprise_management::PrivateSetMembershipResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PrivateSetMembershipResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PrivateSetMembershipRlweRequest*
Arena::CreateMaybeMessage< ::enterprise_management::PrivateSetMembershipRlweRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PrivateSetMembershipRlweRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PrivateSetMembershipRlweResponse*
Arena::CreateMaybeMessage< ::enterprise_management::PrivateSetMembershipRlweResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PrivateSetMembershipRlweResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceAutoEnrollmentRequest*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceAutoEnrollmentRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceAutoEnrollmentRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceAutoEnrollmentResponse*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceAutoEnrollmentResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceAutoEnrollmentResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceStateRetrievalRequest*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceStateRetrievalRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceStateRetrievalRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceStateKeyUpdateRequest*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceStateKeyUpdateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceStateKeyUpdateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceStateRetrievalResponse*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceStateRetrievalResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceStateRetrievalResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceInitialEnrollmentStateRequest*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceInitialEnrollmentStateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceInitialEnrollmentStateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceInitialEnrollmentStateResponse*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceInitialEnrollmentStateResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceInitialEnrollmentStateResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DevicePairingRequest*
Arena::CreateMaybeMessage< ::enterprise_management::DevicePairingRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DevicePairingRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DevicePairingResponse*
Arena::CreateMaybeMessage< ::enterprise_management::DevicePairingResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DevicePairingResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CheckDevicePairingRequest*
Arena::CreateMaybeMessage< ::enterprise_management::CheckDevicePairingRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CheckDevicePairingRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CheckDevicePairingResponse*
Arena::CreateMaybeMessage< ::enterprise_management::CheckDevicePairingResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CheckDevicePairingResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::RemoteCommand*
Arena::CreateMaybeMessage< ::enterprise_management::RemoteCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::RemoteCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::RemoteCommandResult*
Arena::CreateMaybeMessage< ::enterprise_management::RemoteCommandResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::RemoteCommandResult >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceRemoteCommandRequest*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceRemoteCommandRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceRemoteCommandRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceRemoteCommandResponse*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceRemoteCommandResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceRemoteCommandResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceAttributeUpdatePermissionRequest*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceAttributeUpdatePermissionRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceAttributeUpdatePermissionRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceAttributeUpdatePermissionResponse*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceAttributeUpdatePermissionResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceAttributeUpdatePermissionResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceAttributeUpdateRequest*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceAttributeUpdateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceAttributeUpdateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceAttributeUpdateResponse*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceAttributeUpdateResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceAttributeUpdateResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::GcmIdUpdateRequest*
Arena::CreateMaybeMessage< ::enterprise_management::GcmIdUpdateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::GcmIdUpdateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::GcmIdUpdateResponse*
Arena::CreateMaybeMessage< ::enterprise_management::GcmIdUpdateResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::GcmIdUpdateResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CheckAndroidManagementRequest*
Arena::CreateMaybeMessage< ::enterprise_management::CheckAndroidManagementRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CheckAndroidManagementRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CheckAndroidManagementResponse*
Arena::CreateMaybeMessage< ::enterprise_management::CheckAndroidManagementResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CheckAndroidManagementResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CertificateBasedDeviceRegisterRequest*
Arena::CreateMaybeMessage< ::enterprise_management::CertificateBasedDeviceRegisterRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CertificateBasedDeviceRegisterRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceRegisterConfiguration*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceRegisterConfiguration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceRegisterConfiguration >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CertificateBasedDeviceRegistrationData*
Arena::CreateMaybeMessage< ::enterprise_management::CertificateBasedDeviceRegistrationData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CertificateBasedDeviceRegistrationData >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::RegisterBrowserRequest*
Arena::CreateMaybeMessage< ::enterprise_management::RegisterBrowserRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::RegisterBrowserRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest*
Arena::CreateMaybeMessage< ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ActiveDirectoryEnrollPlayUserRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse*
Arena::CreateMaybeMessage< ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ActiveDirectoryEnrollPlayUserResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::SamlParametersProto*
Arena::CreateMaybeMessage< ::enterprise_management::SamlParametersProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::SamlParametersProto >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PublicSamlUserRequest*
Arena::CreateMaybeMessage< ::enterprise_management::PublicSamlUserRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PublicSamlUserRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PublicSamlUserResponse*
Arena::CreateMaybeMessage< ::enterprise_management::PublicSamlUserResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PublicSamlUserResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ActiveDirectoryPlayActivityRequest*
Arena::CreateMaybeMessage< ::enterprise_management::ActiveDirectoryPlayActivityRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ActiveDirectoryPlayActivityRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ActiveDirectoryPlayActivityResponse*
Arena::CreateMaybeMessage< ::enterprise_management::ActiveDirectoryPlayActivityResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ActiveDirectoryPlayActivityResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CheckDeviceLicenseRequest*
Arena::CreateMaybeMessage< ::enterprise_management::CheckDeviceLicenseRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CheckDeviceLicenseRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::LicenseAvailability*
Arena::CreateMaybeMessage< ::enterprise_management::LicenseAvailability >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::LicenseAvailability >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CheckDeviceLicenseResponse*
Arena::CreateMaybeMessage< ::enterprise_management::CheckDeviceLicenseResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CheckDeviceLicenseResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ActiveDirectoryUserSigninRequest*
Arena::CreateMaybeMessage< ::enterprise_management::ActiveDirectoryUserSigninRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ActiveDirectoryUserSigninRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ActiveDirectoryUserSigninResponse*
Arena::CreateMaybeMessage< ::enterprise_management::ActiveDirectoryUserSigninResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ActiveDirectoryUserSigninResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::TpmVersionInfo*
Arena::CreateMaybeMessage< ::enterprise_management::TpmVersionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::TpmVersionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::TpmStatusInfo*
Arena::CreateMaybeMessage< ::enterprise_management::TpmStatusInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::TpmStatusInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::TpmSupportedFeatures*
Arena::CreateMaybeMessage< ::enterprise_management::TpmSupportedFeatures >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::TpmSupportedFeatures >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::SystemState*
Arena::CreateMaybeMessage< ::enterprise_management::SystemState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::SystemState >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ExtensionInstallReportLogEvent*
Arena::CreateMaybeMessage< ::enterprise_management::ExtensionInstallReportLogEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ExtensionInstallReportLogEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AppInstallReportLogEvent*
Arena::CreateMaybeMessage< ::enterprise_management::AppInstallReportLogEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AppInstallReportLogEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ExtensionInstallReport*
Arena::CreateMaybeMessage< ::enterprise_management::ExtensionInstallReport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ExtensionInstallReport >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AppInstallReport*
Arena::CreateMaybeMessage< ::enterprise_management::AppInstallReport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AppInstallReport >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AppInstallReportRequest*
Arena::CreateMaybeMessage< ::enterprise_management::AppInstallReportRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AppInstallReportRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ExtensionInstallReportRequest*
Arena::CreateMaybeMessage< ::enterprise_management::ExtensionInstallReportRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ExtensionInstallReportRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AppInstallReportResponse*
Arena::CreateMaybeMessage< ::enterprise_management::AppInstallReportResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AppInstallReportResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::RefreshAccountRequest*
Arena::CreateMaybeMessage< ::enterprise_management::RefreshAccountRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::RefreshAccountRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::RefreshAccountResponse*
Arena::CreateMaybeMessage< ::enterprise_management::RefreshAccountResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::RefreshAccountResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::RsuLookupKeyUploadRequest*
Arena::CreateMaybeMessage< ::enterprise_management::RsuLookupKeyUploadRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::RsuLookupKeyUploadRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::RsuLookupKeyUploadResponse*
Arena::CreateMaybeMessage< ::enterprise_management::RsuLookupKeyUploadResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::RsuLookupKeyUploadResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ESimProfileInfo*
Arena::CreateMaybeMessage< ::enterprise_management::ESimProfileInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ESimProfileInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::UploadEuiccInfoRequest*
Arena::CreateMaybeMessage< ::enterprise_management::UploadEuiccInfoRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::UploadEuiccInfoRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::UploadEuiccInfoResponse*
Arena::CreateMaybeMessage< ::enterprise_management::UploadEuiccInfoResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::UploadEuiccInfoResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PrintJobEvent_PrintJobConfiguration*
Arena::CreateMaybeMessage< ::enterprise_management::PrintJobEvent_PrintJobConfiguration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PrintJobEvent_PrintJobConfiguration >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PrintJobEvent_Printer*
Arena::CreateMaybeMessage< ::enterprise_management::PrintJobEvent_Printer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PrintJobEvent_Printer >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize*
Arena::CreateMaybeMessage< ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PrintJobEvent_PrintSettings_MediaSize >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PrintJobEvent_PrintSettings*
Arena::CreateMaybeMessage< ::enterprise_management::PrintJobEvent_PrintSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PrintJobEvent_PrintSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::PrintJobEvent*
Arena::CreateMaybeMessage< ::enterprise_management::PrintJobEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::PrintJobEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::App*
Arena::CreateMaybeMessage< ::enterprise_management::App >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::App >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::AppActivity*
Arena::CreateMaybeMessage< ::enterprise_management::AppActivity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::AppActivity >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ScreenTimeSpan*
Arena::CreateMaybeMessage< ::enterprise_management::ScreenTimeSpan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ScreenTimeSpan >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ChildStatusReportRequest*
Arena::CreateMaybeMessage< ::enterprise_management::ChildStatusReportRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ChildStatusReportRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ChildStatusReportResponse*
Arena::CreateMaybeMessage< ::enterprise_management::ChildStatusReportResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ChildStatusReportResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::StartCsrRequest*
Arena::CreateMaybeMessage< ::enterprise_management::StartCsrRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::StartCsrRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::StartCsrResponse*
Arena::CreateMaybeMessage< ::enterprise_management::StartCsrResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::StartCsrResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::FinishCsrRequest*
Arena::CreateMaybeMessage< ::enterprise_management::FinishCsrRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::FinishCsrRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::FinishCsrResponse*
Arena::CreateMaybeMessage< ::enterprise_management::FinishCsrResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::FinishCsrResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DownloadCertRequest*
Arena::CreateMaybeMessage< ::enterprise_management::DownloadCertRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DownloadCertRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DownloadCertResponse*
Arena::CreateMaybeMessage< ::enterprise_management::DownloadCertResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DownloadCertResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CertProvStartOrContinueRequest*
Arena::CreateMaybeMessage< ::enterprise_management::CertProvStartOrContinueRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CertProvStartOrContinueRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CertProvAuthorizeRequest*
Arena::CreateMaybeMessage< ::enterprise_management::CertProvAuthorizeRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CertProvAuthorizeRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CertProvUploadProofOfPossessionRequest*
Arena::CreateMaybeMessage< ::enterprise_management::CertProvUploadProofOfPossessionRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CertProvUploadProofOfPossessionRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CertProvTryLaterInstruction*
Arena::CreateMaybeMessage< ::enterprise_management::CertProvTryLaterInstruction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CertProvTryLaterInstruction >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CertProvAuthorizeInstruction*
Arena::CreateMaybeMessage< ::enterprise_management::CertProvAuthorizeInstruction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CertProvAuthorizeInstruction >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CertProvProofOfPossessionInstruction*
Arena::CreateMaybeMessage< ::enterprise_management::CertProvProofOfPossessionInstruction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CertProvProofOfPossessionInstruction >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CertProvImportCertificateInstruction*
Arena::CreateMaybeMessage< ::enterprise_management::CertProvImportCertificateInstruction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CertProvImportCertificateInstruction >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::CertProvNextActionResponse*
Arena::CreateMaybeMessage< ::enterprise_management::CertProvNextActionResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::CertProvNextActionResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ClientCertificateProvisioningRequest*
Arena::CreateMaybeMessage< ::enterprise_management::ClientCertificateProvisioningRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ClientCertificateProvisioningRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::ClientCertificateProvisioningResponse*
Arena::CreateMaybeMessage< ::enterprise_management::ClientCertificateProvisioningResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::ClientCertificateProvisioningResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::BrowserPublicKeyUploadRequest*
Arena::CreateMaybeMessage< ::enterprise_management::BrowserPublicKeyUploadRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::BrowserPublicKeyUploadRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::BrowserPublicKeyUploadResponse*
Arena::CreateMaybeMessage< ::enterprise_management::BrowserPublicKeyUploadResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::BrowserPublicKeyUploadResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceManagementRequest*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceManagementRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceManagementRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceManagementResponse*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceManagementResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceManagementResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_management::DeviceStateRetrievalInfo*
Arena::CreateMaybeMessage< ::enterprise_management::DeviceStateRetrievalInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_management::DeviceStateRetrievalInfo >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
